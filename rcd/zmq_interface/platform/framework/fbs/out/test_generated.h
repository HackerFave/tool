// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TEST_H_
#define FLATBUFFERS_GENERATED_TEST_H_

#include "flatbuffers/flatbuffers.h"

struct Repeat;
struct RepeatBuilder;
struct RepeatT;

struct MsgTest;
struct MsgTestBuilder;
struct MsgTestT;

struct MsgRequest;
struct MsgRequestBuilder;
struct MsgRequestT;

struct MsgResponse;
struct MsgResponseBuilder;
struct MsgResponseT;

bool operator==(const RepeatT &lhs, const RepeatT &rhs);
bool operator!=(const RepeatT &lhs, const RepeatT &rhs);
bool operator==(const MsgTestT &lhs, const MsgTestT &rhs);
bool operator!=(const MsgTestT &lhs, const MsgTestT &rhs);
bool operator==(const MsgRequestT &lhs, const MsgRequestT &rhs);
bool operator!=(const MsgRequestT &lhs, const MsgRequestT &rhs);
bool operator==(const MsgResponseT &lhs, const MsgResponseT &rhs);
bool operator!=(const MsgResponseT &lhs, const MsgResponseT &rhs);

inline const flatbuffers::TypeTable *RepeatTypeTable();

inline const flatbuffers::TypeTable *MsgTestTypeTable();

inline const flatbuffers::TypeTable *MsgRequestTypeTable();

inline const flatbuffers::TypeTable *MsgResponseTypeTable();

struct RepeatT : public flatbuffers::NativeTable {
  typedef Repeat TableType;
  int32_t id;
  RepeatT()
      : id(0) {
  }
};

inline bool operator==(const RepeatT &lhs, const RepeatT &rhs) {
  return
      (lhs.id == rhs.id);
}

inline bool operator!=(const RepeatT &lhs, const RepeatT &rhs) {
    return !(lhs == rhs);
}


struct Repeat FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RepeatT NativeTableType;
  typedef RepeatBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RepeatTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  bool mutate_id(int32_t _id) {
    return SetField<int32_t>(VT_ID, _id, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           verifier.EndTable();
  }
  RepeatT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RepeatT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Repeat> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RepeatT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RepeatBuilder {
  typedef Repeat Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(Repeat::VT_ID, id, 0);
  }
  explicit RepeatBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Repeat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Repeat>(end);
    return o;
  }
};

inline flatbuffers::Offset<Repeat> CreateRepeat(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0) {
  RepeatBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

flatbuffers::Offset<Repeat> CreateRepeat(flatbuffers::FlatBufferBuilder &_fbb, const RepeatT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MsgTestT : public flatbuffers::NativeTable {
  typedef MsgTest TableType;
  uint8_t result;
  uint64_t time;
  std::vector<std::unique_ptr<RepeatT>> array;
  MsgTestT()
      : result(0),
        time(0) {
  }
};

inline bool operator==(const MsgTestT &lhs, const MsgTestT &rhs) {
  return
      (lhs.result == rhs.result) &&
      (lhs.time == rhs.time) &&
      (lhs.array == rhs.array);
}

inline bool operator!=(const MsgTestT &lhs, const MsgTestT &rhs) {
    return !(lhs == rhs);
}


struct MsgTest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MsgTestT NativeTableType;
  typedef MsgTestBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MsgTestTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4,
    VT_TIME = 6,
    VT_ARRAY = 8
  };
  uint8_t result() const {
    return GetField<uint8_t>(VT_RESULT, 0);
  }
  bool mutate_result(uint8_t _result) {
    return SetField<uint8_t>(VT_RESULT, _result, 0);
  }
  uint64_t time() const {
    return GetField<uint64_t>(VT_TIME, 0);
  }
  bool mutate_time(uint64_t _time) {
    return SetField<uint64_t>(VT_TIME, _time, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Repeat>> *array() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Repeat>> *>(VT_ARRAY);
  }
  flatbuffers::Vector<flatbuffers::Offset<Repeat>> *mutable_array() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<Repeat>> *>(VT_ARRAY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_RESULT) &&
           VerifyField<uint64_t>(verifier, VT_TIME) &&
           VerifyOffset(verifier, VT_ARRAY) &&
           verifier.VerifyVector(array()) &&
           verifier.VerifyVectorOfTables(array()) &&
           verifier.EndTable();
  }
  MsgTestT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MsgTestT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MsgTest> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MsgTestT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MsgTestBuilder {
  typedef MsgTest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_result(uint8_t result) {
    fbb_.AddElement<uint8_t>(MsgTest::VT_RESULT, result, 0);
  }
  void add_time(uint64_t time) {
    fbb_.AddElement<uint64_t>(MsgTest::VT_TIME, time, 0);
  }
  void add_array(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Repeat>>> array) {
    fbb_.AddOffset(MsgTest::VT_ARRAY, array);
  }
  explicit MsgTestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MsgTest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MsgTest>(end);
    return o;
  }
};

inline flatbuffers::Offset<MsgTest> CreateMsgTest(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t result = 0,
    uint64_t time = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Repeat>>> array = 0) {
  MsgTestBuilder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_array(array);
  builder_.add_result(result);
  return builder_.Finish();
}

inline flatbuffers::Offset<MsgTest> CreateMsgTestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t result = 0,
    uint64_t time = 0,
    const std::vector<flatbuffers::Offset<Repeat>> *array = nullptr) {
  auto array__ = array ? _fbb.CreateVector<flatbuffers::Offset<Repeat>>(*array) : 0;
  return CreateMsgTest(
      _fbb,
      result,
      time,
      array__);
}

flatbuffers::Offset<MsgTest> CreateMsgTest(flatbuffers::FlatBufferBuilder &_fbb, const MsgTestT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MsgRequestT : public flatbuffers::NativeTable {
  typedef MsgRequest TableType;
  std::string request;
  MsgRequestT() {
  }
};

inline bool operator==(const MsgRequestT &lhs, const MsgRequestT &rhs) {
  return
      (lhs.request == rhs.request);
}

inline bool operator!=(const MsgRequestT &lhs, const MsgRequestT &rhs) {
    return !(lhs == rhs);
}


struct MsgRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MsgRequestT NativeTableType;
  typedef MsgRequestBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MsgRequestTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REQUEST = 4
  };
  const flatbuffers::String *request() const {
    return GetPointer<const flatbuffers::String *>(VT_REQUEST);
  }
  flatbuffers::String *mutable_request() {
    return GetPointer<flatbuffers::String *>(VT_REQUEST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_REQUEST) &&
           verifier.VerifyString(request()) &&
           verifier.EndTable();
  }
  MsgRequestT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MsgRequestT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MsgRequest> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MsgRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MsgRequestBuilder {
  typedef MsgRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_request(flatbuffers::Offset<flatbuffers::String> request) {
    fbb_.AddOffset(MsgRequest::VT_REQUEST, request);
  }
  explicit MsgRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MsgRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MsgRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<MsgRequest> CreateMsgRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> request = 0) {
  MsgRequestBuilder builder_(_fbb);
  builder_.add_request(request);
  return builder_.Finish();
}

inline flatbuffers::Offset<MsgRequest> CreateMsgRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *request = nullptr) {
  auto request__ = request ? _fbb.CreateString(request) : 0;
  return CreateMsgRequest(
      _fbb,
      request__);
}

flatbuffers::Offset<MsgRequest> CreateMsgRequest(flatbuffers::FlatBufferBuilder &_fbb, const MsgRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MsgResponseT : public flatbuffers::NativeTable {
  typedef MsgResponse TableType;
  std::string response;
  MsgResponseT() {
  }
};

inline bool operator==(const MsgResponseT &lhs, const MsgResponseT &rhs) {
  return
      (lhs.response == rhs.response);
}

inline bool operator!=(const MsgResponseT &lhs, const MsgResponseT &rhs) {
    return !(lhs == rhs);
}


struct MsgResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MsgResponseT NativeTableType;
  typedef MsgResponseBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MsgResponseTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESPONSE = 4
  };
  const flatbuffers::String *response() const {
    return GetPointer<const flatbuffers::String *>(VT_RESPONSE);
  }
  flatbuffers::String *mutable_response() {
    return GetPointer<flatbuffers::String *>(VT_RESPONSE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RESPONSE) &&
           verifier.VerifyString(response()) &&
           verifier.EndTable();
  }
  MsgResponseT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MsgResponseT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MsgResponse> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MsgResponseT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MsgResponseBuilder {
  typedef MsgResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_response(flatbuffers::Offset<flatbuffers::String> response) {
    fbb_.AddOffset(MsgResponse::VT_RESPONSE, response);
  }
  explicit MsgResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MsgResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MsgResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<MsgResponse> CreateMsgResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> response = 0) {
  MsgResponseBuilder builder_(_fbb);
  builder_.add_response(response);
  return builder_.Finish();
}

inline flatbuffers::Offset<MsgResponse> CreateMsgResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *response = nullptr) {
  auto response__ = response ? _fbb.CreateString(response) : 0;
  return CreateMsgResponse(
      _fbb,
      response__);
}

flatbuffers::Offset<MsgResponse> CreateMsgResponse(flatbuffers::FlatBufferBuilder &_fbb, const MsgResponseT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline RepeatT *Repeat::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<RepeatT> _o = std::unique_ptr<RepeatT>(new RepeatT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Repeat::UnPackTo(RepeatT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; }
}

inline flatbuffers::Offset<Repeat> Repeat::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RepeatT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRepeat(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Repeat> CreateRepeat(flatbuffers::FlatBufferBuilder &_fbb, const RepeatT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RepeatT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  return CreateRepeat(
      _fbb,
      _id);
}

inline MsgTestT *MsgTest::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<MsgTestT> _o = std::unique_ptr<MsgTestT>(new MsgTestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MsgTest::UnPackTo(MsgTestT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = result(); _o->result = _e; }
  { auto _e = time(); _o->time = _e; }
  { auto _e = array(); if (_e) { _o->array.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->array[_i] = std::unique_ptr<RepeatT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<MsgTest> MsgTest::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MsgTestT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMsgTest(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MsgTest> CreateMsgTest(flatbuffers::FlatBufferBuilder &_fbb, const MsgTestT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MsgTestT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _result = _o->result;
  auto _time = _o->time;
  auto _array = _o->array.size() ? _fbb.CreateVector<flatbuffers::Offset<Repeat>> (_o->array.size(), [](size_t i, _VectorArgs *__va) { return CreateRepeat(*__va->__fbb, __va->__o->array[i].get(), __va->__rehasher); }, &_va ) : 0;
  return CreateMsgTest(
      _fbb,
      _result,
      _time,
      _array);
}

inline MsgRequestT *MsgRequest::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<MsgRequestT> _o = std::unique_ptr<MsgRequestT>(new MsgRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MsgRequest::UnPackTo(MsgRequestT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = request(); if (_e) _o->request = _e->str(); }
}

inline flatbuffers::Offset<MsgRequest> MsgRequest::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MsgRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMsgRequest(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MsgRequest> CreateMsgRequest(flatbuffers::FlatBufferBuilder &_fbb, const MsgRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MsgRequestT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _request = _o->request.empty() ? 0 : _fbb.CreateString(_o->request);
  return CreateMsgRequest(
      _fbb,
      _request);
}

inline MsgResponseT *MsgResponse::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<MsgResponseT> _o = std::unique_ptr<MsgResponseT>(new MsgResponseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MsgResponse::UnPackTo(MsgResponseT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = response(); if (_e) _o->response = _e->str(); }
}

inline flatbuffers::Offset<MsgResponse> MsgResponse::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MsgResponseT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMsgResponse(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MsgResponse> CreateMsgResponse(flatbuffers::FlatBufferBuilder &_fbb, const MsgResponseT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MsgResponseT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _response = _o->response.empty() ? 0 : _fbb.CreateString(_o->response);
  return CreateMsgResponse(
      _fbb,
      _response);
}

inline const flatbuffers::TypeTable *RepeatTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "id"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MsgTestTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    RepeatTypeTable
  };
  static const char * const names[] = {
    "result",
    "time",
    "array"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MsgRequestTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "request"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MsgResponseTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "response"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

#endif  // FLATBUFFERS_GENERATED_TEST_H_
