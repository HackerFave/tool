// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_DECISION_DECISION_H_
#define FLATBUFFERS_GENERATED_DECISION_DECISION_H_

#include "flatbuffers/flatbuffers.h"

namespace decision {

struct LatLonHead;
struct LatLonHeadBuilder;
struct LatLonHeadT;

struct Output;
struct OutputBuilder;
struct OutputT;

struct RoadTaskVehicleInfo;
struct RoadTaskVehicleInfoBuilder;
struct RoadTaskVehicleInfoT;

struct Msg1030;
struct Msg1030Builder;
struct Msg1030T;

struct Msg1050;
struct Msg1050Builder;
struct Msg1050T;

struct Msg2062;
struct Msg2062Builder;
struct Msg2062T;

struct Msg0404;
struct Msg0404Builder;
struct Msg0404T;

struct Msg0500;
struct Msg0500Builder;
struct Msg0500T;

struct Msg0501;
struct Msg0501Builder;
struct Msg0501T;

struct Msg8F1C;
struct Msg8F1CBuilder;
struct Msg8F1CT;

bool operator==(const LatLonHeadT &lhs, const LatLonHeadT &rhs);
bool operator!=(const LatLonHeadT &lhs, const LatLonHeadT &rhs);
bool operator==(const OutputT &lhs, const OutputT &rhs);
bool operator!=(const OutputT &lhs, const OutputT &rhs);
bool operator==(const RoadTaskVehicleInfoT &lhs, const RoadTaskVehicleInfoT &rhs);
bool operator!=(const RoadTaskVehicleInfoT &lhs, const RoadTaskVehicleInfoT &rhs);
bool operator==(const Msg1030T &lhs, const Msg1030T &rhs);
bool operator!=(const Msg1030T &lhs, const Msg1030T &rhs);
bool operator==(const Msg1050T &lhs, const Msg1050T &rhs);
bool operator!=(const Msg1050T &lhs, const Msg1050T &rhs);
bool operator==(const Msg2062T &lhs, const Msg2062T &rhs);
bool operator!=(const Msg2062T &lhs, const Msg2062T &rhs);
bool operator==(const Msg0404T &lhs, const Msg0404T &rhs);
bool operator!=(const Msg0404T &lhs, const Msg0404T &rhs);
bool operator==(const Msg0500T &lhs, const Msg0500T &rhs);
bool operator!=(const Msg0500T &lhs, const Msg0500T &rhs);
bool operator==(const Msg0501T &lhs, const Msg0501T &rhs);
bool operator!=(const Msg0501T &lhs, const Msg0501T &rhs);
bool operator==(const Msg8F1CT &lhs, const Msg8F1CT &rhs);
bool operator!=(const Msg8F1CT &lhs, const Msg8F1CT &rhs);

inline const flatbuffers::TypeTable *LatLonHeadTypeTable();

inline const flatbuffers::TypeTable *OutputTypeTable();

inline const flatbuffers::TypeTable *RoadTaskVehicleInfoTypeTable();

inline const flatbuffers::TypeTable *Msg1030TypeTable();

inline const flatbuffers::TypeTable *Msg1050TypeTable();

inline const flatbuffers::TypeTable *Msg2062TypeTable();

inline const flatbuffers::TypeTable *Msg0404TypeTable();

inline const flatbuffers::TypeTable *Msg0500TypeTable();

inline const flatbuffers::TypeTable *Msg0501TypeTable();

inline const flatbuffers::TypeTable *Msg8F1CTypeTable();

struct LatLonHeadT : public flatbuffers::NativeTable {
  typedef LatLonHead TableType;
  double lat;
  double lng;
  double head;
  LatLonHeadT()
      : lat(0.0),
        lng(0.0),
        head(0.0) {
  }
};

inline bool operator==(const LatLonHeadT &lhs, const LatLonHeadT &rhs) {
  return
      (lhs.lat == rhs.lat) &&
      (lhs.lng == rhs.lng) &&
      (lhs.head == rhs.head);
}

inline bool operator!=(const LatLonHeadT &lhs, const LatLonHeadT &rhs) {
    return !(lhs == rhs);
}


struct LatLonHead FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LatLonHeadT NativeTableType;
  typedef LatLonHeadBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LatLonHeadTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LAT = 4,
    VT_LNG = 6,
    VT_HEAD = 8
  };
  double lat() const {
    return GetField<double>(VT_LAT, 0.0);
  }
  bool mutate_lat(double _lat) {
    return SetField<double>(VT_LAT, _lat, 0.0);
  }
  double lng() const {
    return GetField<double>(VT_LNG, 0.0);
  }
  bool mutate_lng(double _lng) {
    return SetField<double>(VT_LNG, _lng, 0.0);
  }
  double head() const {
    return GetField<double>(VT_HEAD, 0.0);
  }
  bool mutate_head(double _head) {
    return SetField<double>(VT_HEAD, _head, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_LAT) &&
           VerifyField<double>(verifier, VT_LNG) &&
           VerifyField<double>(verifier, VT_HEAD) &&
           verifier.EndTable();
  }
  LatLonHeadT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LatLonHeadT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LatLonHead> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LatLonHeadT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LatLonHeadBuilder {
  typedef LatLonHead Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_lat(double lat) {
    fbb_.AddElement<double>(LatLonHead::VT_LAT, lat, 0.0);
  }
  void add_lng(double lng) {
    fbb_.AddElement<double>(LatLonHead::VT_LNG, lng, 0.0);
  }
  void add_head(double head) {
    fbb_.AddElement<double>(LatLonHead::VT_HEAD, head, 0.0);
  }
  explicit LatLonHeadBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LatLonHead> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LatLonHead>(end);
    return o;
  }
};

inline flatbuffers::Offset<LatLonHead> CreateLatLonHead(
    flatbuffers::FlatBufferBuilder &_fbb,
    double lat = 0.0,
    double lng = 0.0,
    double head = 0.0) {
  LatLonHeadBuilder builder_(_fbb);
  builder_.add_head(head);
  builder_.add_lng(lng);
  builder_.add_lat(lat);
  return builder_.Finish();
}

flatbuffers::Offset<LatLonHead> CreateLatLonHead(flatbuffers::FlatBufferBuilder &_fbb, const LatLonHeadT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct OutputT : public flatbuffers::NativeTable {
  typedef Output TableType;
  uint8_t drive_mode;
  uint8_t drive_mode_last;
  uint8_t drive_state;
  uint8_t drive_state_last;
  uint16_t drive_state_child;
  uint16_t drive_state_child_last;
  uint16_t fault;
  int32_t target_key_point;
  uint32_t GpsPathList;
  int32_t point_key;
  std::unique_ptr<decision::LatLonHeadT> park_point;
  std::unique_ptr<decision::LatLonHeadT> park_error;
  float ti_task_speed;
  int32_t terminal;
  uint8_t exec_cmd;
  uint8_t load_status;
  std::string drive_state_desc;
  std::string drive_state_child_desc;
  bool single_mode;
  uint32_t reference_line;
  bool detour;
  OutputT()
      : drive_mode(0),
        drive_mode_last(0),
        drive_state(0),
        drive_state_last(0),
        drive_state_child(0),
        drive_state_child_last(0),
        fault(0),
        target_key_point(0),
        GpsPathList(0),
        point_key(0),
        ti_task_speed(0.0f),
        terminal(0),
        exec_cmd(0),
        load_status(0),
        single_mode(false),
        reference_line(0),
        detour(false) {
  }
};

inline bool operator==(const OutputT &lhs, const OutputT &rhs) {
  return
      (lhs.drive_mode == rhs.drive_mode) &&
      (lhs.drive_mode_last == rhs.drive_mode_last) &&
      (lhs.drive_state == rhs.drive_state) &&
      (lhs.drive_state_last == rhs.drive_state_last) &&
      (lhs.drive_state_child == rhs.drive_state_child) &&
      (lhs.drive_state_child_last == rhs.drive_state_child_last) &&
      (lhs.fault == rhs.fault) &&
      (lhs.target_key_point == rhs.target_key_point) &&
      (lhs.GpsPathList == rhs.GpsPathList) &&
      (lhs.point_key == rhs.point_key) &&
      (lhs.park_point == rhs.park_point) &&
      (lhs.park_error == rhs.park_error) &&
      (lhs.ti_task_speed == rhs.ti_task_speed) &&
      (lhs.terminal == rhs.terminal) &&
      (lhs.exec_cmd == rhs.exec_cmd) &&
      (lhs.load_status == rhs.load_status) &&
      (lhs.drive_state_desc == rhs.drive_state_desc) &&
      (lhs.drive_state_child_desc == rhs.drive_state_child_desc) &&
      (lhs.single_mode == rhs.single_mode) &&
      (lhs.reference_line == rhs.reference_line) &&
      (lhs.detour == rhs.detour);
}

inline bool operator!=(const OutputT &lhs, const OutputT &rhs) {
    return !(lhs == rhs);
}


struct Output FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OutputT NativeTableType;
  typedef OutputBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return OutputTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DRIVE_MODE = 4,
    VT_DRIVE_MODE_LAST = 6,
    VT_DRIVE_STATE = 8,
    VT_DRIVE_STATE_LAST = 10,
    VT_DRIVE_STATE_CHILD = 12,
    VT_DRIVE_STATE_CHILD_LAST = 14,
    VT_FAULT = 16,
    VT_TARGET_KEY_POINT = 18,
    VT_GPSPATHLIST = 20,
    VT_POINT_KEY = 22,
    VT_PARK_POINT = 24,
    VT_PARK_ERROR = 26,
    VT_TI_TASK_SPEED = 28,
    VT_TERMINAL = 30,
    VT_EXEC_CMD = 32,
    VT_LOAD_STATUS = 34,
    VT_DRIVE_STATE_DESC = 36,
    VT_DRIVE_STATE_CHILD_DESC = 38,
    VT_SINGLE_MODE = 40,
    VT_REFERENCE_LINE = 42,
    VT_DETOUR = 44
  };
  uint8_t drive_mode() const {
    return GetField<uint8_t>(VT_DRIVE_MODE, 0);
  }
  bool mutate_drive_mode(uint8_t _drive_mode) {
    return SetField<uint8_t>(VT_DRIVE_MODE, _drive_mode, 0);
  }
  uint8_t drive_mode_last() const {
    return GetField<uint8_t>(VT_DRIVE_MODE_LAST, 0);
  }
  bool mutate_drive_mode_last(uint8_t _drive_mode_last) {
    return SetField<uint8_t>(VT_DRIVE_MODE_LAST, _drive_mode_last, 0);
  }
  uint8_t drive_state() const {
    return GetField<uint8_t>(VT_DRIVE_STATE, 0);
  }
  bool mutate_drive_state(uint8_t _drive_state) {
    return SetField<uint8_t>(VT_DRIVE_STATE, _drive_state, 0);
  }
  uint8_t drive_state_last() const {
    return GetField<uint8_t>(VT_DRIVE_STATE_LAST, 0);
  }
  bool mutate_drive_state_last(uint8_t _drive_state_last) {
    return SetField<uint8_t>(VT_DRIVE_STATE_LAST, _drive_state_last, 0);
  }
  uint16_t drive_state_child() const {
    return GetField<uint16_t>(VT_DRIVE_STATE_CHILD, 0);
  }
  bool mutate_drive_state_child(uint16_t _drive_state_child) {
    return SetField<uint16_t>(VT_DRIVE_STATE_CHILD, _drive_state_child, 0);
  }
  uint16_t drive_state_child_last() const {
    return GetField<uint16_t>(VT_DRIVE_STATE_CHILD_LAST, 0);
  }
  bool mutate_drive_state_child_last(uint16_t _drive_state_child_last) {
    return SetField<uint16_t>(VT_DRIVE_STATE_CHILD_LAST, _drive_state_child_last, 0);
  }
  uint16_t fault() const {
    return GetField<uint16_t>(VT_FAULT, 0);
  }
  bool mutate_fault(uint16_t _fault) {
    return SetField<uint16_t>(VT_FAULT, _fault, 0);
  }
  int32_t target_key_point() const {
    return GetField<int32_t>(VT_TARGET_KEY_POINT, 0);
  }
  bool mutate_target_key_point(int32_t _target_key_point) {
    return SetField<int32_t>(VT_TARGET_KEY_POINT, _target_key_point, 0);
  }
  uint32_t GpsPathList() const {
    return GetField<uint32_t>(VT_GPSPATHLIST, 0);
  }
  bool mutate_GpsPathList(uint32_t _GpsPathList) {
    return SetField<uint32_t>(VT_GPSPATHLIST, _GpsPathList, 0);
  }
  int32_t point_key() const {
    return GetField<int32_t>(VT_POINT_KEY, 0);
  }
  bool mutate_point_key(int32_t _point_key) {
    return SetField<int32_t>(VT_POINT_KEY, _point_key, 0);
  }
  const decision::LatLonHead *park_point() const {
    return GetPointer<const decision::LatLonHead *>(VT_PARK_POINT);
  }
  decision::LatLonHead *mutable_park_point() {
    return GetPointer<decision::LatLonHead *>(VT_PARK_POINT);
  }
  const decision::LatLonHead *park_error() const {
    return GetPointer<const decision::LatLonHead *>(VT_PARK_ERROR);
  }
  decision::LatLonHead *mutable_park_error() {
    return GetPointer<decision::LatLonHead *>(VT_PARK_ERROR);
  }
  float ti_task_speed() const {
    return GetField<float>(VT_TI_TASK_SPEED, 0.0f);
  }
  bool mutate_ti_task_speed(float _ti_task_speed) {
    return SetField<float>(VT_TI_TASK_SPEED, _ti_task_speed, 0.0f);
  }
  int32_t terminal() const {
    return GetField<int32_t>(VT_TERMINAL, 0);
  }
  bool mutate_terminal(int32_t _terminal) {
    return SetField<int32_t>(VT_TERMINAL, _terminal, 0);
  }
  uint8_t exec_cmd() const {
    return GetField<uint8_t>(VT_EXEC_CMD, 0);
  }
  bool mutate_exec_cmd(uint8_t _exec_cmd) {
    return SetField<uint8_t>(VT_EXEC_CMD, _exec_cmd, 0);
  }
  uint8_t load_status() const {
    return GetField<uint8_t>(VT_LOAD_STATUS, 0);
  }
  bool mutate_load_status(uint8_t _load_status) {
    return SetField<uint8_t>(VT_LOAD_STATUS, _load_status, 0);
  }
  const flatbuffers::String *drive_state_desc() const {
    return GetPointer<const flatbuffers::String *>(VT_DRIVE_STATE_DESC);
  }
  flatbuffers::String *mutable_drive_state_desc() {
    return GetPointer<flatbuffers::String *>(VT_DRIVE_STATE_DESC);
  }
  const flatbuffers::String *drive_state_child_desc() const {
    return GetPointer<const flatbuffers::String *>(VT_DRIVE_STATE_CHILD_DESC);
  }
  flatbuffers::String *mutable_drive_state_child_desc() {
    return GetPointer<flatbuffers::String *>(VT_DRIVE_STATE_CHILD_DESC);
  }
  bool single_mode() const {
    return GetField<uint8_t>(VT_SINGLE_MODE, 0) != 0;
  }
  bool mutate_single_mode(bool _single_mode) {
    return SetField<uint8_t>(VT_SINGLE_MODE, static_cast<uint8_t>(_single_mode), 0);
  }
  uint32_t reference_line() const {
    return GetField<uint32_t>(VT_REFERENCE_LINE, 0);
  }
  bool mutate_reference_line(uint32_t _reference_line) {
    return SetField<uint32_t>(VT_REFERENCE_LINE, _reference_line, 0);
  }
  bool detour() const {
    return GetField<uint8_t>(VT_DETOUR, 0) != 0;
  }
  bool mutate_detour(bool _detour) {
    return SetField<uint8_t>(VT_DETOUR, static_cast<uint8_t>(_detour), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_DRIVE_MODE) &&
           VerifyField<uint8_t>(verifier, VT_DRIVE_MODE_LAST) &&
           VerifyField<uint8_t>(verifier, VT_DRIVE_STATE) &&
           VerifyField<uint8_t>(verifier, VT_DRIVE_STATE_LAST) &&
           VerifyField<uint16_t>(verifier, VT_DRIVE_STATE_CHILD) &&
           VerifyField<uint16_t>(verifier, VT_DRIVE_STATE_CHILD_LAST) &&
           VerifyField<uint16_t>(verifier, VT_FAULT) &&
           VerifyField<int32_t>(verifier, VT_TARGET_KEY_POINT) &&
           VerifyField<uint32_t>(verifier, VT_GPSPATHLIST) &&
           VerifyField<int32_t>(verifier, VT_POINT_KEY) &&
           VerifyOffset(verifier, VT_PARK_POINT) &&
           verifier.VerifyTable(park_point()) &&
           VerifyOffset(verifier, VT_PARK_ERROR) &&
           verifier.VerifyTable(park_error()) &&
           VerifyField<float>(verifier, VT_TI_TASK_SPEED) &&
           VerifyField<int32_t>(verifier, VT_TERMINAL) &&
           VerifyField<uint8_t>(verifier, VT_EXEC_CMD) &&
           VerifyField<uint8_t>(verifier, VT_LOAD_STATUS) &&
           VerifyOffset(verifier, VT_DRIVE_STATE_DESC) &&
           verifier.VerifyString(drive_state_desc()) &&
           VerifyOffset(verifier, VT_DRIVE_STATE_CHILD_DESC) &&
           verifier.VerifyString(drive_state_child_desc()) &&
           VerifyField<uint8_t>(verifier, VT_SINGLE_MODE) &&
           VerifyField<uint32_t>(verifier, VT_REFERENCE_LINE) &&
           VerifyField<uint8_t>(verifier, VT_DETOUR) &&
           verifier.EndTable();
  }
  OutputT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OutputT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Output> Pack(flatbuffers::FlatBufferBuilder &_fbb, const OutputT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct OutputBuilder {
  typedef Output Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_drive_mode(uint8_t drive_mode) {
    fbb_.AddElement<uint8_t>(Output::VT_DRIVE_MODE, drive_mode, 0);
  }
  void add_drive_mode_last(uint8_t drive_mode_last) {
    fbb_.AddElement<uint8_t>(Output::VT_DRIVE_MODE_LAST, drive_mode_last, 0);
  }
  void add_drive_state(uint8_t drive_state) {
    fbb_.AddElement<uint8_t>(Output::VT_DRIVE_STATE, drive_state, 0);
  }
  void add_drive_state_last(uint8_t drive_state_last) {
    fbb_.AddElement<uint8_t>(Output::VT_DRIVE_STATE_LAST, drive_state_last, 0);
  }
  void add_drive_state_child(uint16_t drive_state_child) {
    fbb_.AddElement<uint16_t>(Output::VT_DRIVE_STATE_CHILD, drive_state_child, 0);
  }
  void add_drive_state_child_last(uint16_t drive_state_child_last) {
    fbb_.AddElement<uint16_t>(Output::VT_DRIVE_STATE_CHILD_LAST, drive_state_child_last, 0);
  }
  void add_fault(uint16_t fault) {
    fbb_.AddElement<uint16_t>(Output::VT_FAULT, fault, 0);
  }
  void add_target_key_point(int32_t target_key_point) {
    fbb_.AddElement<int32_t>(Output::VT_TARGET_KEY_POINT, target_key_point, 0);
  }
  void add_GpsPathList(uint32_t GpsPathList) {
    fbb_.AddElement<uint32_t>(Output::VT_GPSPATHLIST, GpsPathList, 0);
  }
  void add_point_key(int32_t point_key) {
    fbb_.AddElement<int32_t>(Output::VT_POINT_KEY, point_key, 0);
  }
  void add_park_point(flatbuffers::Offset<decision::LatLonHead> park_point) {
    fbb_.AddOffset(Output::VT_PARK_POINT, park_point);
  }
  void add_park_error(flatbuffers::Offset<decision::LatLonHead> park_error) {
    fbb_.AddOffset(Output::VT_PARK_ERROR, park_error);
  }
  void add_ti_task_speed(float ti_task_speed) {
    fbb_.AddElement<float>(Output::VT_TI_TASK_SPEED, ti_task_speed, 0.0f);
  }
  void add_terminal(int32_t terminal) {
    fbb_.AddElement<int32_t>(Output::VT_TERMINAL, terminal, 0);
  }
  void add_exec_cmd(uint8_t exec_cmd) {
    fbb_.AddElement<uint8_t>(Output::VT_EXEC_CMD, exec_cmd, 0);
  }
  void add_load_status(uint8_t load_status) {
    fbb_.AddElement<uint8_t>(Output::VT_LOAD_STATUS, load_status, 0);
  }
  void add_drive_state_desc(flatbuffers::Offset<flatbuffers::String> drive_state_desc) {
    fbb_.AddOffset(Output::VT_DRIVE_STATE_DESC, drive_state_desc);
  }
  void add_drive_state_child_desc(flatbuffers::Offset<flatbuffers::String> drive_state_child_desc) {
    fbb_.AddOffset(Output::VT_DRIVE_STATE_CHILD_DESC, drive_state_child_desc);
  }
  void add_single_mode(bool single_mode) {
    fbb_.AddElement<uint8_t>(Output::VT_SINGLE_MODE, static_cast<uint8_t>(single_mode), 0);
  }
  void add_reference_line(uint32_t reference_line) {
    fbb_.AddElement<uint32_t>(Output::VT_REFERENCE_LINE, reference_line, 0);
  }
  void add_detour(bool detour) {
    fbb_.AddElement<uint8_t>(Output::VT_DETOUR, static_cast<uint8_t>(detour), 0);
  }
  explicit OutputBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Output> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Output>(end);
    return o;
  }
};

inline flatbuffers::Offset<Output> CreateOutput(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t drive_mode = 0,
    uint8_t drive_mode_last = 0,
    uint8_t drive_state = 0,
    uint8_t drive_state_last = 0,
    uint16_t drive_state_child = 0,
    uint16_t drive_state_child_last = 0,
    uint16_t fault = 0,
    int32_t target_key_point = 0,
    uint32_t GpsPathList = 0,
    int32_t point_key = 0,
    flatbuffers::Offset<decision::LatLonHead> park_point = 0,
    flatbuffers::Offset<decision::LatLonHead> park_error = 0,
    float ti_task_speed = 0.0f,
    int32_t terminal = 0,
    uint8_t exec_cmd = 0,
    uint8_t load_status = 0,
    flatbuffers::Offset<flatbuffers::String> drive_state_desc = 0,
    flatbuffers::Offset<flatbuffers::String> drive_state_child_desc = 0,
    bool single_mode = false,
    uint32_t reference_line = 0,
    bool detour = false) {
  OutputBuilder builder_(_fbb);
  builder_.add_reference_line(reference_line);
  builder_.add_drive_state_child_desc(drive_state_child_desc);
  builder_.add_drive_state_desc(drive_state_desc);
  builder_.add_terminal(terminal);
  builder_.add_ti_task_speed(ti_task_speed);
  builder_.add_park_error(park_error);
  builder_.add_park_point(park_point);
  builder_.add_point_key(point_key);
  builder_.add_GpsPathList(GpsPathList);
  builder_.add_target_key_point(target_key_point);
  builder_.add_fault(fault);
  builder_.add_drive_state_child_last(drive_state_child_last);
  builder_.add_drive_state_child(drive_state_child);
  builder_.add_detour(detour);
  builder_.add_single_mode(single_mode);
  builder_.add_load_status(load_status);
  builder_.add_exec_cmd(exec_cmd);
  builder_.add_drive_state_last(drive_state_last);
  builder_.add_drive_state(drive_state);
  builder_.add_drive_mode_last(drive_mode_last);
  builder_.add_drive_mode(drive_mode);
  return builder_.Finish();
}

inline flatbuffers::Offset<Output> CreateOutputDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t drive_mode = 0,
    uint8_t drive_mode_last = 0,
    uint8_t drive_state = 0,
    uint8_t drive_state_last = 0,
    uint16_t drive_state_child = 0,
    uint16_t drive_state_child_last = 0,
    uint16_t fault = 0,
    int32_t target_key_point = 0,
    uint32_t GpsPathList = 0,
    int32_t point_key = 0,
    flatbuffers::Offset<decision::LatLonHead> park_point = 0,
    flatbuffers::Offset<decision::LatLonHead> park_error = 0,
    float ti_task_speed = 0.0f,
    int32_t terminal = 0,
    uint8_t exec_cmd = 0,
    uint8_t load_status = 0,
    const char *drive_state_desc = nullptr,
    const char *drive_state_child_desc = nullptr,
    bool single_mode = false,
    uint32_t reference_line = 0,
    bool detour = false) {
  auto drive_state_desc__ = drive_state_desc ? _fbb.CreateString(drive_state_desc) : 0;
  auto drive_state_child_desc__ = drive_state_child_desc ? _fbb.CreateString(drive_state_child_desc) : 0;
  return decision::CreateOutput(
      _fbb,
      drive_mode,
      drive_mode_last,
      drive_state,
      drive_state_last,
      drive_state_child,
      drive_state_child_last,
      fault,
      target_key_point,
      GpsPathList,
      point_key,
      park_point,
      park_error,
      ti_task_speed,
      terminal,
      exec_cmd,
      load_status,
      drive_state_desc__,
      drive_state_child_desc__,
      single_mode,
      reference_line,
      detour);
}

flatbuffers::Offset<Output> CreateOutput(flatbuffers::FlatBufferBuilder &_fbb, const OutputT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RoadTaskVehicleInfoT : public flatbuffers::NativeTable {
  typedef RoadTaskVehicleInfo TableType;
  uint16_t road_id;
  float remain_dis;
  uint32_t point_key;
  uint16_t task_id;
  uint8_t work_status;
  std::string task_file_name;
  uint8_t service_state;
  uint16_t reason;
  uint8_t run;
  uint16_t why_stop;
  RoadTaskVehicleInfoT()
      : road_id(0),
        remain_dis(0.0f),
        point_key(0),
        task_id(0),
        work_status(0),
        service_state(0),
        reason(0),
        run(0),
        why_stop(0) {
  }
};

inline bool operator==(const RoadTaskVehicleInfoT &lhs, const RoadTaskVehicleInfoT &rhs) {
  return
      (lhs.road_id == rhs.road_id) &&
      (lhs.remain_dis == rhs.remain_dis) &&
      (lhs.point_key == rhs.point_key) &&
      (lhs.task_id == rhs.task_id) &&
      (lhs.work_status == rhs.work_status) &&
      (lhs.task_file_name == rhs.task_file_name) &&
      (lhs.service_state == rhs.service_state) &&
      (lhs.reason == rhs.reason) &&
      (lhs.run == rhs.run) &&
      (lhs.why_stop == rhs.why_stop);
}

inline bool operator!=(const RoadTaskVehicleInfoT &lhs, const RoadTaskVehicleInfoT &rhs) {
    return !(lhs == rhs);
}


struct RoadTaskVehicleInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RoadTaskVehicleInfoT NativeTableType;
  typedef RoadTaskVehicleInfoBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RoadTaskVehicleInfoTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ROAD_ID = 4,
    VT_REMAIN_DIS = 6,
    VT_POINT_KEY = 8,
    VT_TASK_ID = 10,
    VT_WORK_STATUS = 12,
    VT_TASK_FILE_NAME = 14,
    VT_SERVICE_STATE = 16,
    VT_REASON = 18,
    VT_RUN = 20,
    VT_WHY_STOP = 22
  };
  uint16_t road_id() const {
    return GetField<uint16_t>(VT_ROAD_ID, 0);
  }
  bool mutate_road_id(uint16_t _road_id) {
    return SetField<uint16_t>(VT_ROAD_ID, _road_id, 0);
  }
  float remain_dis() const {
    return GetField<float>(VT_REMAIN_DIS, 0.0f);
  }
  bool mutate_remain_dis(float _remain_dis) {
    return SetField<float>(VT_REMAIN_DIS, _remain_dis, 0.0f);
  }
  uint32_t point_key() const {
    return GetField<uint32_t>(VT_POINT_KEY, 0);
  }
  bool mutate_point_key(uint32_t _point_key) {
    return SetField<uint32_t>(VT_POINT_KEY, _point_key, 0);
  }
  uint16_t task_id() const {
    return GetField<uint16_t>(VT_TASK_ID, 0);
  }
  bool mutate_task_id(uint16_t _task_id) {
    return SetField<uint16_t>(VT_TASK_ID, _task_id, 0);
  }
  uint8_t work_status() const {
    return GetField<uint8_t>(VT_WORK_STATUS, 0);
  }
  bool mutate_work_status(uint8_t _work_status) {
    return SetField<uint8_t>(VT_WORK_STATUS, _work_status, 0);
  }
  const flatbuffers::String *task_file_name() const {
    return GetPointer<const flatbuffers::String *>(VT_TASK_FILE_NAME);
  }
  flatbuffers::String *mutable_task_file_name() {
    return GetPointer<flatbuffers::String *>(VT_TASK_FILE_NAME);
  }
  uint8_t service_state() const {
    return GetField<uint8_t>(VT_SERVICE_STATE, 0);
  }
  bool mutate_service_state(uint8_t _service_state) {
    return SetField<uint8_t>(VT_SERVICE_STATE, _service_state, 0);
  }
  uint16_t reason() const {
    return GetField<uint16_t>(VT_REASON, 0);
  }
  bool mutate_reason(uint16_t _reason) {
    return SetField<uint16_t>(VT_REASON, _reason, 0);
  }
  uint8_t run() const {
    return GetField<uint8_t>(VT_RUN, 0);
  }
  bool mutate_run(uint8_t _run) {
    return SetField<uint8_t>(VT_RUN, _run, 0);
  }
  uint16_t why_stop() const {
    return GetField<uint16_t>(VT_WHY_STOP, 0);
  }
  bool mutate_why_stop(uint16_t _why_stop) {
    return SetField<uint16_t>(VT_WHY_STOP, _why_stop, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ROAD_ID) &&
           VerifyField<float>(verifier, VT_REMAIN_DIS) &&
           VerifyField<uint32_t>(verifier, VT_POINT_KEY) &&
           VerifyField<uint16_t>(verifier, VT_TASK_ID) &&
           VerifyField<uint8_t>(verifier, VT_WORK_STATUS) &&
           VerifyOffset(verifier, VT_TASK_FILE_NAME) &&
           verifier.VerifyString(task_file_name()) &&
           VerifyField<uint8_t>(verifier, VT_SERVICE_STATE) &&
           VerifyField<uint16_t>(verifier, VT_REASON) &&
           VerifyField<uint8_t>(verifier, VT_RUN) &&
           VerifyField<uint16_t>(verifier, VT_WHY_STOP) &&
           verifier.EndTable();
  }
  RoadTaskVehicleInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RoadTaskVehicleInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RoadTaskVehicleInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RoadTaskVehicleInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RoadTaskVehicleInfoBuilder {
  typedef RoadTaskVehicleInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_road_id(uint16_t road_id) {
    fbb_.AddElement<uint16_t>(RoadTaskVehicleInfo::VT_ROAD_ID, road_id, 0);
  }
  void add_remain_dis(float remain_dis) {
    fbb_.AddElement<float>(RoadTaskVehicleInfo::VT_REMAIN_DIS, remain_dis, 0.0f);
  }
  void add_point_key(uint32_t point_key) {
    fbb_.AddElement<uint32_t>(RoadTaskVehicleInfo::VT_POINT_KEY, point_key, 0);
  }
  void add_task_id(uint16_t task_id) {
    fbb_.AddElement<uint16_t>(RoadTaskVehicleInfo::VT_TASK_ID, task_id, 0);
  }
  void add_work_status(uint8_t work_status) {
    fbb_.AddElement<uint8_t>(RoadTaskVehicleInfo::VT_WORK_STATUS, work_status, 0);
  }
  void add_task_file_name(flatbuffers::Offset<flatbuffers::String> task_file_name) {
    fbb_.AddOffset(RoadTaskVehicleInfo::VT_TASK_FILE_NAME, task_file_name);
  }
  void add_service_state(uint8_t service_state) {
    fbb_.AddElement<uint8_t>(RoadTaskVehicleInfo::VT_SERVICE_STATE, service_state, 0);
  }
  void add_reason(uint16_t reason) {
    fbb_.AddElement<uint16_t>(RoadTaskVehicleInfo::VT_REASON, reason, 0);
  }
  void add_run(uint8_t run) {
    fbb_.AddElement<uint8_t>(RoadTaskVehicleInfo::VT_RUN, run, 0);
  }
  void add_why_stop(uint16_t why_stop) {
    fbb_.AddElement<uint16_t>(RoadTaskVehicleInfo::VT_WHY_STOP, why_stop, 0);
  }
  explicit RoadTaskVehicleInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RoadTaskVehicleInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RoadTaskVehicleInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<RoadTaskVehicleInfo> CreateRoadTaskVehicleInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t road_id = 0,
    float remain_dis = 0.0f,
    uint32_t point_key = 0,
    uint16_t task_id = 0,
    uint8_t work_status = 0,
    flatbuffers::Offset<flatbuffers::String> task_file_name = 0,
    uint8_t service_state = 0,
    uint16_t reason = 0,
    uint8_t run = 0,
    uint16_t why_stop = 0) {
  RoadTaskVehicleInfoBuilder builder_(_fbb);
  builder_.add_task_file_name(task_file_name);
  builder_.add_point_key(point_key);
  builder_.add_remain_dis(remain_dis);
  builder_.add_why_stop(why_stop);
  builder_.add_reason(reason);
  builder_.add_task_id(task_id);
  builder_.add_road_id(road_id);
  builder_.add_run(run);
  builder_.add_service_state(service_state);
  builder_.add_work_status(work_status);
  return builder_.Finish();
}

inline flatbuffers::Offset<RoadTaskVehicleInfo> CreateRoadTaskVehicleInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t road_id = 0,
    float remain_dis = 0.0f,
    uint32_t point_key = 0,
    uint16_t task_id = 0,
    uint8_t work_status = 0,
    const char *task_file_name = nullptr,
    uint8_t service_state = 0,
    uint16_t reason = 0,
    uint8_t run = 0,
    uint16_t why_stop = 0) {
  auto task_file_name__ = task_file_name ? _fbb.CreateString(task_file_name) : 0;
  return decision::CreateRoadTaskVehicleInfo(
      _fbb,
      road_id,
      remain_dis,
      point_key,
      task_id,
      work_status,
      task_file_name__,
      service_state,
      reason,
      run,
      why_stop);
}

flatbuffers::Offset<RoadTaskVehicleInfo> CreateRoadTaskVehicleInfo(flatbuffers::FlatBufferBuilder &_fbb, const RoadTaskVehicleInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Msg1030T : public flatbuffers::NativeTable {
  typedef Msg1030 TableType;
  uint16_t id;
  float vehicle_length;
  float vehicle_width;
  float vehicle_height;
  uint8_t start_state;
  Msg1030T()
      : id(0),
        vehicle_length(0.0f),
        vehicle_width(0.0f),
        vehicle_height(0.0f),
        start_state(0) {
  }
};

inline bool operator==(const Msg1030T &lhs, const Msg1030T &rhs) {
  return
      (lhs.id == rhs.id) &&
      (lhs.vehicle_length == rhs.vehicle_length) &&
      (lhs.vehicle_width == rhs.vehicle_width) &&
      (lhs.vehicle_height == rhs.vehicle_height) &&
      (lhs.start_state == rhs.start_state);
}

inline bool operator!=(const Msg1030T &lhs, const Msg1030T &rhs) {
    return !(lhs == rhs);
}


struct Msg1030 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Msg1030T NativeTableType;
  typedef Msg1030Builder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Msg1030TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_VEHICLE_LENGTH = 6,
    VT_VEHICLE_WIDTH = 8,
    VT_VEHICLE_HEIGHT = 10,
    VT_START_STATE = 12
  };
  uint16_t id() const {
    return GetField<uint16_t>(VT_ID, 0);
  }
  bool mutate_id(uint16_t _id) {
    return SetField<uint16_t>(VT_ID, _id, 0);
  }
  float vehicle_length() const {
    return GetField<float>(VT_VEHICLE_LENGTH, 0.0f);
  }
  bool mutate_vehicle_length(float _vehicle_length) {
    return SetField<float>(VT_VEHICLE_LENGTH, _vehicle_length, 0.0f);
  }
  float vehicle_width() const {
    return GetField<float>(VT_VEHICLE_WIDTH, 0.0f);
  }
  bool mutate_vehicle_width(float _vehicle_width) {
    return SetField<float>(VT_VEHICLE_WIDTH, _vehicle_width, 0.0f);
  }
  float vehicle_height() const {
    return GetField<float>(VT_VEHICLE_HEIGHT, 0.0f);
  }
  bool mutate_vehicle_height(float _vehicle_height) {
    return SetField<float>(VT_VEHICLE_HEIGHT, _vehicle_height, 0.0f);
  }
  uint8_t start_state() const {
    return GetField<uint8_t>(VT_START_STATE, 0);
  }
  bool mutate_start_state(uint8_t _start_state) {
    return SetField<uint8_t>(VT_START_STATE, _start_state, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ID) &&
           VerifyField<float>(verifier, VT_VEHICLE_LENGTH) &&
           VerifyField<float>(verifier, VT_VEHICLE_WIDTH) &&
           VerifyField<float>(verifier, VT_VEHICLE_HEIGHT) &&
           VerifyField<uint8_t>(verifier, VT_START_STATE) &&
           verifier.EndTable();
  }
  Msg1030T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Msg1030T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Msg1030> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg1030T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Msg1030Builder {
  typedef Msg1030 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint16_t id) {
    fbb_.AddElement<uint16_t>(Msg1030::VT_ID, id, 0);
  }
  void add_vehicle_length(float vehicle_length) {
    fbb_.AddElement<float>(Msg1030::VT_VEHICLE_LENGTH, vehicle_length, 0.0f);
  }
  void add_vehicle_width(float vehicle_width) {
    fbb_.AddElement<float>(Msg1030::VT_VEHICLE_WIDTH, vehicle_width, 0.0f);
  }
  void add_vehicle_height(float vehicle_height) {
    fbb_.AddElement<float>(Msg1030::VT_VEHICLE_HEIGHT, vehicle_height, 0.0f);
  }
  void add_start_state(uint8_t start_state) {
    fbb_.AddElement<uint8_t>(Msg1030::VT_START_STATE, start_state, 0);
  }
  explicit Msg1030Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Msg1030> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Msg1030>(end);
    return o;
  }
};

inline flatbuffers::Offset<Msg1030> CreateMsg1030(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t id = 0,
    float vehicle_length = 0.0f,
    float vehicle_width = 0.0f,
    float vehicle_height = 0.0f,
    uint8_t start_state = 0) {
  Msg1030Builder builder_(_fbb);
  builder_.add_vehicle_height(vehicle_height);
  builder_.add_vehicle_width(vehicle_width);
  builder_.add_vehicle_length(vehicle_length);
  builder_.add_id(id);
  builder_.add_start_state(start_state);
  return builder_.Finish();
}

flatbuffers::Offset<Msg1030> CreateMsg1030(flatbuffers::FlatBufferBuilder &_fbb, const Msg1030T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Msg1050T : public flatbuffers::NativeTable {
  typedef Msg1050 TableType;
  uint16_t id;
  uint16_t rsv;
  Msg1050T()
      : id(0),
        rsv(0) {
  }
};

inline bool operator==(const Msg1050T &lhs, const Msg1050T &rhs) {
  return
      (lhs.id == rhs.id) &&
      (lhs.rsv == rhs.rsv);
}

inline bool operator!=(const Msg1050T &lhs, const Msg1050T &rhs) {
    return !(lhs == rhs);
}


struct Msg1050 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Msg1050T NativeTableType;
  typedef Msg1050Builder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Msg1050TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_RSV = 6
  };
  uint16_t id() const {
    return GetField<uint16_t>(VT_ID, 0);
  }
  bool mutate_id(uint16_t _id) {
    return SetField<uint16_t>(VT_ID, _id, 0);
  }
  uint16_t rsv() const {
    return GetField<uint16_t>(VT_RSV, 0);
  }
  bool mutate_rsv(uint16_t _rsv) {
    return SetField<uint16_t>(VT_RSV, _rsv, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ID) &&
           VerifyField<uint16_t>(verifier, VT_RSV) &&
           verifier.EndTable();
  }
  Msg1050T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Msg1050T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Msg1050> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg1050T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Msg1050Builder {
  typedef Msg1050 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint16_t id) {
    fbb_.AddElement<uint16_t>(Msg1050::VT_ID, id, 0);
  }
  void add_rsv(uint16_t rsv) {
    fbb_.AddElement<uint16_t>(Msg1050::VT_RSV, rsv, 0);
  }
  explicit Msg1050Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Msg1050> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Msg1050>(end);
    return o;
  }
};

inline flatbuffers::Offset<Msg1050> CreateMsg1050(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t id = 0,
    uint16_t rsv = 0) {
  Msg1050Builder builder_(_fbb);
  builder_.add_rsv(rsv);
  builder_.add_id(id);
  return builder_.Finish();
}

flatbuffers::Offset<Msg1050> CreateMsg1050(flatbuffers::FlatBufferBuilder &_fbb, const Msg1050T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Msg2062T : public flatbuffers::NativeTable {
  typedef Msg2062 TableType;
  uint16_t id;
  uint8_t cmd;
  uint8_t ack;
  Msg2062T()
      : id(8290),
        cmd(0),
        ack(1) {
  }
};

inline bool operator==(const Msg2062T &lhs, const Msg2062T &rhs) {
  return
      (lhs.id == rhs.id) &&
      (lhs.cmd == rhs.cmd) &&
      (lhs.ack == rhs.ack);
}

inline bool operator!=(const Msg2062T &lhs, const Msg2062T &rhs) {
    return !(lhs == rhs);
}


struct Msg2062 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Msg2062T NativeTableType;
  typedef Msg2062Builder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Msg2062TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_CMD = 6,
    VT_ACK = 8
  };
  uint16_t id() const {
    return GetField<uint16_t>(VT_ID, 8290);
  }
  bool mutate_id(uint16_t _id) {
    return SetField<uint16_t>(VT_ID, _id, 8290);
  }
  uint8_t cmd() const {
    return GetField<uint8_t>(VT_CMD, 0);
  }
  bool mutate_cmd(uint8_t _cmd) {
    return SetField<uint8_t>(VT_CMD, _cmd, 0);
  }
  uint8_t ack() const {
    return GetField<uint8_t>(VT_ACK, 1);
  }
  bool mutate_ack(uint8_t _ack) {
    return SetField<uint8_t>(VT_ACK, _ack, 1);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ID) &&
           VerifyField<uint8_t>(verifier, VT_CMD) &&
           VerifyField<uint8_t>(verifier, VT_ACK) &&
           verifier.EndTable();
  }
  Msg2062T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Msg2062T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Msg2062> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg2062T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Msg2062Builder {
  typedef Msg2062 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint16_t id) {
    fbb_.AddElement<uint16_t>(Msg2062::VT_ID, id, 8290);
  }
  void add_cmd(uint8_t cmd) {
    fbb_.AddElement<uint8_t>(Msg2062::VT_CMD, cmd, 0);
  }
  void add_ack(uint8_t ack) {
    fbb_.AddElement<uint8_t>(Msg2062::VT_ACK, ack, 1);
  }
  explicit Msg2062Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Msg2062> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Msg2062>(end);
    return o;
  }
};

inline flatbuffers::Offset<Msg2062> CreateMsg2062(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t id = 8290,
    uint8_t cmd = 0,
    uint8_t ack = 1) {
  Msg2062Builder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_ack(ack);
  builder_.add_cmd(cmd);
  return builder_.Finish();
}

flatbuffers::Offset<Msg2062> CreateMsg2062(flatbuffers::FlatBufferBuilder &_fbb, const Msg2062T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Msg0404T : public flatbuffers::NativeTable {
  typedef Msg0404 TableType;
  uint16_t id;
  int8_t manual_driving;
  int8_t task_type;
  int8_t direction;
  Msg0404T()
      : id(0),
        manual_driving(0),
        task_type(0),
        direction(0) {
  }
};

inline bool operator==(const Msg0404T &lhs, const Msg0404T &rhs) {
  return
      (lhs.id == rhs.id) &&
      (lhs.manual_driving == rhs.manual_driving) &&
      (lhs.task_type == rhs.task_type) &&
      (lhs.direction == rhs.direction);
}

inline bool operator!=(const Msg0404T &lhs, const Msg0404T &rhs) {
    return !(lhs == rhs);
}


struct Msg0404 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Msg0404T NativeTableType;
  typedef Msg0404Builder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Msg0404TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_MANUAL_DRIVING = 6,
    VT_TASK_TYPE = 8,
    VT_DIRECTION = 10
  };
  uint16_t id() const {
    return GetField<uint16_t>(VT_ID, 0);
  }
  bool mutate_id(uint16_t _id) {
    return SetField<uint16_t>(VT_ID, _id, 0);
  }
  int8_t manual_driving() const {
    return GetField<int8_t>(VT_MANUAL_DRIVING, 0);
  }
  bool mutate_manual_driving(int8_t _manual_driving) {
    return SetField<int8_t>(VT_MANUAL_DRIVING, _manual_driving, 0);
  }
  int8_t task_type() const {
    return GetField<int8_t>(VT_TASK_TYPE, 0);
  }
  bool mutate_task_type(int8_t _task_type) {
    return SetField<int8_t>(VT_TASK_TYPE, _task_type, 0);
  }
  int8_t direction() const {
    return GetField<int8_t>(VT_DIRECTION, 0);
  }
  bool mutate_direction(int8_t _direction) {
    return SetField<int8_t>(VT_DIRECTION, _direction, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ID) &&
           VerifyField<int8_t>(verifier, VT_MANUAL_DRIVING) &&
           VerifyField<int8_t>(verifier, VT_TASK_TYPE) &&
           VerifyField<int8_t>(verifier, VT_DIRECTION) &&
           verifier.EndTable();
  }
  Msg0404T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Msg0404T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Msg0404> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg0404T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Msg0404Builder {
  typedef Msg0404 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint16_t id) {
    fbb_.AddElement<uint16_t>(Msg0404::VT_ID, id, 0);
  }
  void add_manual_driving(int8_t manual_driving) {
    fbb_.AddElement<int8_t>(Msg0404::VT_MANUAL_DRIVING, manual_driving, 0);
  }
  void add_task_type(int8_t task_type) {
    fbb_.AddElement<int8_t>(Msg0404::VT_TASK_TYPE, task_type, 0);
  }
  void add_direction(int8_t direction) {
    fbb_.AddElement<int8_t>(Msg0404::VT_DIRECTION, direction, 0);
  }
  explicit Msg0404Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Msg0404> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Msg0404>(end);
    return o;
  }
};

inline flatbuffers::Offset<Msg0404> CreateMsg0404(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t id = 0,
    int8_t manual_driving = 0,
    int8_t task_type = 0,
    int8_t direction = 0) {
  Msg0404Builder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_direction(direction);
  builder_.add_task_type(task_type);
  builder_.add_manual_driving(manual_driving);
  return builder_.Finish();
}

flatbuffers::Offset<Msg0404> CreateMsg0404(flatbuffers::FlatBufferBuilder &_fbb, const Msg0404T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Msg0500T : public flatbuffers::NativeTable {
  typedef Msg0500 TableType;
  uint16_t id;
  uint8_t state;
  Msg0500T()
      : id(1280),
        state(0) {
  }
};

inline bool operator==(const Msg0500T &lhs, const Msg0500T &rhs) {
  return
      (lhs.id == rhs.id) &&
      (lhs.state == rhs.state);
}

inline bool operator!=(const Msg0500T &lhs, const Msg0500T &rhs) {
    return !(lhs == rhs);
}


struct Msg0500 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Msg0500T NativeTableType;
  typedef Msg0500Builder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Msg0500TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_STATE = 6
  };
  uint16_t id() const {
    return GetField<uint16_t>(VT_ID, 1280);
  }
  bool mutate_id(uint16_t _id) {
    return SetField<uint16_t>(VT_ID, _id, 1280);
  }
  uint8_t state() const {
    return GetField<uint8_t>(VT_STATE, 0);
  }
  bool mutate_state(uint8_t _state) {
    return SetField<uint8_t>(VT_STATE, _state, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ID) &&
           VerifyField<uint8_t>(verifier, VT_STATE) &&
           verifier.EndTable();
  }
  Msg0500T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Msg0500T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Msg0500> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg0500T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Msg0500Builder {
  typedef Msg0500 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint16_t id) {
    fbb_.AddElement<uint16_t>(Msg0500::VT_ID, id, 1280);
  }
  void add_state(uint8_t state) {
    fbb_.AddElement<uint8_t>(Msg0500::VT_STATE, state, 0);
  }
  explicit Msg0500Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Msg0500> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Msg0500>(end);
    return o;
  }
};

inline flatbuffers::Offset<Msg0500> CreateMsg0500(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t id = 1280,
    uint8_t state = 0) {
  Msg0500Builder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_state(state);
  return builder_.Finish();
}

flatbuffers::Offset<Msg0500> CreateMsg0500(flatbuffers::FlatBufferBuilder &_fbb, const Msg0500T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Msg0501T : public flatbuffers::NativeTable {
  typedef Msg0501 TableType;
  uint16_t id;
  int16_t dis;
  Msg0501T()
      : id(1281),
        dis(0) {
  }
};

inline bool operator==(const Msg0501T &lhs, const Msg0501T &rhs) {
  return
      (lhs.id == rhs.id) &&
      (lhs.dis == rhs.dis);
}

inline bool operator!=(const Msg0501T &lhs, const Msg0501T &rhs) {
    return !(lhs == rhs);
}


struct Msg0501 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Msg0501T NativeTableType;
  typedef Msg0501Builder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Msg0501TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_DIS = 6
  };
  uint16_t id() const {
    return GetField<uint16_t>(VT_ID, 1281);
  }
  bool mutate_id(uint16_t _id) {
    return SetField<uint16_t>(VT_ID, _id, 1281);
  }
  int16_t dis() const {
    return GetField<int16_t>(VT_DIS, 0);
  }
  bool mutate_dis(int16_t _dis) {
    return SetField<int16_t>(VT_DIS, _dis, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ID) &&
           VerifyField<int16_t>(verifier, VT_DIS) &&
           verifier.EndTable();
  }
  Msg0501T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Msg0501T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Msg0501> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg0501T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Msg0501Builder {
  typedef Msg0501 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint16_t id) {
    fbb_.AddElement<uint16_t>(Msg0501::VT_ID, id, 1281);
  }
  void add_dis(int16_t dis) {
    fbb_.AddElement<int16_t>(Msg0501::VT_DIS, dis, 0);
  }
  explicit Msg0501Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Msg0501> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Msg0501>(end);
    return o;
  }
};

inline flatbuffers::Offset<Msg0501> CreateMsg0501(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t id = 1281,
    int16_t dis = 0) {
  Msg0501Builder builder_(_fbb);
  builder_.add_dis(dis);
  builder_.add_id(id);
  return builder_.Finish();
}

flatbuffers::Offset<Msg0501> CreateMsg0501(flatbuffers::FlatBufferBuilder &_fbb, const Msg0501T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Msg8F1CT : public flatbuffers::NativeTable {
  typedef Msg8F1C TableType;
  uint16_t id;
  uint8_t type;
  uint8_t result;
  uint8_t why_fail;
  Msg8F1CT()
      : id(36636),
        type(0),
        result(0),
        why_fail(0) {
  }
};

inline bool operator==(const Msg8F1CT &lhs, const Msg8F1CT &rhs) {
  return
      (lhs.id == rhs.id) &&
      (lhs.type == rhs.type) &&
      (lhs.result == rhs.result) &&
      (lhs.why_fail == rhs.why_fail);
}

inline bool operator!=(const Msg8F1CT &lhs, const Msg8F1CT &rhs) {
    return !(lhs == rhs);
}


struct Msg8F1C FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Msg8F1CT NativeTableType;
  typedef Msg8F1CBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Msg8F1CTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TYPE = 6,
    VT_RESULT = 8,
    VT_WHY_FAIL = 10
  };
  uint16_t id() const {
    return GetField<uint16_t>(VT_ID, 36636);
  }
  bool mutate_id(uint16_t _id) {
    return SetField<uint16_t>(VT_ID, _id, 36636);
  }
  uint8_t type() const {
    return GetField<uint8_t>(VT_TYPE, 0);
  }
  bool mutate_type(uint8_t _type) {
    return SetField<uint8_t>(VT_TYPE, _type, 0);
  }
  uint8_t result() const {
    return GetField<uint8_t>(VT_RESULT, 0);
  }
  bool mutate_result(uint8_t _result) {
    return SetField<uint8_t>(VT_RESULT, _result, 0);
  }
  uint8_t why_fail() const {
    return GetField<uint8_t>(VT_WHY_FAIL, 0);
  }
  bool mutate_why_fail(uint8_t _why_fail) {
    return SetField<uint8_t>(VT_WHY_FAIL, _why_fail, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ID) &&
           VerifyField<uint8_t>(verifier, VT_TYPE) &&
           VerifyField<uint8_t>(verifier, VT_RESULT) &&
           VerifyField<uint8_t>(verifier, VT_WHY_FAIL) &&
           verifier.EndTable();
  }
  Msg8F1CT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Msg8F1CT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Msg8F1C> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg8F1CT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Msg8F1CBuilder {
  typedef Msg8F1C Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint16_t id) {
    fbb_.AddElement<uint16_t>(Msg8F1C::VT_ID, id, 36636);
  }
  void add_type(uint8_t type) {
    fbb_.AddElement<uint8_t>(Msg8F1C::VT_TYPE, type, 0);
  }
  void add_result(uint8_t result) {
    fbb_.AddElement<uint8_t>(Msg8F1C::VT_RESULT, result, 0);
  }
  void add_why_fail(uint8_t why_fail) {
    fbb_.AddElement<uint8_t>(Msg8F1C::VT_WHY_FAIL, why_fail, 0);
  }
  explicit Msg8F1CBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Msg8F1C> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Msg8F1C>(end);
    return o;
  }
};

inline flatbuffers::Offset<Msg8F1C> CreateMsg8F1C(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t id = 36636,
    uint8_t type = 0,
    uint8_t result = 0,
    uint8_t why_fail = 0) {
  Msg8F1CBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_why_fail(why_fail);
  builder_.add_result(result);
  builder_.add_type(type);
  return builder_.Finish();
}

flatbuffers::Offset<Msg8F1C> CreateMsg8F1C(flatbuffers::FlatBufferBuilder &_fbb, const Msg8F1CT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline LatLonHeadT *LatLonHead::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<decision::LatLonHeadT> _o = std::unique_ptr<decision::LatLonHeadT>(new LatLonHeadT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LatLonHead::UnPackTo(LatLonHeadT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = lat(); _o->lat = _e; }
  { auto _e = lng(); _o->lng = _e; }
  { auto _e = head(); _o->head = _e; }
}

inline flatbuffers::Offset<LatLonHead> LatLonHead::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LatLonHeadT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLatLonHead(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LatLonHead> CreateLatLonHead(flatbuffers::FlatBufferBuilder &_fbb, const LatLonHeadT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LatLonHeadT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _lat = _o->lat;
  auto _lng = _o->lng;
  auto _head = _o->head;
  return decision::CreateLatLonHead(
      _fbb,
      _lat,
      _lng,
      _head);
}

inline OutputT *Output::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<decision::OutputT> _o = std::unique_ptr<decision::OutputT>(new OutputT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Output::UnPackTo(OutputT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = drive_mode(); _o->drive_mode = _e; }
  { auto _e = drive_mode_last(); _o->drive_mode_last = _e; }
  { auto _e = drive_state(); _o->drive_state = _e; }
  { auto _e = drive_state_last(); _o->drive_state_last = _e; }
  { auto _e = drive_state_child(); _o->drive_state_child = _e; }
  { auto _e = drive_state_child_last(); _o->drive_state_child_last = _e; }
  { auto _e = fault(); _o->fault = _e; }
  { auto _e = target_key_point(); _o->target_key_point = _e; }
  { auto _e = GpsPathList(); _o->GpsPathList = _e; }
  { auto _e = point_key(); _o->point_key = _e; }
  { auto _e = park_point(); if (_e) _o->park_point = std::unique_ptr<decision::LatLonHeadT>(_e->UnPack(_resolver)); }
  { auto _e = park_error(); if (_e) _o->park_error = std::unique_ptr<decision::LatLonHeadT>(_e->UnPack(_resolver)); }
  { auto _e = ti_task_speed(); _o->ti_task_speed = _e; }
  { auto _e = terminal(); _o->terminal = _e; }
  { auto _e = exec_cmd(); _o->exec_cmd = _e; }
  { auto _e = load_status(); _o->load_status = _e; }
  { auto _e = drive_state_desc(); if (_e) _o->drive_state_desc = _e->str(); }
  { auto _e = drive_state_child_desc(); if (_e) _o->drive_state_child_desc = _e->str(); }
  { auto _e = single_mode(); _o->single_mode = _e; }
  { auto _e = reference_line(); _o->reference_line = _e; }
  { auto _e = detour(); _o->detour = _e; }
}

inline flatbuffers::Offset<Output> Output::Pack(flatbuffers::FlatBufferBuilder &_fbb, const OutputT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOutput(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Output> CreateOutput(flatbuffers::FlatBufferBuilder &_fbb, const OutputT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const OutputT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _drive_mode = _o->drive_mode;
  auto _drive_mode_last = _o->drive_mode_last;
  auto _drive_state = _o->drive_state;
  auto _drive_state_last = _o->drive_state_last;
  auto _drive_state_child = _o->drive_state_child;
  auto _drive_state_child_last = _o->drive_state_child_last;
  auto _fault = _o->fault;
  auto _target_key_point = _o->target_key_point;
  auto _GpsPathList = _o->GpsPathList;
  auto _point_key = _o->point_key;
  auto _park_point = _o->park_point ? CreateLatLonHead(_fbb, _o->park_point.get(), _rehasher) : 0;
  auto _park_error = _o->park_error ? CreateLatLonHead(_fbb, _o->park_error.get(), _rehasher) : 0;
  auto _ti_task_speed = _o->ti_task_speed;
  auto _terminal = _o->terminal;
  auto _exec_cmd = _o->exec_cmd;
  auto _load_status = _o->load_status;
  auto _drive_state_desc = _o->drive_state_desc.empty() ? 0 : _fbb.CreateString(_o->drive_state_desc);
  auto _drive_state_child_desc = _o->drive_state_child_desc.empty() ? 0 : _fbb.CreateString(_o->drive_state_child_desc);
  auto _single_mode = _o->single_mode;
  auto _reference_line = _o->reference_line;
  auto _detour = _o->detour;
  return decision::CreateOutput(
      _fbb,
      _drive_mode,
      _drive_mode_last,
      _drive_state,
      _drive_state_last,
      _drive_state_child,
      _drive_state_child_last,
      _fault,
      _target_key_point,
      _GpsPathList,
      _point_key,
      _park_point,
      _park_error,
      _ti_task_speed,
      _terminal,
      _exec_cmd,
      _load_status,
      _drive_state_desc,
      _drive_state_child_desc,
      _single_mode,
      _reference_line,
      _detour);
}

inline RoadTaskVehicleInfoT *RoadTaskVehicleInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<decision::RoadTaskVehicleInfoT> _o = std::unique_ptr<decision::RoadTaskVehicleInfoT>(new RoadTaskVehicleInfoT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RoadTaskVehicleInfo::UnPackTo(RoadTaskVehicleInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = road_id(); _o->road_id = _e; }
  { auto _e = remain_dis(); _o->remain_dis = _e; }
  { auto _e = point_key(); _o->point_key = _e; }
  { auto _e = task_id(); _o->task_id = _e; }
  { auto _e = work_status(); _o->work_status = _e; }
  { auto _e = task_file_name(); if (_e) _o->task_file_name = _e->str(); }
  { auto _e = service_state(); _o->service_state = _e; }
  { auto _e = reason(); _o->reason = _e; }
  { auto _e = run(); _o->run = _e; }
  { auto _e = why_stop(); _o->why_stop = _e; }
}

inline flatbuffers::Offset<RoadTaskVehicleInfo> RoadTaskVehicleInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RoadTaskVehicleInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRoadTaskVehicleInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RoadTaskVehicleInfo> CreateRoadTaskVehicleInfo(flatbuffers::FlatBufferBuilder &_fbb, const RoadTaskVehicleInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RoadTaskVehicleInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _road_id = _o->road_id;
  auto _remain_dis = _o->remain_dis;
  auto _point_key = _o->point_key;
  auto _task_id = _o->task_id;
  auto _work_status = _o->work_status;
  auto _task_file_name = _o->task_file_name.empty() ? 0 : _fbb.CreateString(_o->task_file_name);
  auto _service_state = _o->service_state;
  auto _reason = _o->reason;
  auto _run = _o->run;
  auto _why_stop = _o->why_stop;
  return decision::CreateRoadTaskVehicleInfo(
      _fbb,
      _road_id,
      _remain_dis,
      _point_key,
      _task_id,
      _work_status,
      _task_file_name,
      _service_state,
      _reason,
      _run,
      _why_stop);
}

inline Msg1030T *Msg1030::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<decision::Msg1030T> _o = std::unique_ptr<decision::Msg1030T>(new Msg1030T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Msg1030::UnPackTo(Msg1030T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; }
  { auto _e = vehicle_length(); _o->vehicle_length = _e; }
  { auto _e = vehicle_width(); _o->vehicle_width = _e; }
  { auto _e = vehicle_height(); _o->vehicle_height = _e; }
  { auto _e = start_state(); _o->start_state = _e; }
}

inline flatbuffers::Offset<Msg1030> Msg1030::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg1030T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMsg1030(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Msg1030> CreateMsg1030(flatbuffers::FlatBufferBuilder &_fbb, const Msg1030T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Msg1030T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _vehicle_length = _o->vehicle_length;
  auto _vehicle_width = _o->vehicle_width;
  auto _vehicle_height = _o->vehicle_height;
  auto _start_state = _o->start_state;
  return decision::CreateMsg1030(
      _fbb,
      _id,
      _vehicle_length,
      _vehicle_width,
      _vehicle_height,
      _start_state);
}

inline Msg1050T *Msg1050::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<decision::Msg1050T> _o = std::unique_ptr<decision::Msg1050T>(new Msg1050T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Msg1050::UnPackTo(Msg1050T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; }
  { auto _e = rsv(); _o->rsv = _e; }
}

inline flatbuffers::Offset<Msg1050> Msg1050::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg1050T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMsg1050(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Msg1050> CreateMsg1050(flatbuffers::FlatBufferBuilder &_fbb, const Msg1050T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Msg1050T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _rsv = _o->rsv;
  return decision::CreateMsg1050(
      _fbb,
      _id,
      _rsv);
}

inline Msg2062T *Msg2062::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<decision::Msg2062T> _o = std::unique_ptr<decision::Msg2062T>(new Msg2062T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Msg2062::UnPackTo(Msg2062T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; }
  { auto _e = cmd(); _o->cmd = _e; }
  { auto _e = ack(); _o->ack = _e; }
}

inline flatbuffers::Offset<Msg2062> Msg2062::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg2062T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMsg2062(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Msg2062> CreateMsg2062(flatbuffers::FlatBufferBuilder &_fbb, const Msg2062T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Msg2062T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _cmd = _o->cmd;
  auto _ack = _o->ack;
  return decision::CreateMsg2062(
      _fbb,
      _id,
      _cmd,
      _ack);
}

inline Msg0404T *Msg0404::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<decision::Msg0404T> _o = std::unique_ptr<decision::Msg0404T>(new Msg0404T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Msg0404::UnPackTo(Msg0404T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; }
  { auto _e = manual_driving(); _o->manual_driving = _e; }
  { auto _e = task_type(); _o->task_type = _e; }
  { auto _e = direction(); _o->direction = _e; }
}

inline flatbuffers::Offset<Msg0404> Msg0404::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg0404T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMsg0404(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Msg0404> CreateMsg0404(flatbuffers::FlatBufferBuilder &_fbb, const Msg0404T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Msg0404T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _manual_driving = _o->manual_driving;
  auto _task_type = _o->task_type;
  auto _direction = _o->direction;
  return decision::CreateMsg0404(
      _fbb,
      _id,
      _manual_driving,
      _task_type,
      _direction);
}

inline Msg0500T *Msg0500::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<decision::Msg0500T> _o = std::unique_ptr<decision::Msg0500T>(new Msg0500T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Msg0500::UnPackTo(Msg0500T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; }
  { auto _e = state(); _o->state = _e; }
}

inline flatbuffers::Offset<Msg0500> Msg0500::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg0500T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMsg0500(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Msg0500> CreateMsg0500(flatbuffers::FlatBufferBuilder &_fbb, const Msg0500T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Msg0500T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _state = _o->state;
  return decision::CreateMsg0500(
      _fbb,
      _id,
      _state);
}

inline Msg0501T *Msg0501::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<decision::Msg0501T> _o = std::unique_ptr<decision::Msg0501T>(new Msg0501T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Msg0501::UnPackTo(Msg0501T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; }
  { auto _e = dis(); _o->dis = _e; }
}

inline flatbuffers::Offset<Msg0501> Msg0501::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg0501T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMsg0501(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Msg0501> CreateMsg0501(flatbuffers::FlatBufferBuilder &_fbb, const Msg0501T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Msg0501T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _dis = _o->dis;
  return decision::CreateMsg0501(
      _fbb,
      _id,
      _dis);
}

inline Msg8F1CT *Msg8F1C::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<decision::Msg8F1CT> _o = std::unique_ptr<decision::Msg8F1CT>(new Msg8F1CT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Msg8F1C::UnPackTo(Msg8F1CT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; }
  { auto _e = type(); _o->type = _e; }
  { auto _e = result(); _o->result = _e; }
  { auto _e = why_fail(); _o->why_fail = _e; }
}

inline flatbuffers::Offset<Msg8F1C> Msg8F1C::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg8F1CT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMsg8F1C(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Msg8F1C> CreateMsg8F1C(flatbuffers::FlatBufferBuilder &_fbb, const Msg8F1CT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Msg8F1CT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _type = _o->type;
  auto _result = _o->result;
  auto _why_fail = _o->why_fail;
  return decision::CreateMsg8F1C(
      _fbb,
      _id,
      _type,
      _result,
      _why_fail);
}

inline const flatbuffers::TypeTable *LatLonHeadTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_DOUBLE, 0, -1 },
    { flatbuffers::ET_DOUBLE, 0, -1 },
    { flatbuffers::ET_DOUBLE, 0, -1 }
  };
  static const char * const names[] = {
    "lat",
    "lng",
    "head"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *OutputTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    decision::LatLonHeadTypeTable
  };
  static const char * const names[] = {
    "drive_mode",
    "drive_mode_last",
    "drive_state",
    "drive_state_last",
    "drive_state_child",
    "drive_state_child_last",
    "fault",
    "target_key_point",
    "GpsPathList",
    "point_key",
    "park_point",
    "park_error",
    "ti_task_speed",
    "terminal",
    "exec_cmd",
    "load_status",
    "drive_state_desc",
    "drive_state_child_desc",
    "single_mode",
    "reference_line",
    "detour"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 21, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RoadTaskVehicleInfoTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_USHORT, 0, -1 }
  };
  static const char * const names[] = {
    "road_id",
    "remain_dis",
    "point_key",
    "task_id",
    "work_status",
    "task_file_name",
    "service_state",
    "reason",
    "run",
    "why_stop"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 10, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Msg1030TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 }
  };
  static const char * const names[] = {
    "id",
    "vehicle_length",
    "vehicle_width",
    "vehicle_height",
    "start_state"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Msg1050TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_USHORT, 0, -1 }
  };
  static const char * const names[] = {
    "id",
    "rsv"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Msg2062TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 }
  };
  static const char * const names[] = {
    "id",
    "cmd",
    "ack"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Msg0404TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_CHAR, 0, -1 },
    { flatbuffers::ET_CHAR, 0, -1 },
    { flatbuffers::ET_CHAR, 0, -1 }
  };
  static const char * const names[] = {
    "id",
    "manual_driving",
    "task_type",
    "direction"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Msg0500TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 }
  };
  static const char * const names[] = {
    "id",
    "state"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Msg0501TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_SHORT, 0, -1 }
  };
  static const char * const names[] = {
    "id",
    "dis"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Msg8F1CTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 }
  };
  static const char * const names[] = {
    "id",
    "type",
    "result",
    "why_fail"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const decision::Output *GetOutput(const void *buf) {
  return flatbuffers::GetRoot<decision::Output>(buf);
}

inline const decision::Output *GetSizePrefixedOutput(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<decision::Output>(buf);
}

inline Output *GetMutableOutput(void *buf) {
  return flatbuffers::GetMutableRoot<Output>(buf);
}

inline const char *OutputIdentifier() {
  return "DECO";
}

inline bool OutputBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, OutputIdentifier());
}

inline bool VerifyOutputBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<decision::Output>(OutputIdentifier());
}

inline bool VerifySizePrefixedOutputBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<decision::Output>(OutputIdentifier());
}

inline void FinishOutputBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<decision::Output> root) {
  fbb.Finish(root, OutputIdentifier());
}

inline void FinishSizePrefixedOutputBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<decision::Output> root) {
  fbb.FinishSizePrefixed(root, OutputIdentifier());
}

inline std::unique_ptr<decision::OutputT> UnPackOutput(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<decision::OutputT>(GetOutput(buf)->UnPack(res));
}

inline std::unique_ptr<decision::OutputT> UnPackSizePrefixedOutput(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<decision::OutputT>(GetSizePrefixedOutput(buf)->UnPack(res));
}

}  // namespace decision

#endif  // FLATBUFFERS_GENERATED_DECISION_DECISION_H_
