// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_DIAGNOSIS_DIAGNOSIS_H_
#define FLATBUFFERS_GENERATED_DIAGNOSIS_DIAGNOSIS_H_

#include "flatbuffers/flatbuffers.h"

namespace diagnosis {

struct Warning;

struct FaultArray;

struct WarningOutput;
struct WarningOutputBuilder;
struct WarningOutputT;

bool operator==(const Warning &lhs, const Warning &rhs);
bool operator!=(const Warning &lhs, const Warning &rhs);
bool operator==(const FaultArray &lhs, const FaultArray &rhs);
bool operator!=(const FaultArray &lhs, const FaultArray &rhs);
bool operator==(const WarningOutputT &lhs, const WarningOutputT &rhs);
bool operator!=(const WarningOutputT &lhs, const WarningOutputT &rhs);

inline const flatbuffers::TypeTable *WarningTypeTable();

inline const flatbuffers::TypeTable *FaultArrayTypeTable();

inline const flatbuffers::TypeTable *WarningOutputTypeTable();

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) Warning FLATBUFFERS_FINAL_CLASS {
 private:
  uint64_t warn_data1_;
  uint64_t warn_data2_;

 public:
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return WarningTypeTable();
  }
  Warning()
      : warn_data1_(0),
        warn_data2_(0) {
  }
  Warning(uint64_t _warn_data1, uint64_t _warn_data2)
      : warn_data1_(flatbuffers::EndianScalar(_warn_data1)),
        warn_data2_(flatbuffers::EndianScalar(_warn_data2)) {
  }
  uint64_t warn_data1() const {
    return flatbuffers::EndianScalar(warn_data1_);
  }
  void mutate_warn_data1(uint64_t _warn_data1) {
    flatbuffers::WriteScalar(&warn_data1_, _warn_data1);
  }
  uint64_t warn_data2() const {
    return flatbuffers::EndianScalar(warn_data2_);
  }
  void mutate_warn_data2(uint64_t _warn_data2) {
    flatbuffers::WriteScalar(&warn_data2_, _warn_data2);
  }
};
FLATBUFFERS_STRUCT_END(Warning, 16);

inline bool operator==(const Warning &lhs, const Warning &rhs) {
  return
      (lhs.warn_data1() == rhs.warn_data1()) &&
      (lhs.warn_data2() == rhs.warn_data2());
}

inline bool operator!=(const Warning &lhs, const Warning &rhs) {
    return !(lhs == rhs);
}


FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) FaultArray FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t fault_array_[16];

 public:
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return FaultArrayTypeTable();
  }
  FaultArray()
      : fault_array_() {
  }
  const flatbuffers::Array<uint8_t, 16> *fault_array() const {
    return reinterpret_cast<const flatbuffers::Array<uint8_t, 16> *>(fault_array_);
  }
  flatbuffers::Array<uint8_t, 16> *mutable_fault_array() {
    return reinterpret_cast<flatbuffers::Array<uint8_t, 16> *>(fault_array_);
  }
};
FLATBUFFERS_STRUCT_END(FaultArray, 16);

inline bool operator==(const FaultArray &lhs, const FaultArray &rhs) {
  return
      (lhs.fault_array() == rhs.fault_array());
}

inline bool operator!=(const FaultArray &lhs, const FaultArray &rhs) {
    return !(lhs == rhs);
}


struct WarningOutputT : public flatbuffers::NativeTable {
  typedef WarningOutput TableType;
  std::unique_ptr<diagnosis::Warning> warn;
  std::unique_ptr<diagnosis::FaultArray> fault_open;
  WarningOutputT() {
  }
};

inline bool operator==(const WarningOutputT &lhs, const WarningOutputT &rhs) {
  return
      (lhs.warn == rhs.warn) &&
      (lhs.fault_open == rhs.fault_open);
}

inline bool operator!=(const WarningOutputT &lhs, const WarningOutputT &rhs) {
    return !(lhs == rhs);
}


struct WarningOutput FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WarningOutputT NativeTableType;
  typedef WarningOutputBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return WarningOutputTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WARN = 4,
    VT_FAULT_OPEN = 6
  };
  const diagnosis::Warning *warn() const {
    return GetStruct<const diagnosis::Warning *>(VT_WARN);
  }
  diagnosis::Warning *mutable_warn() {
    return GetStruct<diagnosis::Warning *>(VT_WARN);
  }
  const diagnosis::FaultArray *fault_open() const {
    return GetStruct<const diagnosis::FaultArray *>(VT_FAULT_OPEN);
  }
  diagnosis::FaultArray *mutable_fault_open() {
    return GetStruct<diagnosis::FaultArray *>(VT_FAULT_OPEN);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<diagnosis::Warning>(verifier, VT_WARN) &&
           VerifyField<diagnosis::FaultArray>(verifier, VT_FAULT_OPEN) &&
           verifier.EndTable();
  }
  WarningOutputT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(WarningOutputT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<WarningOutput> Pack(flatbuffers::FlatBufferBuilder &_fbb, const WarningOutputT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct WarningOutputBuilder {
  typedef WarningOutput Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_warn(const diagnosis::Warning *warn) {
    fbb_.AddStruct(WarningOutput::VT_WARN, warn);
  }
  void add_fault_open(const diagnosis::FaultArray *fault_open) {
    fbb_.AddStruct(WarningOutput::VT_FAULT_OPEN, fault_open);
  }
  explicit WarningOutputBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<WarningOutput> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WarningOutput>(end);
    return o;
  }
};

inline flatbuffers::Offset<WarningOutput> CreateWarningOutput(
    flatbuffers::FlatBufferBuilder &_fbb,
    const diagnosis::Warning *warn = 0,
    const diagnosis::FaultArray *fault_open = 0) {
  WarningOutputBuilder builder_(_fbb);
  builder_.add_fault_open(fault_open);
  builder_.add_warn(warn);
  return builder_.Finish();
}

flatbuffers::Offset<WarningOutput> CreateWarningOutput(flatbuffers::FlatBufferBuilder &_fbb, const WarningOutputT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline WarningOutputT *WarningOutput::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<diagnosis::WarningOutputT> _o = std::unique_ptr<diagnosis::WarningOutputT>(new WarningOutputT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void WarningOutput::UnPackTo(WarningOutputT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = warn(); if (_e) _o->warn = std::unique_ptr<diagnosis::Warning>(new diagnosis::Warning(*_e)); }
  { auto _e = fault_open(); if (_e) _o->fault_open = std::unique_ptr<diagnosis::FaultArray>(new diagnosis::FaultArray(*_e)); }
}

inline flatbuffers::Offset<WarningOutput> WarningOutput::Pack(flatbuffers::FlatBufferBuilder &_fbb, const WarningOutputT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateWarningOutput(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<WarningOutput> CreateWarningOutput(flatbuffers::FlatBufferBuilder &_fbb, const WarningOutputT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const WarningOutputT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _warn = _o->warn ? _o->warn.get() : 0;
  auto _fault_open = _o->fault_open ? _o->fault_open.get() : 0;
  return diagnosis::CreateWarningOutput(
      _fbb,
      _warn,
      _fault_open);
}

inline const flatbuffers::TypeTable *WarningTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_ULONG, 0, -1 }
  };
  static const int64_t values[] = { 0, 8, 16 };
  static const char * const names[] = {
    "warn_data1",
    "warn_data2"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_STRUCT, 2, type_codes, nullptr, values, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *FaultArrayTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 }
  };
  static const int64_t values[] = { 0, 16 };
  static const char * const names[] = {
    "fault_array"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_STRUCT, 1, type_codes, nullptr, values, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *WarningOutputTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    diagnosis::WarningTypeTable,
    diagnosis::FaultArrayTypeTable
  };
  static const char * const names[] = {
    "warn",
    "fault_open"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const diagnosis::WarningOutput *GetWarningOutput(const void *buf) {
  return flatbuffers::GetRoot<diagnosis::WarningOutput>(buf);
}

inline const diagnosis::WarningOutput *GetSizePrefixedWarningOutput(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<diagnosis::WarningOutput>(buf);
}

inline WarningOutput *GetMutableWarningOutput(void *buf) {
  return flatbuffers::GetMutableRoot<WarningOutput>(buf);
}

inline const char *WarningOutputIdentifier() {
  return "FACO";
}

inline bool WarningOutputBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, WarningOutputIdentifier());
}

inline bool VerifyWarningOutputBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<diagnosis::WarningOutput>(WarningOutputIdentifier());
}

inline bool VerifySizePrefixedWarningOutputBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<diagnosis::WarningOutput>(WarningOutputIdentifier());
}

inline void FinishWarningOutputBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<diagnosis::WarningOutput> root) {
  fbb.Finish(root, WarningOutputIdentifier());
}

inline void FinishSizePrefixedWarningOutputBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<diagnosis::WarningOutput> root) {
  fbb.FinishSizePrefixed(root, WarningOutputIdentifier());
}

inline std::unique_ptr<diagnosis::WarningOutputT> UnPackWarningOutput(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<diagnosis::WarningOutputT>(GetWarningOutput(buf)->UnPack(res));
}

inline std::unique_ptr<diagnosis::WarningOutputT> UnPackSizePrefixedWarningOutput(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<diagnosis::WarningOutputT>(GetSizePrefixedWarningOutput(buf)->UnPack(res));
}

}  // namespace diagnosis

#endif  // FLATBUFFERS_GENERATED_DIAGNOSIS_DIAGNOSIS_H_
