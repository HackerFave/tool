// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_PREDICTION_PREDICTION_H_
#define FLATBUFFERS_GENERATED_PREDICTION_PREDICTION_H_

#include "flatbuffers/flatbuffers.h"

namespace prediction {

struct Point_xy;

struct Point_xyz;

struct Points;

struct Pointcar;

struct Pointwall;

struct LidarSickInfo;
struct LidarSickInfoBuilder;
struct LidarSickInfoT;

struct DataRecord_fuse;
struct DataRecord_fuseBuilder;
struct DataRecord_fuseT;

struct DataRecord_v2i;
struct DataRecord_v2iBuilder;
struct DataRecord_v2iT;

struct SteerPara;
struct SteerParaBuilder;
struct SteerParaT;

struct Lidardis;
struct LidardisBuilder;
struct LidardisT;

struct SenseResultInfo;
struct SenseResultInfoBuilder;
struct SenseResultInfoT;

bool operator==(const Point_xy &lhs, const Point_xy &rhs);
bool operator!=(const Point_xy &lhs, const Point_xy &rhs);
bool operator==(const Point_xyz &lhs, const Point_xyz &rhs);
bool operator!=(const Point_xyz &lhs, const Point_xyz &rhs);
bool operator==(const Points &lhs, const Points &rhs);
bool operator!=(const Points &lhs, const Points &rhs);
bool operator==(const Pointcar &lhs, const Pointcar &rhs);
bool operator!=(const Pointcar &lhs, const Pointcar &rhs);
bool operator==(const Pointwall &lhs, const Pointwall &rhs);
bool operator!=(const Pointwall &lhs, const Pointwall &rhs);
bool operator==(const LidarSickInfoT &lhs, const LidarSickInfoT &rhs);
bool operator!=(const LidarSickInfoT &lhs, const LidarSickInfoT &rhs);
bool operator==(const DataRecord_fuseT &lhs, const DataRecord_fuseT &rhs);
bool operator!=(const DataRecord_fuseT &lhs, const DataRecord_fuseT &rhs);
bool operator==(const DataRecord_v2iT &lhs, const DataRecord_v2iT &rhs);
bool operator!=(const DataRecord_v2iT &lhs, const DataRecord_v2iT &rhs);
bool operator==(const SteerParaT &lhs, const SteerParaT &rhs);
bool operator!=(const SteerParaT &lhs, const SteerParaT &rhs);
bool operator==(const LidardisT &lhs, const LidardisT &rhs);
bool operator!=(const LidardisT &lhs, const LidardisT &rhs);
bool operator==(const SenseResultInfoT &lhs, const SenseResultInfoT &rhs);
bool operator!=(const SenseResultInfoT &lhs, const SenseResultInfoT &rhs);

inline const flatbuffers::TypeTable *Point_xyTypeTable();

inline const flatbuffers::TypeTable *Point_xyzTypeTable();

inline const flatbuffers::TypeTable *PointsTypeTable();

inline const flatbuffers::TypeTable *PointcarTypeTable();

inline const flatbuffers::TypeTable *PointwallTypeTable();

inline const flatbuffers::TypeTable *LidarSickInfoTypeTable();

inline const flatbuffers::TypeTable *DataRecord_fuseTypeTable();

inline const flatbuffers::TypeTable *DataRecord_v2iTypeTable();

inline const flatbuffers::TypeTable *SteerParaTypeTable();

inline const flatbuffers::TypeTable *LidardisTypeTable();

inline const flatbuffers::TypeTable *SenseResultInfoTypeTable();

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Point_xy FLATBUFFERS_FINAL_CLASS {
 private:
  float xy_[2];

 public:
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Point_xyTypeTable();
  }
  Point_xy()
      : xy_() {
  }
  const flatbuffers::Array<float, 2> *xy() const {
    return reinterpret_cast<const flatbuffers::Array<float, 2> *>(xy_);
  }
  flatbuffers::Array<float, 2> *mutable_xy() {
    return reinterpret_cast<flatbuffers::Array<float, 2> *>(xy_);
  }
};
FLATBUFFERS_STRUCT_END(Point_xy, 8);

inline bool operator==(const Point_xy &lhs, const Point_xy &rhs) {
  return
      (lhs.xy() == rhs.xy());
}

inline bool operator!=(const Point_xy &lhs, const Point_xy &rhs) {
    return !(lhs == rhs);
}


FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Point_xyz FLATBUFFERS_FINAL_CLASS {
 private:
  float xyz_[3];

 public:
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Point_xyzTypeTable();
  }
  Point_xyz()
      : xyz_() {
  }
  const flatbuffers::Array<float, 3> *xyz() const {
    return reinterpret_cast<const flatbuffers::Array<float, 3> *>(xyz_);
  }
  flatbuffers::Array<float, 3> *mutable_xyz() {
    return reinterpret_cast<flatbuffers::Array<float, 3> *>(xyz_);
  }
};
FLATBUFFERS_STRUCT_END(Point_xyz, 12);

inline bool operator==(const Point_xyz &lhs, const Point_xyz &rhs) {
  return
      (lhs.xyz() == rhs.xyz());
}

inline bool operator!=(const Point_xyz &lhs, const Point_xyz &rhs) {
    return !(lhs == rhs);
}


FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Points FLATBUFFERS_FINAL_CLASS {
 private:
  prediction::Point_xyz vertex_[4];

 public:
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PointsTypeTable();
  }
  Points()
      : vertex_() {
  }
  const flatbuffers::Array<prediction::Point_xyz, 4> *vertex() const {
    return reinterpret_cast<const flatbuffers::Array<prediction::Point_xyz, 4> *>(vertex_);
  }
  flatbuffers::Array<prediction::Point_xyz, 4> *mutable_vertex() {
    return reinterpret_cast<flatbuffers::Array<prediction::Point_xyz, 4> *>(vertex_);
  }
};
FLATBUFFERS_STRUCT_END(Points, 48);

inline bool operator==(const Points &lhs, const Points &rhs) {
  return
      (lhs.vertex() == rhs.vertex());
}

inline bool operator!=(const Points &lhs, const Points &rhs) {
    return !(lhs == rhs);
}


FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Pointcar FLATBUFFERS_FINAL_CLASS {
 private:
  prediction::Point_xy vertex_[4];

 public:
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PointcarTypeTable();
  }
  Pointcar()
      : vertex_() {
  }
  const flatbuffers::Array<prediction::Point_xy, 4> *vertex() const {
    return reinterpret_cast<const flatbuffers::Array<prediction::Point_xy, 4> *>(vertex_);
  }
  flatbuffers::Array<prediction::Point_xy, 4> *mutable_vertex() {
    return reinterpret_cast<flatbuffers::Array<prediction::Point_xy, 4> *>(vertex_);
  }
};
FLATBUFFERS_STRUCT_END(Pointcar, 32);

inline bool operator==(const Pointcar &lhs, const Pointcar &rhs) {
  return
      (lhs.vertex() == rhs.vertex());
}

inline bool operator!=(const Pointcar &lhs, const Pointcar &rhs) {
    return !(lhs == rhs);
}


FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Pointwall FLATBUFFERS_FINAL_CLASS {
 private:
  prediction::Point_xy wall_[25];

 public:
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PointwallTypeTable();
  }
  Pointwall()
      : wall_() {
  }
  const flatbuffers::Array<prediction::Point_xy, 25> *wall() const {
    return reinterpret_cast<const flatbuffers::Array<prediction::Point_xy, 25> *>(wall_);
  }
  flatbuffers::Array<prediction::Point_xy, 25> *mutable_wall() {
    return reinterpret_cast<flatbuffers::Array<prediction::Point_xy, 25> *>(wall_);
  }
};
FLATBUFFERS_STRUCT_END(Pointwall, 200);

inline bool operator==(const Pointwall &lhs, const Pointwall &rhs) {
  return
      (lhs.wall() == rhs.wall());
}

inline bool operator!=(const Pointwall &lhs, const Pointwall &rhs) {
    return !(lhs == rhs);
}


struct LidarSickInfoT : public flatbuffers::NativeTable {
  typedef LidarSickInfo TableType;
  uint64_t Time;
  uint32_t object_number;
  uint32_t object_type;
  uint32_t detection_type;
  float object_dist_long;
  float object_dist_lat;
  float object_length;
  float object_width;
  float object_height;
  float object_head;
  float object_vrel_long;
  float object_vrel_lat;
  float object_min_long;
  bool stop_flag;
  LidarSickInfoT()
      : Time(0),
        object_number(0),
        object_type(0),
        detection_type(0),
        object_dist_long(0.0f),
        object_dist_lat(0.0f),
        object_length(0.0f),
        object_width(0.0f),
        object_height(0.0f),
        object_head(0.0f),
        object_vrel_long(0.0f),
        object_vrel_lat(0.0f),
        object_min_long(0.0f),
        stop_flag(false) {
  }
};

inline bool operator==(const LidarSickInfoT &lhs, const LidarSickInfoT &rhs) {
  return
      (lhs.Time == rhs.Time) &&
      (lhs.object_number == rhs.object_number) &&
      (lhs.object_type == rhs.object_type) &&
      (lhs.detection_type == rhs.detection_type) &&
      (lhs.object_dist_long == rhs.object_dist_long) &&
      (lhs.object_dist_lat == rhs.object_dist_lat) &&
      (lhs.object_length == rhs.object_length) &&
      (lhs.object_width == rhs.object_width) &&
      (lhs.object_height == rhs.object_height) &&
      (lhs.object_head == rhs.object_head) &&
      (lhs.object_vrel_long == rhs.object_vrel_long) &&
      (lhs.object_vrel_lat == rhs.object_vrel_lat) &&
      (lhs.object_min_long == rhs.object_min_long) &&
      (lhs.stop_flag == rhs.stop_flag);
}

inline bool operator!=(const LidarSickInfoT &lhs, const LidarSickInfoT &rhs) {
    return !(lhs == rhs);
}


struct LidarSickInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LidarSickInfoT NativeTableType;
  typedef LidarSickInfoBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LidarSickInfoTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIME = 4,
    VT_OBJECT_NUMBER = 6,
    VT_OBJECT_TYPE = 8,
    VT_DETECTION_TYPE = 10,
    VT_OBJECT_DIST_LONG = 12,
    VT_OBJECT_DIST_LAT = 14,
    VT_OBJECT_LENGTH = 16,
    VT_OBJECT_WIDTH = 18,
    VT_OBJECT_HEIGHT = 20,
    VT_OBJECT_HEAD = 22,
    VT_OBJECT_VREL_LONG = 24,
    VT_OBJECT_VREL_LAT = 26,
    VT_OBJECT_MIN_LONG = 28,
    VT_STOP_FLAG = 30
  };
  uint64_t Time() const {
    return GetField<uint64_t>(VT_TIME, 0);
  }
  bool mutate_Time(uint64_t _Time) {
    return SetField<uint64_t>(VT_TIME, _Time, 0);
  }
  uint32_t object_number() const {
    return GetField<uint32_t>(VT_OBJECT_NUMBER, 0);
  }
  bool mutate_object_number(uint32_t _object_number) {
    return SetField<uint32_t>(VT_OBJECT_NUMBER, _object_number, 0);
  }
  uint32_t object_type() const {
    return GetField<uint32_t>(VT_OBJECT_TYPE, 0);
  }
  bool mutate_object_type(uint32_t _object_type) {
    return SetField<uint32_t>(VT_OBJECT_TYPE, _object_type, 0);
  }
  uint32_t detection_type() const {
    return GetField<uint32_t>(VT_DETECTION_TYPE, 0);
  }
  bool mutate_detection_type(uint32_t _detection_type) {
    return SetField<uint32_t>(VT_DETECTION_TYPE, _detection_type, 0);
  }
  float object_dist_long() const {
    return GetField<float>(VT_OBJECT_DIST_LONG, 0.0f);
  }
  bool mutate_object_dist_long(float _object_dist_long) {
    return SetField<float>(VT_OBJECT_DIST_LONG, _object_dist_long, 0.0f);
  }
  float object_dist_lat() const {
    return GetField<float>(VT_OBJECT_DIST_LAT, 0.0f);
  }
  bool mutate_object_dist_lat(float _object_dist_lat) {
    return SetField<float>(VT_OBJECT_DIST_LAT, _object_dist_lat, 0.0f);
  }
  float object_length() const {
    return GetField<float>(VT_OBJECT_LENGTH, 0.0f);
  }
  bool mutate_object_length(float _object_length) {
    return SetField<float>(VT_OBJECT_LENGTH, _object_length, 0.0f);
  }
  float object_width() const {
    return GetField<float>(VT_OBJECT_WIDTH, 0.0f);
  }
  bool mutate_object_width(float _object_width) {
    return SetField<float>(VT_OBJECT_WIDTH, _object_width, 0.0f);
  }
  float object_height() const {
    return GetField<float>(VT_OBJECT_HEIGHT, 0.0f);
  }
  bool mutate_object_height(float _object_height) {
    return SetField<float>(VT_OBJECT_HEIGHT, _object_height, 0.0f);
  }
  float object_head() const {
    return GetField<float>(VT_OBJECT_HEAD, 0.0f);
  }
  bool mutate_object_head(float _object_head) {
    return SetField<float>(VT_OBJECT_HEAD, _object_head, 0.0f);
  }
  float object_vrel_long() const {
    return GetField<float>(VT_OBJECT_VREL_LONG, 0.0f);
  }
  bool mutate_object_vrel_long(float _object_vrel_long) {
    return SetField<float>(VT_OBJECT_VREL_LONG, _object_vrel_long, 0.0f);
  }
  float object_vrel_lat() const {
    return GetField<float>(VT_OBJECT_VREL_LAT, 0.0f);
  }
  bool mutate_object_vrel_lat(float _object_vrel_lat) {
    return SetField<float>(VT_OBJECT_VREL_LAT, _object_vrel_lat, 0.0f);
  }
  float object_min_long() const {
    return GetField<float>(VT_OBJECT_MIN_LONG, 0.0f);
  }
  bool mutate_object_min_long(float _object_min_long) {
    return SetField<float>(VT_OBJECT_MIN_LONG, _object_min_long, 0.0f);
  }
  bool stop_flag() const {
    return GetField<uint8_t>(VT_STOP_FLAG, 0) != 0;
  }
  bool mutate_stop_flag(bool _stop_flag) {
    return SetField<uint8_t>(VT_STOP_FLAG, static_cast<uint8_t>(_stop_flag), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_TIME) &&
           VerifyField<uint32_t>(verifier, VT_OBJECT_NUMBER) &&
           VerifyField<uint32_t>(verifier, VT_OBJECT_TYPE) &&
           VerifyField<uint32_t>(verifier, VT_DETECTION_TYPE) &&
           VerifyField<float>(verifier, VT_OBJECT_DIST_LONG) &&
           VerifyField<float>(verifier, VT_OBJECT_DIST_LAT) &&
           VerifyField<float>(verifier, VT_OBJECT_LENGTH) &&
           VerifyField<float>(verifier, VT_OBJECT_WIDTH) &&
           VerifyField<float>(verifier, VT_OBJECT_HEIGHT) &&
           VerifyField<float>(verifier, VT_OBJECT_HEAD) &&
           VerifyField<float>(verifier, VT_OBJECT_VREL_LONG) &&
           VerifyField<float>(verifier, VT_OBJECT_VREL_LAT) &&
           VerifyField<float>(verifier, VT_OBJECT_MIN_LONG) &&
           VerifyField<uint8_t>(verifier, VT_STOP_FLAG) &&
           verifier.EndTable();
  }
  LidarSickInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LidarSickInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LidarSickInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LidarSickInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LidarSickInfoBuilder {
  typedef LidarSickInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Time(uint64_t Time) {
    fbb_.AddElement<uint64_t>(LidarSickInfo::VT_TIME, Time, 0);
  }
  void add_object_number(uint32_t object_number) {
    fbb_.AddElement<uint32_t>(LidarSickInfo::VT_OBJECT_NUMBER, object_number, 0);
  }
  void add_object_type(uint32_t object_type) {
    fbb_.AddElement<uint32_t>(LidarSickInfo::VT_OBJECT_TYPE, object_type, 0);
  }
  void add_detection_type(uint32_t detection_type) {
    fbb_.AddElement<uint32_t>(LidarSickInfo::VT_DETECTION_TYPE, detection_type, 0);
  }
  void add_object_dist_long(float object_dist_long) {
    fbb_.AddElement<float>(LidarSickInfo::VT_OBJECT_DIST_LONG, object_dist_long, 0.0f);
  }
  void add_object_dist_lat(float object_dist_lat) {
    fbb_.AddElement<float>(LidarSickInfo::VT_OBJECT_DIST_LAT, object_dist_lat, 0.0f);
  }
  void add_object_length(float object_length) {
    fbb_.AddElement<float>(LidarSickInfo::VT_OBJECT_LENGTH, object_length, 0.0f);
  }
  void add_object_width(float object_width) {
    fbb_.AddElement<float>(LidarSickInfo::VT_OBJECT_WIDTH, object_width, 0.0f);
  }
  void add_object_height(float object_height) {
    fbb_.AddElement<float>(LidarSickInfo::VT_OBJECT_HEIGHT, object_height, 0.0f);
  }
  void add_object_head(float object_head) {
    fbb_.AddElement<float>(LidarSickInfo::VT_OBJECT_HEAD, object_head, 0.0f);
  }
  void add_object_vrel_long(float object_vrel_long) {
    fbb_.AddElement<float>(LidarSickInfo::VT_OBJECT_VREL_LONG, object_vrel_long, 0.0f);
  }
  void add_object_vrel_lat(float object_vrel_lat) {
    fbb_.AddElement<float>(LidarSickInfo::VT_OBJECT_VREL_LAT, object_vrel_lat, 0.0f);
  }
  void add_object_min_long(float object_min_long) {
    fbb_.AddElement<float>(LidarSickInfo::VT_OBJECT_MIN_LONG, object_min_long, 0.0f);
  }
  void add_stop_flag(bool stop_flag) {
    fbb_.AddElement<uint8_t>(LidarSickInfo::VT_STOP_FLAG, static_cast<uint8_t>(stop_flag), 0);
  }
  explicit LidarSickInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LidarSickInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LidarSickInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<LidarSickInfo> CreateLidarSickInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t Time = 0,
    uint32_t object_number = 0,
    uint32_t object_type = 0,
    uint32_t detection_type = 0,
    float object_dist_long = 0.0f,
    float object_dist_lat = 0.0f,
    float object_length = 0.0f,
    float object_width = 0.0f,
    float object_height = 0.0f,
    float object_head = 0.0f,
    float object_vrel_long = 0.0f,
    float object_vrel_lat = 0.0f,
    float object_min_long = 0.0f,
    bool stop_flag = false) {
  LidarSickInfoBuilder builder_(_fbb);
  builder_.add_Time(Time);
  builder_.add_object_min_long(object_min_long);
  builder_.add_object_vrel_lat(object_vrel_lat);
  builder_.add_object_vrel_long(object_vrel_long);
  builder_.add_object_head(object_head);
  builder_.add_object_height(object_height);
  builder_.add_object_width(object_width);
  builder_.add_object_length(object_length);
  builder_.add_object_dist_lat(object_dist_lat);
  builder_.add_object_dist_long(object_dist_long);
  builder_.add_detection_type(detection_type);
  builder_.add_object_type(object_type);
  builder_.add_object_number(object_number);
  builder_.add_stop_flag(stop_flag);
  return builder_.Finish();
}

flatbuffers::Offset<LidarSickInfo> CreateLidarSickInfo(flatbuffers::FlatBufferBuilder &_fbb, const LidarSickInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DataRecord_fuseT : public flatbuffers::NativeTable {
  typedef DataRecord_fuse TableType;
  uint32_t count;
  uint64_t Time;
  uint64_t record_time;
  uint32_t path_flag;
  uint32_t path_id;
  int32_t key_obstacle;
  uint32_t object_couter;
  bool is_impact;
  uint32_t object_type;
  uint32_t detection_type;
  float object_dist_long;
  float object_dist_lat;
  float object_length;
  float object_width;
  float object_height;
  float object_head;
  float object_vrel_long;
  float object_vrel_lat;
  std::unique_ptr<prediction::Points> p_corner;
  float object_min_long;
  bool stop_flag;
  float front_x;
  float front_y;
  float path_dis;
  float bia_dis;
  float cur_max;
  std::unique_ptr<prediction::Pointcar> point_car;
  float min_impact_point;
  uint32_t wall_count;
  std::unique_ptr<prediction::Pointwall> point_wall;
  float wall_y;
  float wall_x;
  std::unique_ptr<prediction::Pointwall> point_wall_left;
  DataRecord_fuseT()
      : count(0),
        Time(0),
        record_time(0),
        path_flag(0),
        path_id(0),
        key_obstacle(0),
        object_couter(0),
        is_impact(false),
        object_type(0),
        detection_type(0),
        object_dist_long(0.0f),
        object_dist_lat(0.0f),
        object_length(0.0f),
        object_width(0.0f),
        object_height(0.0f),
        object_head(0.0f),
        object_vrel_long(0.0f),
        object_vrel_lat(0.0f),
        object_min_long(0.0f),
        stop_flag(false),
        front_x(0.0f),
        front_y(0.0f),
        path_dis(0.0f),
        bia_dis(0.0f),
        cur_max(0.0f),
        min_impact_point(0.0f),
        wall_count(0),
        wall_y(0.0f),
        wall_x(0.0f) {
  }
};

inline bool operator==(const DataRecord_fuseT &lhs, const DataRecord_fuseT &rhs) {
  return
      (lhs.count == rhs.count) &&
      (lhs.Time == rhs.Time) &&
      (lhs.record_time == rhs.record_time) &&
      (lhs.path_flag == rhs.path_flag) &&
      (lhs.path_id == rhs.path_id) &&
      (lhs.key_obstacle == rhs.key_obstacle) &&
      (lhs.object_couter == rhs.object_couter) &&
      (lhs.is_impact == rhs.is_impact) &&
      (lhs.object_type == rhs.object_type) &&
      (lhs.detection_type == rhs.detection_type) &&
      (lhs.object_dist_long == rhs.object_dist_long) &&
      (lhs.object_dist_lat == rhs.object_dist_lat) &&
      (lhs.object_length == rhs.object_length) &&
      (lhs.object_width == rhs.object_width) &&
      (lhs.object_height == rhs.object_height) &&
      (lhs.object_head == rhs.object_head) &&
      (lhs.object_vrel_long == rhs.object_vrel_long) &&
      (lhs.object_vrel_lat == rhs.object_vrel_lat) &&
      (lhs.p_corner == rhs.p_corner) &&
      (lhs.object_min_long == rhs.object_min_long) &&
      (lhs.stop_flag == rhs.stop_flag) &&
      (lhs.front_x == rhs.front_x) &&
      (lhs.front_y == rhs.front_y) &&
      (lhs.path_dis == rhs.path_dis) &&
      (lhs.bia_dis == rhs.bia_dis) &&
      (lhs.cur_max == rhs.cur_max) &&
      (lhs.point_car == rhs.point_car) &&
      (lhs.min_impact_point == rhs.min_impact_point) &&
      (lhs.wall_count == rhs.wall_count) &&
      (lhs.point_wall == rhs.point_wall) &&
      (lhs.wall_y == rhs.wall_y) &&
      (lhs.wall_x == rhs.wall_x) &&
      (lhs.point_wall_left == rhs.point_wall_left);
}

inline bool operator!=(const DataRecord_fuseT &lhs, const DataRecord_fuseT &rhs) {
    return !(lhs == rhs);
}


struct DataRecord_fuse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DataRecord_fuseT NativeTableType;
  typedef DataRecord_fuseBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DataRecord_fuseTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COUNT = 4,
    VT_TIME = 6,
    VT_RECORD_TIME = 8,
    VT_PATH_FLAG = 10,
    VT_PATH_ID = 12,
    VT_KEY_OBSTACLE = 14,
    VT_OBJECT_COUTER = 16,
    VT_IS_IMPACT = 18,
    VT_OBJECT_TYPE = 20,
    VT_DETECTION_TYPE = 22,
    VT_OBJECT_DIST_LONG = 24,
    VT_OBJECT_DIST_LAT = 26,
    VT_OBJECT_LENGTH = 28,
    VT_OBJECT_WIDTH = 30,
    VT_OBJECT_HEIGHT = 32,
    VT_OBJECT_HEAD = 34,
    VT_OBJECT_VREL_LONG = 36,
    VT_OBJECT_VREL_LAT = 38,
    VT_P_CORNER = 40,
    VT_OBJECT_MIN_LONG = 42,
    VT_STOP_FLAG = 44,
    VT_FRONT_X = 46,
    VT_FRONT_Y = 48,
    VT_PATH_DIS = 50,
    VT_BIA_DIS = 52,
    VT_CUR_MAX = 54,
    VT_POINT_CAR = 56,
    VT_MIN_IMPACT_POINT = 58,
    VT_WALL_COUNT = 60,
    VT_POINT_WALL = 62,
    VT_WALL_Y = 64,
    VT_WALL_X = 66,
    VT_POINT_WALL_LEFT = 68
  };
  uint32_t count() const {
    return GetField<uint32_t>(VT_COUNT, 0);
  }
  bool mutate_count(uint32_t _count) {
    return SetField<uint32_t>(VT_COUNT, _count, 0);
  }
  uint64_t Time() const {
    return GetField<uint64_t>(VT_TIME, 0);
  }
  bool mutate_Time(uint64_t _Time) {
    return SetField<uint64_t>(VT_TIME, _Time, 0);
  }
  uint64_t record_time() const {
    return GetField<uint64_t>(VT_RECORD_TIME, 0);
  }
  bool mutate_record_time(uint64_t _record_time) {
    return SetField<uint64_t>(VT_RECORD_TIME, _record_time, 0);
  }
  uint32_t path_flag() const {
    return GetField<uint32_t>(VT_PATH_FLAG, 0);
  }
  bool mutate_path_flag(uint32_t _path_flag) {
    return SetField<uint32_t>(VT_PATH_FLAG, _path_flag, 0);
  }
  uint32_t path_id() const {
    return GetField<uint32_t>(VT_PATH_ID, 0);
  }
  bool mutate_path_id(uint32_t _path_id) {
    return SetField<uint32_t>(VT_PATH_ID, _path_id, 0);
  }
  int32_t key_obstacle() const {
    return GetField<int32_t>(VT_KEY_OBSTACLE, 0);
  }
  bool mutate_key_obstacle(int32_t _key_obstacle) {
    return SetField<int32_t>(VT_KEY_OBSTACLE, _key_obstacle, 0);
  }
  uint32_t object_couter() const {
    return GetField<uint32_t>(VT_OBJECT_COUTER, 0);
  }
  bool mutate_object_couter(uint32_t _object_couter) {
    return SetField<uint32_t>(VT_OBJECT_COUTER, _object_couter, 0);
  }
  bool is_impact() const {
    return GetField<uint8_t>(VT_IS_IMPACT, 0) != 0;
  }
  bool mutate_is_impact(bool _is_impact) {
    return SetField<uint8_t>(VT_IS_IMPACT, static_cast<uint8_t>(_is_impact), 0);
  }
  uint32_t object_type() const {
    return GetField<uint32_t>(VT_OBJECT_TYPE, 0);
  }
  bool mutate_object_type(uint32_t _object_type) {
    return SetField<uint32_t>(VT_OBJECT_TYPE, _object_type, 0);
  }
  uint32_t detection_type() const {
    return GetField<uint32_t>(VT_DETECTION_TYPE, 0);
  }
  bool mutate_detection_type(uint32_t _detection_type) {
    return SetField<uint32_t>(VT_DETECTION_TYPE, _detection_type, 0);
  }
  float object_dist_long() const {
    return GetField<float>(VT_OBJECT_DIST_LONG, 0.0f);
  }
  bool mutate_object_dist_long(float _object_dist_long) {
    return SetField<float>(VT_OBJECT_DIST_LONG, _object_dist_long, 0.0f);
  }
  float object_dist_lat() const {
    return GetField<float>(VT_OBJECT_DIST_LAT, 0.0f);
  }
  bool mutate_object_dist_lat(float _object_dist_lat) {
    return SetField<float>(VT_OBJECT_DIST_LAT, _object_dist_lat, 0.0f);
  }
  float object_length() const {
    return GetField<float>(VT_OBJECT_LENGTH, 0.0f);
  }
  bool mutate_object_length(float _object_length) {
    return SetField<float>(VT_OBJECT_LENGTH, _object_length, 0.0f);
  }
  float object_width() const {
    return GetField<float>(VT_OBJECT_WIDTH, 0.0f);
  }
  bool mutate_object_width(float _object_width) {
    return SetField<float>(VT_OBJECT_WIDTH, _object_width, 0.0f);
  }
  float object_height() const {
    return GetField<float>(VT_OBJECT_HEIGHT, 0.0f);
  }
  bool mutate_object_height(float _object_height) {
    return SetField<float>(VT_OBJECT_HEIGHT, _object_height, 0.0f);
  }
  float object_head() const {
    return GetField<float>(VT_OBJECT_HEAD, 0.0f);
  }
  bool mutate_object_head(float _object_head) {
    return SetField<float>(VT_OBJECT_HEAD, _object_head, 0.0f);
  }
  float object_vrel_long() const {
    return GetField<float>(VT_OBJECT_VREL_LONG, 0.0f);
  }
  bool mutate_object_vrel_long(float _object_vrel_long) {
    return SetField<float>(VT_OBJECT_VREL_LONG, _object_vrel_long, 0.0f);
  }
  float object_vrel_lat() const {
    return GetField<float>(VT_OBJECT_VREL_LAT, 0.0f);
  }
  bool mutate_object_vrel_lat(float _object_vrel_lat) {
    return SetField<float>(VT_OBJECT_VREL_LAT, _object_vrel_lat, 0.0f);
  }
  const prediction::Points *p_corner() const {
    return GetStruct<const prediction::Points *>(VT_P_CORNER);
  }
  prediction::Points *mutable_p_corner() {
    return GetStruct<prediction::Points *>(VT_P_CORNER);
  }
  float object_min_long() const {
    return GetField<float>(VT_OBJECT_MIN_LONG, 0.0f);
  }
  bool mutate_object_min_long(float _object_min_long) {
    return SetField<float>(VT_OBJECT_MIN_LONG, _object_min_long, 0.0f);
  }
  bool stop_flag() const {
    return GetField<uint8_t>(VT_STOP_FLAG, 0) != 0;
  }
  bool mutate_stop_flag(bool _stop_flag) {
    return SetField<uint8_t>(VT_STOP_FLAG, static_cast<uint8_t>(_stop_flag), 0);
  }
  float front_x() const {
    return GetField<float>(VT_FRONT_X, 0.0f);
  }
  bool mutate_front_x(float _front_x) {
    return SetField<float>(VT_FRONT_X, _front_x, 0.0f);
  }
  float front_y() const {
    return GetField<float>(VT_FRONT_Y, 0.0f);
  }
  bool mutate_front_y(float _front_y) {
    return SetField<float>(VT_FRONT_Y, _front_y, 0.0f);
  }
  float path_dis() const {
    return GetField<float>(VT_PATH_DIS, 0.0f);
  }
  bool mutate_path_dis(float _path_dis) {
    return SetField<float>(VT_PATH_DIS, _path_dis, 0.0f);
  }
  float bia_dis() const {
    return GetField<float>(VT_BIA_DIS, 0.0f);
  }
  bool mutate_bia_dis(float _bia_dis) {
    return SetField<float>(VT_BIA_DIS, _bia_dis, 0.0f);
  }
  float cur_max() const {
    return GetField<float>(VT_CUR_MAX, 0.0f);
  }
  bool mutate_cur_max(float _cur_max) {
    return SetField<float>(VT_CUR_MAX, _cur_max, 0.0f);
  }
  const prediction::Pointcar *point_car() const {
    return GetStruct<const prediction::Pointcar *>(VT_POINT_CAR);
  }
  prediction::Pointcar *mutable_point_car() {
    return GetStruct<prediction::Pointcar *>(VT_POINT_CAR);
  }
  float min_impact_point() const {
    return GetField<float>(VT_MIN_IMPACT_POINT, 0.0f);
  }
  bool mutate_min_impact_point(float _min_impact_point) {
    return SetField<float>(VT_MIN_IMPACT_POINT, _min_impact_point, 0.0f);
  }
  uint32_t wall_count() const {
    return GetField<uint32_t>(VT_WALL_COUNT, 0);
  }
  bool mutate_wall_count(uint32_t _wall_count) {
    return SetField<uint32_t>(VT_WALL_COUNT, _wall_count, 0);
  }
  const prediction::Pointwall *point_wall() const {
    return GetStruct<const prediction::Pointwall *>(VT_POINT_WALL);
  }
  prediction::Pointwall *mutable_point_wall() {
    return GetStruct<prediction::Pointwall *>(VT_POINT_WALL);
  }
  float wall_y() const {
    return GetField<float>(VT_WALL_Y, 0.0f);
  }
  bool mutate_wall_y(float _wall_y) {
    return SetField<float>(VT_WALL_Y, _wall_y, 0.0f);
  }
  float wall_x() const {
    return GetField<float>(VT_WALL_X, 0.0f);
  }
  bool mutate_wall_x(float _wall_x) {
    return SetField<float>(VT_WALL_X, _wall_x, 0.0f);
  }
  const prediction::Pointwall *point_wall_left() const {
    return GetStruct<const prediction::Pointwall *>(VT_POINT_WALL_LEFT);
  }
  prediction::Pointwall *mutable_point_wall_left() {
    return GetStruct<prediction::Pointwall *>(VT_POINT_WALL_LEFT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_COUNT) &&
           VerifyField<uint64_t>(verifier, VT_TIME) &&
           VerifyField<uint64_t>(verifier, VT_RECORD_TIME) &&
           VerifyField<uint32_t>(verifier, VT_PATH_FLAG) &&
           VerifyField<uint32_t>(verifier, VT_PATH_ID) &&
           VerifyField<int32_t>(verifier, VT_KEY_OBSTACLE) &&
           VerifyField<uint32_t>(verifier, VT_OBJECT_COUTER) &&
           VerifyField<uint8_t>(verifier, VT_IS_IMPACT) &&
           VerifyField<uint32_t>(verifier, VT_OBJECT_TYPE) &&
           VerifyField<uint32_t>(verifier, VT_DETECTION_TYPE) &&
           VerifyField<float>(verifier, VT_OBJECT_DIST_LONG) &&
           VerifyField<float>(verifier, VT_OBJECT_DIST_LAT) &&
           VerifyField<float>(verifier, VT_OBJECT_LENGTH) &&
           VerifyField<float>(verifier, VT_OBJECT_WIDTH) &&
           VerifyField<float>(verifier, VT_OBJECT_HEIGHT) &&
           VerifyField<float>(verifier, VT_OBJECT_HEAD) &&
           VerifyField<float>(verifier, VT_OBJECT_VREL_LONG) &&
           VerifyField<float>(verifier, VT_OBJECT_VREL_LAT) &&
           VerifyField<prediction::Points>(verifier, VT_P_CORNER) &&
           VerifyField<float>(verifier, VT_OBJECT_MIN_LONG) &&
           VerifyField<uint8_t>(verifier, VT_STOP_FLAG) &&
           VerifyField<float>(verifier, VT_FRONT_X) &&
           VerifyField<float>(verifier, VT_FRONT_Y) &&
           VerifyField<float>(verifier, VT_PATH_DIS) &&
           VerifyField<float>(verifier, VT_BIA_DIS) &&
           VerifyField<float>(verifier, VT_CUR_MAX) &&
           VerifyField<prediction::Pointcar>(verifier, VT_POINT_CAR) &&
           VerifyField<float>(verifier, VT_MIN_IMPACT_POINT) &&
           VerifyField<uint32_t>(verifier, VT_WALL_COUNT) &&
           VerifyField<prediction::Pointwall>(verifier, VT_POINT_WALL) &&
           VerifyField<float>(verifier, VT_WALL_Y) &&
           VerifyField<float>(verifier, VT_WALL_X) &&
           VerifyField<prediction::Pointwall>(verifier, VT_POINT_WALL_LEFT) &&
           verifier.EndTable();
  }
  DataRecord_fuseT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DataRecord_fuseT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DataRecord_fuse> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DataRecord_fuseT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DataRecord_fuseBuilder {
  typedef DataRecord_fuse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_count(uint32_t count) {
    fbb_.AddElement<uint32_t>(DataRecord_fuse::VT_COUNT, count, 0);
  }
  void add_Time(uint64_t Time) {
    fbb_.AddElement<uint64_t>(DataRecord_fuse::VT_TIME, Time, 0);
  }
  void add_record_time(uint64_t record_time) {
    fbb_.AddElement<uint64_t>(DataRecord_fuse::VT_RECORD_TIME, record_time, 0);
  }
  void add_path_flag(uint32_t path_flag) {
    fbb_.AddElement<uint32_t>(DataRecord_fuse::VT_PATH_FLAG, path_flag, 0);
  }
  void add_path_id(uint32_t path_id) {
    fbb_.AddElement<uint32_t>(DataRecord_fuse::VT_PATH_ID, path_id, 0);
  }
  void add_key_obstacle(int32_t key_obstacle) {
    fbb_.AddElement<int32_t>(DataRecord_fuse::VT_KEY_OBSTACLE, key_obstacle, 0);
  }
  void add_object_couter(uint32_t object_couter) {
    fbb_.AddElement<uint32_t>(DataRecord_fuse::VT_OBJECT_COUTER, object_couter, 0);
  }
  void add_is_impact(bool is_impact) {
    fbb_.AddElement<uint8_t>(DataRecord_fuse::VT_IS_IMPACT, static_cast<uint8_t>(is_impact), 0);
  }
  void add_object_type(uint32_t object_type) {
    fbb_.AddElement<uint32_t>(DataRecord_fuse::VT_OBJECT_TYPE, object_type, 0);
  }
  void add_detection_type(uint32_t detection_type) {
    fbb_.AddElement<uint32_t>(DataRecord_fuse::VT_DETECTION_TYPE, detection_type, 0);
  }
  void add_object_dist_long(float object_dist_long) {
    fbb_.AddElement<float>(DataRecord_fuse::VT_OBJECT_DIST_LONG, object_dist_long, 0.0f);
  }
  void add_object_dist_lat(float object_dist_lat) {
    fbb_.AddElement<float>(DataRecord_fuse::VT_OBJECT_DIST_LAT, object_dist_lat, 0.0f);
  }
  void add_object_length(float object_length) {
    fbb_.AddElement<float>(DataRecord_fuse::VT_OBJECT_LENGTH, object_length, 0.0f);
  }
  void add_object_width(float object_width) {
    fbb_.AddElement<float>(DataRecord_fuse::VT_OBJECT_WIDTH, object_width, 0.0f);
  }
  void add_object_height(float object_height) {
    fbb_.AddElement<float>(DataRecord_fuse::VT_OBJECT_HEIGHT, object_height, 0.0f);
  }
  void add_object_head(float object_head) {
    fbb_.AddElement<float>(DataRecord_fuse::VT_OBJECT_HEAD, object_head, 0.0f);
  }
  void add_object_vrel_long(float object_vrel_long) {
    fbb_.AddElement<float>(DataRecord_fuse::VT_OBJECT_VREL_LONG, object_vrel_long, 0.0f);
  }
  void add_object_vrel_lat(float object_vrel_lat) {
    fbb_.AddElement<float>(DataRecord_fuse::VT_OBJECT_VREL_LAT, object_vrel_lat, 0.0f);
  }
  void add_p_corner(const prediction::Points *p_corner) {
    fbb_.AddStruct(DataRecord_fuse::VT_P_CORNER, p_corner);
  }
  void add_object_min_long(float object_min_long) {
    fbb_.AddElement<float>(DataRecord_fuse::VT_OBJECT_MIN_LONG, object_min_long, 0.0f);
  }
  void add_stop_flag(bool stop_flag) {
    fbb_.AddElement<uint8_t>(DataRecord_fuse::VT_STOP_FLAG, static_cast<uint8_t>(stop_flag), 0);
  }
  void add_front_x(float front_x) {
    fbb_.AddElement<float>(DataRecord_fuse::VT_FRONT_X, front_x, 0.0f);
  }
  void add_front_y(float front_y) {
    fbb_.AddElement<float>(DataRecord_fuse::VT_FRONT_Y, front_y, 0.0f);
  }
  void add_path_dis(float path_dis) {
    fbb_.AddElement<float>(DataRecord_fuse::VT_PATH_DIS, path_dis, 0.0f);
  }
  void add_bia_dis(float bia_dis) {
    fbb_.AddElement<float>(DataRecord_fuse::VT_BIA_DIS, bia_dis, 0.0f);
  }
  void add_cur_max(float cur_max) {
    fbb_.AddElement<float>(DataRecord_fuse::VT_CUR_MAX, cur_max, 0.0f);
  }
  void add_point_car(const prediction::Pointcar *point_car) {
    fbb_.AddStruct(DataRecord_fuse::VT_POINT_CAR, point_car);
  }
  void add_min_impact_point(float min_impact_point) {
    fbb_.AddElement<float>(DataRecord_fuse::VT_MIN_IMPACT_POINT, min_impact_point, 0.0f);
  }
  void add_wall_count(uint32_t wall_count) {
    fbb_.AddElement<uint32_t>(DataRecord_fuse::VT_WALL_COUNT, wall_count, 0);
  }
  void add_point_wall(const prediction::Pointwall *point_wall) {
    fbb_.AddStruct(DataRecord_fuse::VT_POINT_WALL, point_wall);
  }
  void add_wall_y(float wall_y) {
    fbb_.AddElement<float>(DataRecord_fuse::VT_WALL_Y, wall_y, 0.0f);
  }
  void add_wall_x(float wall_x) {
    fbb_.AddElement<float>(DataRecord_fuse::VT_WALL_X, wall_x, 0.0f);
  }
  void add_point_wall_left(const prediction::Pointwall *point_wall_left) {
    fbb_.AddStruct(DataRecord_fuse::VT_POINT_WALL_LEFT, point_wall_left);
  }
  explicit DataRecord_fuseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DataRecord_fuse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DataRecord_fuse>(end);
    return o;
  }
};

inline flatbuffers::Offset<DataRecord_fuse> CreateDataRecord_fuse(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t count = 0,
    uint64_t Time = 0,
    uint64_t record_time = 0,
    uint32_t path_flag = 0,
    uint32_t path_id = 0,
    int32_t key_obstacle = 0,
    uint32_t object_couter = 0,
    bool is_impact = false,
    uint32_t object_type = 0,
    uint32_t detection_type = 0,
    float object_dist_long = 0.0f,
    float object_dist_lat = 0.0f,
    float object_length = 0.0f,
    float object_width = 0.0f,
    float object_height = 0.0f,
    float object_head = 0.0f,
    float object_vrel_long = 0.0f,
    float object_vrel_lat = 0.0f,
    const prediction::Points *p_corner = 0,
    float object_min_long = 0.0f,
    bool stop_flag = false,
    float front_x = 0.0f,
    float front_y = 0.0f,
    float path_dis = 0.0f,
    float bia_dis = 0.0f,
    float cur_max = 0.0f,
    const prediction::Pointcar *point_car = 0,
    float min_impact_point = 0.0f,
    uint32_t wall_count = 0,
    const prediction::Pointwall *point_wall = 0,
    float wall_y = 0.0f,
    float wall_x = 0.0f,
    const prediction::Pointwall *point_wall_left = 0) {
  DataRecord_fuseBuilder builder_(_fbb);
  builder_.add_record_time(record_time);
  builder_.add_Time(Time);
  builder_.add_point_wall_left(point_wall_left);
  builder_.add_wall_x(wall_x);
  builder_.add_wall_y(wall_y);
  builder_.add_point_wall(point_wall);
  builder_.add_wall_count(wall_count);
  builder_.add_min_impact_point(min_impact_point);
  builder_.add_point_car(point_car);
  builder_.add_cur_max(cur_max);
  builder_.add_bia_dis(bia_dis);
  builder_.add_path_dis(path_dis);
  builder_.add_front_y(front_y);
  builder_.add_front_x(front_x);
  builder_.add_object_min_long(object_min_long);
  builder_.add_p_corner(p_corner);
  builder_.add_object_vrel_lat(object_vrel_lat);
  builder_.add_object_vrel_long(object_vrel_long);
  builder_.add_object_head(object_head);
  builder_.add_object_height(object_height);
  builder_.add_object_width(object_width);
  builder_.add_object_length(object_length);
  builder_.add_object_dist_lat(object_dist_lat);
  builder_.add_object_dist_long(object_dist_long);
  builder_.add_detection_type(detection_type);
  builder_.add_object_type(object_type);
  builder_.add_object_couter(object_couter);
  builder_.add_key_obstacle(key_obstacle);
  builder_.add_path_id(path_id);
  builder_.add_path_flag(path_flag);
  builder_.add_count(count);
  builder_.add_stop_flag(stop_flag);
  builder_.add_is_impact(is_impact);
  return builder_.Finish();
}

flatbuffers::Offset<DataRecord_fuse> CreateDataRecord_fuse(flatbuffers::FlatBufferBuilder &_fbb, const DataRecord_fuseT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DataRecord_v2iT : public flatbuffers::NativeTable {
  typedef DataRecord_v2i TableType;
  uint32_t count;
  uint32_t path_id;
  int32_t key_obstacle;
  uint64_t record_time;
  bool is_impact;
  bool is_expand_impact_result;
  float y_V2Vcar;
  float x_V2Vcar;
  float x_center;
  float y_center;
  float width_V2Vcar;
  float height_V2Vcar;
  std::unique_ptr<prediction::Pointcar> p_coner;
  uint32_t huiche_flag;
  std::unique_ptr<prediction::Pointcar> point_car;
  float dis_path;
  float v2i_stop_x;
  float v2i_stop_y;
  float y_limit;
  float x_limit;
  float width_limit;
  float V2V_limit_flag;
  DataRecord_v2iT()
      : count(0),
        path_id(0),
        key_obstacle(0),
        record_time(0),
        is_impact(false),
        is_expand_impact_result(false),
        y_V2Vcar(0.0f),
        x_V2Vcar(0.0f),
        x_center(0.0f),
        y_center(0.0f),
        width_V2Vcar(0.0f),
        height_V2Vcar(0.0f),
        huiche_flag(0),
        dis_path(0.0f),
        v2i_stop_x(0.0f),
        v2i_stop_y(0.0f),
        y_limit(0.0f),
        x_limit(0.0f),
        width_limit(0.0f),
        V2V_limit_flag(0.0f) {
  }
};

inline bool operator==(const DataRecord_v2iT &lhs, const DataRecord_v2iT &rhs) {
  return
      (lhs.count == rhs.count) &&
      (lhs.path_id == rhs.path_id) &&
      (lhs.key_obstacle == rhs.key_obstacle) &&
      (lhs.record_time == rhs.record_time) &&
      (lhs.is_impact == rhs.is_impact) &&
      (lhs.is_expand_impact_result == rhs.is_expand_impact_result) &&
      (lhs.y_V2Vcar == rhs.y_V2Vcar) &&
      (lhs.x_V2Vcar == rhs.x_V2Vcar) &&
      (lhs.x_center == rhs.x_center) &&
      (lhs.y_center == rhs.y_center) &&
      (lhs.width_V2Vcar == rhs.width_V2Vcar) &&
      (lhs.height_V2Vcar == rhs.height_V2Vcar) &&
      (lhs.p_coner == rhs.p_coner) &&
      (lhs.huiche_flag == rhs.huiche_flag) &&
      (lhs.point_car == rhs.point_car) &&
      (lhs.dis_path == rhs.dis_path) &&
      (lhs.v2i_stop_x == rhs.v2i_stop_x) &&
      (lhs.v2i_stop_y == rhs.v2i_stop_y) &&
      (lhs.y_limit == rhs.y_limit) &&
      (lhs.x_limit == rhs.x_limit) &&
      (lhs.width_limit == rhs.width_limit) &&
      (lhs.V2V_limit_flag == rhs.V2V_limit_flag);
}

inline bool operator!=(const DataRecord_v2iT &lhs, const DataRecord_v2iT &rhs) {
    return !(lhs == rhs);
}


struct DataRecord_v2i FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DataRecord_v2iT NativeTableType;
  typedef DataRecord_v2iBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DataRecord_v2iTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COUNT = 4,
    VT_PATH_ID = 6,
    VT_KEY_OBSTACLE = 8,
    VT_RECORD_TIME = 10,
    VT_IS_IMPACT = 12,
    VT_IS_EXPAND_IMPACT_RESULT = 14,
    VT_Y_V2VCAR = 16,
    VT_X_V2VCAR = 18,
    VT_X_CENTER = 20,
    VT_Y_CENTER = 22,
    VT_WIDTH_V2VCAR = 24,
    VT_HEIGHT_V2VCAR = 26,
    VT_P_CONER = 28,
    VT_HUICHE_FLAG = 30,
    VT_POINT_CAR = 32,
    VT_DIS_PATH = 34,
    VT_V2I_STOP_X = 36,
    VT_V2I_STOP_Y = 38,
    VT_Y_LIMIT = 40,
    VT_X_LIMIT = 42,
    VT_WIDTH_LIMIT = 44,
    VT_V2V_LIMIT_FLAG = 46
  };
  uint32_t count() const {
    return GetField<uint32_t>(VT_COUNT, 0);
  }
  bool mutate_count(uint32_t _count) {
    return SetField<uint32_t>(VT_COUNT, _count, 0);
  }
  uint32_t path_id() const {
    return GetField<uint32_t>(VT_PATH_ID, 0);
  }
  bool mutate_path_id(uint32_t _path_id) {
    return SetField<uint32_t>(VT_PATH_ID, _path_id, 0);
  }
  int32_t key_obstacle() const {
    return GetField<int32_t>(VT_KEY_OBSTACLE, 0);
  }
  bool mutate_key_obstacle(int32_t _key_obstacle) {
    return SetField<int32_t>(VT_KEY_OBSTACLE, _key_obstacle, 0);
  }
  uint64_t record_time() const {
    return GetField<uint64_t>(VT_RECORD_TIME, 0);
  }
  bool mutate_record_time(uint64_t _record_time) {
    return SetField<uint64_t>(VT_RECORD_TIME, _record_time, 0);
  }
  bool is_impact() const {
    return GetField<uint8_t>(VT_IS_IMPACT, 0) != 0;
  }
  bool mutate_is_impact(bool _is_impact) {
    return SetField<uint8_t>(VT_IS_IMPACT, static_cast<uint8_t>(_is_impact), 0);
  }
  bool is_expand_impact_result() const {
    return GetField<uint8_t>(VT_IS_EXPAND_IMPACT_RESULT, 0) != 0;
  }
  bool mutate_is_expand_impact_result(bool _is_expand_impact_result) {
    return SetField<uint8_t>(VT_IS_EXPAND_IMPACT_RESULT, static_cast<uint8_t>(_is_expand_impact_result), 0);
  }
  float y_V2Vcar() const {
    return GetField<float>(VT_Y_V2VCAR, 0.0f);
  }
  bool mutate_y_V2Vcar(float _y_V2Vcar) {
    return SetField<float>(VT_Y_V2VCAR, _y_V2Vcar, 0.0f);
  }
  float x_V2Vcar() const {
    return GetField<float>(VT_X_V2VCAR, 0.0f);
  }
  bool mutate_x_V2Vcar(float _x_V2Vcar) {
    return SetField<float>(VT_X_V2VCAR, _x_V2Vcar, 0.0f);
  }
  float x_center() const {
    return GetField<float>(VT_X_CENTER, 0.0f);
  }
  bool mutate_x_center(float _x_center) {
    return SetField<float>(VT_X_CENTER, _x_center, 0.0f);
  }
  float y_center() const {
    return GetField<float>(VT_Y_CENTER, 0.0f);
  }
  bool mutate_y_center(float _y_center) {
    return SetField<float>(VT_Y_CENTER, _y_center, 0.0f);
  }
  float width_V2Vcar() const {
    return GetField<float>(VT_WIDTH_V2VCAR, 0.0f);
  }
  bool mutate_width_V2Vcar(float _width_V2Vcar) {
    return SetField<float>(VT_WIDTH_V2VCAR, _width_V2Vcar, 0.0f);
  }
  float height_V2Vcar() const {
    return GetField<float>(VT_HEIGHT_V2VCAR, 0.0f);
  }
  bool mutate_height_V2Vcar(float _height_V2Vcar) {
    return SetField<float>(VT_HEIGHT_V2VCAR, _height_V2Vcar, 0.0f);
  }
  const prediction::Pointcar *p_coner() const {
    return GetStruct<const prediction::Pointcar *>(VT_P_CONER);
  }
  prediction::Pointcar *mutable_p_coner() {
    return GetStruct<prediction::Pointcar *>(VT_P_CONER);
  }
  uint32_t huiche_flag() const {
    return GetField<uint32_t>(VT_HUICHE_FLAG, 0);
  }
  bool mutate_huiche_flag(uint32_t _huiche_flag) {
    return SetField<uint32_t>(VT_HUICHE_FLAG, _huiche_flag, 0);
  }
  const prediction::Pointcar *point_car() const {
    return GetStruct<const prediction::Pointcar *>(VT_POINT_CAR);
  }
  prediction::Pointcar *mutable_point_car() {
    return GetStruct<prediction::Pointcar *>(VT_POINT_CAR);
  }
  float dis_path() const {
    return GetField<float>(VT_DIS_PATH, 0.0f);
  }
  bool mutate_dis_path(float _dis_path) {
    return SetField<float>(VT_DIS_PATH, _dis_path, 0.0f);
  }
  float v2i_stop_x() const {
    return GetField<float>(VT_V2I_STOP_X, 0.0f);
  }
  bool mutate_v2i_stop_x(float _v2i_stop_x) {
    return SetField<float>(VT_V2I_STOP_X, _v2i_stop_x, 0.0f);
  }
  float v2i_stop_y() const {
    return GetField<float>(VT_V2I_STOP_Y, 0.0f);
  }
  bool mutate_v2i_stop_y(float _v2i_stop_y) {
    return SetField<float>(VT_V2I_STOP_Y, _v2i_stop_y, 0.0f);
  }
  float y_limit() const {
    return GetField<float>(VT_Y_LIMIT, 0.0f);
  }
  bool mutate_y_limit(float _y_limit) {
    return SetField<float>(VT_Y_LIMIT, _y_limit, 0.0f);
  }
  float x_limit() const {
    return GetField<float>(VT_X_LIMIT, 0.0f);
  }
  bool mutate_x_limit(float _x_limit) {
    return SetField<float>(VT_X_LIMIT, _x_limit, 0.0f);
  }
  float width_limit() const {
    return GetField<float>(VT_WIDTH_LIMIT, 0.0f);
  }
  bool mutate_width_limit(float _width_limit) {
    return SetField<float>(VT_WIDTH_LIMIT, _width_limit, 0.0f);
  }
  float V2V_limit_flag() const {
    return GetField<float>(VT_V2V_LIMIT_FLAG, 0.0f);
  }
  bool mutate_V2V_limit_flag(float _V2V_limit_flag) {
    return SetField<float>(VT_V2V_LIMIT_FLAG, _V2V_limit_flag, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_COUNT) &&
           VerifyField<uint32_t>(verifier, VT_PATH_ID) &&
           VerifyField<int32_t>(verifier, VT_KEY_OBSTACLE) &&
           VerifyField<uint64_t>(verifier, VT_RECORD_TIME) &&
           VerifyField<uint8_t>(verifier, VT_IS_IMPACT) &&
           VerifyField<uint8_t>(verifier, VT_IS_EXPAND_IMPACT_RESULT) &&
           VerifyField<float>(verifier, VT_Y_V2VCAR) &&
           VerifyField<float>(verifier, VT_X_V2VCAR) &&
           VerifyField<float>(verifier, VT_X_CENTER) &&
           VerifyField<float>(verifier, VT_Y_CENTER) &&
           VerifyField<float>(verifier, VT_WIDTH_V2VCAR) &&
           VerifyField<float>(verifier, VT_HEIGHT_V2VCAR) &&
           VerifyField<prediction::Pointcar>(verifier, VT_P_CONER) &&
           VerifyField<uint32_t>(verifier, VT_HUICHE_FLAG) &&
           VerifyField<prediction::Pointcar>(verifier, VT_POINT_CAR) &&
           VerifyField<float>(verifier, VT_DIS_PATH) &&
           VerifyField<float>(verifier, VT_V2I_STOP_X) &&
           VerifyField<float>(verifier, VT_V2I_STOP_Y) &&
           VerifyField<float>(verifier, VT_Y_LIMIT) &&
           VerifyField<float>(verifier, VT_X_LIMIT) &&
           VerifyField<float>(verifier, VT_WIDTH_LIMIT) &&
           VerifyField<float>(verifier, VT_V2V_LIMIT_FLAG) &&
           verifier.EndTable();
  }
  DataRecord_v2iT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DataRecord_v2iT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DataRecord_v2i> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DataRecord_v2iT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DataRecord_v2iBuilder {
  typedef DataRecord_v2i Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_count(uint32_t count) {
    fbb_.AddElement<uint32_t>(DataRecord_v2i::VT_COUNT, count, 0);
  }
  void add_path_id(uint32_t path_id) {
    fbb_.AddElement<uint32_t>(DataRecord_v2i::VT_PATH_ID, path_id, 0);
  }
  void add_key_obstacle(int32_t key_obstacle) {
    fbb_.AddElement<int32_t>(DataRecord_v2i::VT_KEY_OBSTACLE, key_obstacle, 0);
  }
  void add_record_time(uint64_t record_time) {
    fbb_.AddElement<uint64_t>(DataRecord_v2i::VT_RECORD_TIME, record_time, 0);
  }
  void add_is_impact(bool is_impact) {
    fbb_.AddElement<uint8_t>(DataRecord_v2i::VT_IS_IMPACT, static_cast<uint8_t>(is_impact), 0);
  }
  void add_is_expand_impact_result(bool is_expand_impact_result) {
    fbb_.AddElement<uint8_t>(DataRecord_v2i::VT_IS_EXPAND_IMPACT_RESULT, static_cast<uint8_t>(is_expand_impact_result), 0);
  }
  void add_y_V2Vcar(float y_V2Vcar) {
    fbb_.AddElement<float>(DataRecord_v2i::VT_Y_V2VCAR, y_V2Vcar, 0.0f);
  }
  void add_x_V2Vcar(float x_V2Vcar) {
    fbb_.AddElement<float>(DataRecord_v2i::VT_X_V2VCAR, x_V2Vcar, 0.0f);
  }
  void add_x_center(float x_center) {
    fbb_.AddElement<float>(DataRecord_v2i::VT_X_CENTER, x_center, 0.0f);
  }
  void add_y_center(float y_center) {
    fbb_.AddElement<float>(DataRecord_v2i::VT_Y_CENTER, y_center, 0.0f);
  }
  void add_width_V2Vcar(float width_V2Vcar) {
    fbb_.AddElement<float>(DataRecord_v2i::VT_WIDTH_V2VCAR, width_V2Vcar, 0.0f);
  }
  void add_height_V2Vcar(float height_V2Vcar) {
    fbb_.AddElement<float>(DataRecord_v2i::VT_HEIGHT_V2VCAR, height_V2Vcar, 0.0f);
  }
  void add_p_coner(const prediction::Pointcar *p_coner) {
    fbb_.AddStruct(DataRecord_v2i::VT_P_CONER, p_coner);
  }
  void add_huiche_flag(uint32_t huiche_flag) {
    fbb_.AddElement<uint32_t>(DataRecord_v2i::VT_HUICHE_FLAG, huiche_flag, 0);
  }
  void add_point_car(const prediction::Pointcar *point_car) {
    fbb_.AddStruct(DataRecord_v2i::VT_POINT_CAR, point_car);
  }
  void add_dis_path(float dis_path) {
    fbb_.AddElement<float>(DataRecord_v2i::VT_DIS_PATH, dis_path, 0.0f);
  }
  void add_v2i_stop_x(float v2i_stop_x) {
    fbb_.AddElement<float>(DataRecord_v2i::VT_V2I_STOP_X, v2i_stop_x, 0.0f);
  }
  void add_v2i_stop_y(float v2i_stop_y) {
    fbb_.AddElement<float>(DataRecord_v2i::VT_V2I_STOP_Y, v2i_stop_y, 0.0f);
  }
  void add_y_limit(float y_limit) {
    fbb_.AddElement<float>(DataRecord_v2i::VT_Y_LIMIT, y_limit, 0.0f);
  }
  void add_x_limit(float x_limit) {
    fbb_.AddElement<float>(DataRecord_v2i::VT_X_LIMIT, x_limit, 0.0f);
  }
  void add_width_limit(float width_limit) {
    fbb_.AddElement<float>(DataRecord_v2i::VT_WIDTH_LIMIT, width_limit, 0.0f);
  }
  void add_V2V_limit_flag(float V2V_limit_flag) {
    fbb_.AddElement<float>(DataRecord_v2i::VT_V2V_LIMIT_FLAG, V2V_limit_flag, 0.0f);
  }
  explicit DataRecord_v2iBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DataRecord_v2i> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DataRecord_v2i>(end);
    return o;
  }
};

inline flatbuffers::Offset<DataRecord_v2i> CreateDataRecord_v2i(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t count = 0,
    uint32_t path_id = 0,
    int32_t key_obstacle = 0,
    uint64_t record_time = 0,
    bool is_impact = false,
    bool is_expand_impact_result = false,
    float y_V2Vcar = 0.0f,
    float x_V2Vcar = 0.0f,
    float x_center = 0.0f,
    float y_center = 0.0f,
    float width_V2Vcar = 0.0f,
    float height_V2Vcar = 0.0f,
    const prediction::Pointcar *p_coner = 0,
    uint32_t huiche_flag = 0,
    const prediction::Pointcar *point_car = 0,
    float dis_path = 0.0f,
    float v2i_stop_x = 0.0f,
    float v2i_stop_y = 0.0f,
    float y_limit = 0.0f,
    float x_limit = 0.0f,
    float width_limit = 0.0f,
    float V2V_limit_flag = 0.0f) {
  DataRecord_v2iBuilder builder_(_fbb);
  builder_.add_record_time(record_time);
  builder_.add_V2V_limit_flag(V2V_limit_flag);
  builder_.add_width_limit(width_limit);
  builder_.add_x_limit(x_limit);
  builder_.add_y_limit(y_limit);
  builder_.add_v2i_stop_y(v2i_stop_y);
  builder_.add_v2i_stop_x(v2i_stop_x);
  builder_.add_dis_path(dis_path);
  builder_.add_point_car(point_car);
  builder_.add_huiche_flag(huiche_flag);
  builder_.add_p_coner(p_coner);
  builder_.add_height_V2Vcar(height_V2Vcar);
  builder_.add_width_V2Vcar(width_V2Vcar);
  builder_.add_y_center(y_center);
  builder_.add_x_center(x_center);
  builder_.add_x_V2Vcar(x_V2Vcar);
  builder_.add_y_V2Vcar(y_V2Vcar);
  builder_.add_key_obstacle(key_obstacle);
  builder_.add_path_id(path_id);
  builder_.add_count(count);
  builder_.add_is_expand_impact_result(is_expand_impact_result);
  builder_.add_is_impact(is_impact);
  return builder_.Finish();
}

flatbuffers::Offset<DataRecord_v2i> CreateDataRecord_v2i(flatbuffers::FlatBufferBuilder &_fbb, const DataRecord_v2iT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SteerParaT : public flatbuffers::NativeTable {
  typedef SteerPara TableType;
  float X_center;
  float Y_center;
  float R_car_left;
  float R_car_right;
  float R_left_side;
  float R_right_side;
  float R_left_lane;
  float R_right_lane;
  SteerParaT()
      : X_center(0.0f),
        Y_center(0.0f),
        R_car_left(0.0f),
        R_car_right(0.0f),
        R_left_side(0.0f),
        R_right_side(0.0f),
        R_left_lane(0.0f),
        R_right_lane(0.0f) {
  }
};

inline bool operator==(const SteerParaT &lhs, const SteerParaT &rhs) {
  return
      (lhs.X_center == rhs.X_center) &&
      (lhs.Y_center == rhs.Y_center) &&
      (lhs.R_car_left == rhs.R_car_left) &&
      (lhs.R_car_right == rhs.R_car_right) &&
      (lhs.R_left_side == rhs.R_left_side) &&
      (lhs.R_right_side == rhs.R_right_side) &&
      (lhs.R_left_lane == rhs.R_left_lane) &&
      (lhs.R_right_lane == rhs.R_right_lane);
}

inline bool operator!=(const SteerParaT &lhs, const SteerParaT &rhs) {
    return !(lhs == rhs);
}


struct SteerPara FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SteerParaT NativeTableType;
  typedef SteerParaBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SteerParaTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X_CENTER = 4,
    VT_Y_CENTER = 6,
    VT_R_CAR_LEFT = 8,
    VT_R_CAR_RIGHT = 10,
    VT_R_LEFT_SIDE = 12,
    VT_R_RIGHT_SIDE = 14,
    VT_R_LEFT_LANE = 16,
    VT_R_RIGHT_LANE = 18
  };
  float X_center() const {
    return GetField<float>(VT_X_CENTER, 0.0f);
  }
  bool mutate_X_center(float _X_center) {
    return SetField<float>(VT_X_CENTER, _X_center, 0.0f);
  }
  float Y_center() const {
    return GetField<float>(VT_Y_CENTER, 0.0f);
  }
  bool mutate_Y_center(float _Y_center) {
    return SetField<float>(VT_Y_CENTER, _Y_center, 0.0f);
  }
  float R_car_left() const {
    return GetField<float>(VT_R_CAR_LEFT, 0.0f);
  }
  bool mutate_R_car_left(float _R_car_left) {
    return SetField<float>(VT_R_CAR_LEFT, _R_car_left, 0.0f);
  }
  float R_car_right() const {
    return GetField<float>(VT_R_CAR_RIGHT, 0.0f);
  }
  bool mutate_R_car_right(float _R_car_right) {
    return SetField<float>(VT_R_CAR_RIGHT, _R_car_right, 0.0f);
  }
  float R_left_side() const {
    return GetField<float>(VT_R_LEFT_SIDE, 0.0f);
  }
  bool mutate_R_left_side(float _R_left_side) {
    return SetField<float>(VT_R_LEFT_SIDE, _R_left_side, 0.0f);
  }
  float R_right_side() const {
    return GetField<float>(VT_R_RIGHT_SIDE, 0.0f);
  }
  bool mutate_R_right_side(float _R_right_side) {
    return SetField<float>(VT_R_RIGHT_SIDE, _R_right_side, 0.0f);
  }
  float R_left_lane() const {
    return GetField<float>(VT_R_LEFT_LANE, 0.0f);
  }
  bool mutate_R_left_lane(float _R_left_lane) {
    return SetField<float>(VT_R_LEFT_LANE, _R_left_lane, 0.0f);
  }
  float R_right_lane() const {
    return GetField<float>(VT_R_RIGHT_LANE, 0.0f);
  }
  bool mutate_R_right_lane(float _R_right_lane) {
    return SetField<float>(VT_R_RIGHT_LANE, _R_right_lane, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_X_CENTER) &&
           VerifyField<float>(verifier, VT_Y_CENTER) &&
           VerifyField<float>(verifier, VT_R_CAR_LEFT) &&
           VerifyField<float>(verifier, VT_R_CAR_RIGHT) &&
           VerifyField<float>(verifier, VT_R_LEFT_SIDE) &&
           VerifyField<float>(verifier, VT_R_RIGHT_SIDE) &&
           VerifyField<float>(verifier, VT_R_LEFT_LANE) &&
           VerifyField<float>(verifier, VT_R_RIGHT_LANE) &&
           verifier.EndTable();
  }
  SteerParaT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SteerParaT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SteerPara> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SteerParaT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SteerParaBuilder {
  typedef SteerPara Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_X_center(float X_center) {
    fbb_.AddElement<float>(SteerPara::VT_X_CENTER, X_center, 0.0f);
  }
  void add_Y_center(float Y_center) {
    fbb_.AddElement<float>(SteerPara::VT_Y_CENTER, Y_center, 0.0f);
  }
  void add_R_car_left(float R_car_left) {
    fbb_.AddElement<float>(SteerPara::VT_R_CAR_LEFT, R_car_left, 0.0f);
  }
  void add_R_car_right(float R_car_right) {
    fbb_.AddElement<float>(SteerPara::VT_R_CAR_RIGHT, R_car_right, 0.0f);
  }
  void add_R_left_side(float R_left_side) {
    fbb_.AddElement<float>(SteerPara::VT_R_LEFT_SIDE, R_left_side, 0.0f);
  }
  void add_R_right_side(float R_right_side) {
    fbb_.AddElement<float>(SteerPara::VT_R_RIGHT_SIDE, R_right_side, 0.0f);
  }
  void add_R_left_lane(float R_left_lane) {
    fbb_.AddElement<float>(SteerPara::VT_R_LEFT_LANE, R_left_lane, 0.0f);
  }
  void add_R_right_lane(float R_right_lane) {
    fbb_.AddElement<float>(SteerPara::VT_R_RIGHT_LANE, R_right_lane, 0.0f);
  }
  explicit SteerParaBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SteerPara> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SteerPara>(end);
    return o;
  }
};

inline flatbuffers::Offset<SteerPara> CreateSteerPara(
    flatbuffers::FlatBufferBuilder &_fbb,
    float X_center = 0.0f,
    float Y_center = 0.0f,
    float R_car_left = 0.0f,
    float R_car_right = 0.0f,
    float R_left_side = 0.0f,
    float R_right_side = 0.0f,
    float R_left_lane = 0.0f,
    float R_right_lane = 0.0f) {
  SteerParaBuilder builder_(_fbb);
  builder_.add_R_right_lane(R_right_lane);
  builder_.add_R_left_lane(R_left_lane);
  builder_.add_R_right_side(R_right_side);
  builder_.add_R_left_side(R_left_side);
  builder_.add_R_car_right(R_car_right);
  builder_.add_R_car_left(R_car_left);
  builder_.add_Y_center(Y_center);
  builder_.add_X_center(X_center);
  return builder_.Finish();
}

flatbuffers::Offset<SteerPara> CreateSteerPara(flatbuffers::FlatBufferBuilder &_fbb, const SteerParaT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LidardisT : public flatbuffers::NativeTable {
  typedef Lidardis TableType;
  float front;
  float back_y;
  float back_x;
  float back_wall_heading_Projectionlength;
  float right_lane;
  float y_limit;
  float x_limit;
  float width_limit;
  float x_stop;
  float dis_path;
  float impact_point_x;
  float impact_point_y;
  uint32_t object_stop_flag;
  uint32_t V2V_limit_flag;
  float width_stop;
  uint32_t isin_path;
  uint32_t impact_load_id;
  LidardisT()
      : front(0.0f),
        back_y(0.0f),
        back_x(0.0f),
        back_wall_heading_Projectionlength(0.0f),
        right_lane(0.0f),
        y_limit(0.0f),
        x_limit(0.0f),
        width_limit(0.0f),
        x_stop(0.0f),
        dis_path(0.0f),
        impact_point_x(0.0f),
        impact_point_y(0.0f),
        object_stop_flag(0),
        V2V_limit_flag(0),
        width_stop(0.0f),
        isin_path(0),
        impact_load_id(0) {
  }
};

inline bool operator==(const LidardisT &lhs, const LidardisT &rhs) {
  return
      (lhs.front == rhs.front) &&
      (lhs.back_y == rhs.back_y) &&
      (lhs.back_x == rhs.back_x) &&
      (lhs.back_wall_heading_Projectionlength == rhs.back_wall_heading_Projectionlength) &&
      (lhs.right_lane == rhs.right_lane) &&
      (lhs.y_limit == rhs.y_limit) &&
      (lhs.x_limit == rhs.x_limit) &&
      (lhs.width_limit == rhs.width_limit) &&
      (lhs.x_stop == rhs.x_stop) &&
      (lhs.dis_path == rhs.dis_path) &&
      (lhs.impact_point_x == rhs.impact_point_x) &&
      (lhs.impact_point_y == rhs.impact_point_y) &&
      (lhs.object_stop_flag == rhs.object_stop_flag) &&
      (lhs.V2V_limit_flag == rhs.V2V_limit_flag) &&
      (lhs.width_stop == rhs.width_stop) &&
      (lhs.isin_path == rhs.isin_path) &&
      (lhs.impact_load_id == rhs.impact_load_id);
}

inline bool operator!=(const LidardisT &lhs, const LidardisT &rhs) {
    return !(lhs == rhs);
}


struct Lidardis FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LidardisT NativeTableType;
  typedef LidardisBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LidardisTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FRONT = 4,
    VT_BACK_Y = 6,
    VT_BACK_X = 8,
    VT_BACK_WALL_HEADING_PROJECTIONLENGTH = 10,
    VT_RIGHT_LANE = 12,
    VT_Y_LIMIT = 14,
    VT_X_LIMIT = 16,
    VT_WIDTH_LIMIT = 18,
    VT_X_STOP = 20,
    VT_DIS_PATH = 22,
    VT_IMPACT_POINT_X = 24,
    VT_IMPACT_POINT_Y = 26,
    VT_OBJECT_STOP_FLAG = 28,
    VT_V2V_LIMIT_FLAG = 30,
    VT_WIDTH_STOP = 32,
    VT_ISIN_PATH = 34,
    VT_IMPACT_LOAD_ID = 36
  };
  float front() const {
    return GetField<float>(VT_FRONT, 0.0f);
  }
  bool mutate_front(float _front) {
    return SetField<float>(VT_FRONT, _front, 0.0f);
  }
  float back_y() const {
    return GetField<float>(VT_BACK_Y, 0.0f);
  }
  bool mutate_back_y(float _back_y) {
    return SetField<float>(VT_BACK_Y, _back_y, 0.0f);
  }
  float back_x() const {
    return GetField<float>(VT_BACK_X, 0.0f);
  }
  bool mutate_back_x(float _back_x) {
    return SetField<float>(VT_BACK_X, _back_x, 0.0f);
  }
  float back_wall_heading_Projectionlength() const {
    return GetField<float>(VT_BACK_WALL_HEADING_PROJECTIONLENGTH, 0.0f);
  }
  bool mutate_back_wall_heading_Projectionlength(float _back_wall_heading_Projectionlength) {
    return SetField<float>(VT_BACK_WALL_HEADING_PROJECTIONLENGTH, _back_wall_heading_Projectionlength, 0.0f);
  }
  float right_lane() const {
    return GetField<float>(VT_RIGHT_LANE, 0.0f);
  }
  bool mutate_right_lane(float _right_lane) {
    return SetField<float>(VT_RIGHT_LANE, _right_lane, 0.0f);
  }
  float y_limit() const {
    return GetField<float>(VT_Y_LIMIT, 0.0f);
  }
  bool mutate_y_limit(float _y_limit) {
    return SetField<float>(VT_Y_LIMIT, _y_limit, 0.0f);
  }
  float x_limit() const {
    return GetField<float>(VT_X_LIMIT, 0.0f);
  }
  bool mutate_x_limit(float _x_limit) {
    return SetField<float>(VT_X_LIMIT, _x_limit, 0.0f);
  }
  float width_limit() const {
    return GetField<float>(VT_WIDTH_LIMIT, 0.0f);
  }
  bool mutate_width_limit(float _width_limit) {
    return SetField<float>(VT_WIDTH_LIMIT, _width_limit, 0.0f);
  }
  float x_stop() const {
    return GetField<float>(VT_X_STOP, 0.0f);
  }
  bool mutate_x_stop(float _x_stop) {
    return SetField<float>(VT_X_STOP, _x_stop, 0.0f);
  }
  float dis_path() const {
    return GetField<float>(VT_DIS_PATH, 0.0f);
  }
  bool mutate_dis_path(float _dis_path) {
    return SetField<float>(VT_DIS_PATH, _dis_path, 0.0f);
  }
  float impact_point_x() const {
    return GetField<float>(VT_IMPACT_POINT_X, 0.0f);
  }
  bool mutate_impact_point_x(float _impact_point_x) {
    return SetField<float>(VT_IMPACT_POINT_X, _impact_point_x, 0.0f);
  }
  float impact_point_y() const {
    return GetField<float>(VT_IMPACT_POINT_Y, 0.0f);
  }
  bool mutate_impact_point_y(float _impact_point_y) {
    return SetField<float>(VT_IMPACT_POINT_Y, _impact_point_y, 0.0f);
  }
  uint32_t object_stop_flag() const {
    return GetField<uint32_t>(VT_OBJECT_STOP_FLAG, 0);
  }
  bool mutate_object_stop_flag(uint32_t _object_stop_flag) {
    return SetField<uint32_t>(VT_OBJECT_STOP_FLAG, _object_stop_flag, 0);
  }
  uint32_t V2V_limit_flag() const {
    return GetField<uint32_t>(VT_V2V_LIMIT_FLAG, 0);
  }
  bool mutate_V2V_limit_flag(uint32_t _V2V_limit_flag) {
    return SetField<uint32_t>(VT_V2V_LIMIT_FLAG, _V2V_limit_flag, 0);
  }
  float width_stop() const {
    return GetField<float>(VT_WIDTH_STOP, 0.0f);
  }
  bool mutate_width_stop(float _width_stop) {
    return SetField<float>(VT_WIDTH_STOP, _width_stop, 0.0f);
  }
  uint32_t isin_path() const {
    return GetField<uint32_t>(VT_ISIN_PATH, 0);
  }
  bool mutate_isin_path(uint32_t _isin_path) {
    return SetField<uint32_t>(VT_ISIN_PATH, _isin_path, 0);
  }
  uint32_t impact_load_id() const {
    return GetField<uint32_t>(VT_IMPACT_LOAD_ID, 0);
  }
  bool mutate_impact_load_id(uint32_t _impact_load_id) {
    return SetField<uint32_t>(VT_IMPACT_LOAD_ID, _impact_load_id, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_FRONT) &&
           VerifyField<float>(verifier, VT_BACK_Y) &&
           VerifyField<float>(verifier, VT_BACK_X) &&
           VerifyField<float>(verifier, VT_BACK_WALL_HEADING_PROJECTIONLENGTH) &&
           VerifyField<float>(verifier, VT_RIGHT_LANE) &&
           VerifyField<float>(verifier, VT_Y_LIMIT) &&
           VerifyField<float>(verifier, VT_X_LIMIT) &&
           VerifyField<float>(verifier, VT_WIDTH_LIMIT) &&
           VerifyField<float>(verifier, VT_X_STOP) &&
           VerifyField<float>(verifier, VT_DIS_PATH) &&
           VerifyField<float>(verifier, VT_IMPACT_POINT_X) &&
           VerifyField<float>(verifier, VT_IMPACT_POINT_Y) &&
           VerifyField<uint32_t>(verifier, VT_OBJECT_STOP_FLAG) &&
           VerifyField<uint32_t>(verifier, VT_V2V_LIMIT_FLAG) &&
           VerifyField<float>(verifier, VT_WIDTH_STOP) &&
           VerifyField<uint32_t>(verifier, VT_ISIN_PATH) &&
           VerifyField<uint32_t>(verifier, VT_IMPACT_LOAD_ID) &&
           verifier.EndTable();
  }
  LidardisT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LidardisT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Lidardis> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LidardisT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LidardisBuilder {
  typedef Lidardis Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_front(float front) {
    fbb_.AddElement<float>(Lidardis::VT_FRONT, front, 0.0f);
  }
  void add_back_y(float back_y) {
    fbb_.AddElement<float>(Lidardis::VT_BACK_Y, back_y, 0.0f);
  }
  void add_back_x(float back_x) {
    fbb_.AddElement<float>(Lidardis::VT_BACK_X, back_x, 0.0f);
  }
  void add_back_wall_heading_Projectionlength(float back_wall_heading_Projectionlength) {
    fbb_.AddElement<float>(Lidardis::VT_BACK_WALL_HEADING_PROJECTIONLENGTH, back_wall_heading_Projectionlength, 0.0f);
  }
  void add_right_lane(float right_lane) {
    fbb_.AddElement<float>(Lidardis::VT_RIGHT_LANE, right_lane, 0.0f);
  }
  void add_y_limit(float y_limit) {
    fbb_.AddElement<float>(Lidardis::VT_Y_LIMIT, y_limit, 0.0f);
  }
  void add_x_limit(float x_limit) {
    fbb_.AddElement<float>(Lidardis::VT_X_LIMIT, x_limit, 0.0f);
  }
  void add_width_limit(float width_limit) {
    fbb_.AddElement<float>(Lidardis::VT_WIDTH_LIMIT, width_limit, 0.0f);
  }
  void add_x_stop(float x_stop) {
    fbb_.AddElement<float>(Lidardis::VT_X_STOP, x_stop, 0.0f);
  }
  void add_dis_path(float dis_path) {
    fbb_.AddElement<float>(Lidardis::VT_DIS_PATH, dis_path, 0.0f);
  }
  void add_impact_point_x(float impact_point_x) {
    fbb_.AddElement<float>(Lidardis::VT_IMPACT_POINT_X, impact_point_x, 0.0f);
  }
  void add_impact_point_y(float impact_point_y) {
    fbb_.AddElement<float>(Lidardis::VT_IMPACT_POINT_Y, impact_point_y, 0.0f);
  }
  void add_object_stop_flag(uint32_t object_stop_flag) {
    fbb_.AddElement<uint32_t>(Lidardis::VT_OBJECT_STOP_FLAG, object_stop_flag, 0);
  }
  void add_V2V_limit_flag(uint32_t V2V_limit_flag) {
    fbb_.AddElement<uint32_t>(Lidardis::VT_V2V_LIMIT_FLAG, V2V_limit_flag, 0);
  }
  void add_width_stop(float width_stop) {
    fbb_.AddElement<float>(Lidardis::VT_WIDTH_STOP, width_stop, 0.0f);
  }
  void add_isin_path(uint32_t isin_path) {
    fbb_.AddElement<uint32_t>(Lidardis::VT_ISIN_PATH, isin_path, 0);
  }
  void add_impact_load_id(uint32_t impact_load_id) {
    fbb_.AddElement<uint32_t>(Lidardis::VT_IMPACT_LOAD_ID, impact_load_id, 0);
  }
  explicit LidardisBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Lidardis> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Lidardis>(end);
    return o;
  }
};

inline flatbuffers::Offset<Lidardis> CreateLidardis(
    flatbuffers::FlatBufferBuilder &_fbb,
    float front = 0.0f,
    float back_y = 0.0f,
    float back_x = 0.0f,
    float back_wall_heading_Projectionlength = 0.0f,
    float right_lane = 0.0f,
    float y_limit = 0.0f,
    float x_limit = 0.0f,
    float width_limit = 0.0f,
    float x_stop = 0.0f,
    float dis_path = 0.0f,
    float impact_point_x = 0.0f,
    float impact_point_y = 0.0f,
    uint32_t object_stop_flag = 0,
    uint32_t V2V_limit_flag = 0,
    float width_stop = 0.0f,
    uint32_t isin_path = 0,
    uint32_t impact_load_id = 0) {
  LidardisBuilder builder_(_fbb);
  builder_.add_impact_load_id(impact_load_id);
  builder_.add_isin_path(isin_path);
  builder_.add_width_stop(width_stop);
  builder_.add_V2V_limit_flag(V2V_limit_flag);
  builder_.add_object_stop_flag(object_stop_flag);
  builder_.add_impact_point_y(impact_point_y);
  builder_.add_impact_point_x(impact_point_x);
  builder_.add_dis_path(dis_path);
  builder_.add_x_stop(x_stop);
  builder_.add_width_limit(width_limit);
  builder_.add_x_limit(x_limit);
  builder_.add_y_limit(y_limit);
  builder_.add_right_lane(right_lane);
  builder_.add_back_wall_heading_Projectionlength(back_wall_heading_Projectionlength);
  builder_.add_back_x(back_x);
  builder_.add_back_y(back_y);
  builder_.add_front(front);
  return builder_.Finish();
}

flatbuffers::Offset<Lidardis> CreateLidardis(flatbuffers::FlatBufferBuilder &_fbb, const LidardisT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SenseResultInfoT : public flatbuffers::NativeTable {
  typedef SenseResultInfo TableType;
  std::unique_ptr<prediction::LidardisT> back_data;
  std::unique_ptr<prediction::LidardisT> lidar_front_data;
  std::unique_ptr<prediction::SteerParaT> steer_para;
  bool lidar_back_judge_result;
  SenseResultInfoT()
      : lidar_back_judge_result(false) {
  }
};

inline bool operator==(const SenseResultInfoT &lhs, const SenseResultInfoT &rhs) {
  return
      (lhs.back_data == rhs.back_data) &&
      (lhs.lidar_front_data == rhs.lidar_front_data) &&
      (lhs.steer_para == rhs.steer_para) &&
      (lhs.lidar_back_judge_result == rhs.lidar_back_judge_result);
}

inline bool operator!=(const SenseResultInfoT &lhs, const SenseResultInfoT &rhs) {
    return !(lhs == rhs);
}


struct SenseResultInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SenseResultInfoT NativeTableType;
  typedef SenseResultInfoBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SenseResultInfoTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BACK_DATA = 4,
    VT_LIDAR_FRONT_DATA = 6,
    VT_STEER_PARA = 8,
    VT_LIDAR_BACK_JUDGE_RESULT = 10
  };
  const prediction::Lidardis *back_data() const {
    return GetPointer<const prediction::Lidardis *>(VT_BACK_DATA);
  }
  prediction::Lidardis *mutable_back_data() {
    return GetPointer<prediction::Lidardis *>(VT_BACK_DATA);
  }
  const prediction::Lidardis *lidar_front_data() const {
    return GetPointer<const prediction::Lidardis *>(VT_LIDAR_FRONT_DATA);
  }
  prediction::Lidardis *mutable_lidar_front_data() {
    return GetPointer<prediction::Lidardis *>(VT_LIDAR_FRONT_DATA);
  }
  const prediction::SteerPara *steer_para() const {
    return GetPointer<const prediction::SteerPara *>(VT_STEER_PARA);
  }
  prediction::SteerPara *mutable_steer_para() {
    return GetPointer<prediction::SteerPara *>(VT_STEER_PARA);
  }
  bool lidar_back_judge_result() const {
    return GetField<uint8_t>(VT_LIDAR_BACK_JUDGE_RESULT, 0) != 0;
  }
  bool mutate_lidar_back_judge_result(bool _lidar_back_judge_result) {
    return SetField<uint8_t>(VT_LIDAR_BACK_JUDGE_RESULT, static_cast<uint8_t>(_lidar_back_judge_result), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BACK_DATA) &&
           verifier.VerifyTable(back_data()) &&
           VerifyOffset(verifier, VT_LIDAR_FRONT_DATA) &&
           verifier.VerifyTable(lidar_front_data()) &&
           VerifyOffset(verifier, VT_STEER_PARA) &&
           verifier.VerifyTable(steer_para()) &&
           VerifyField<uint8_t>(verifier, VT_LIDAR_BACK_JUDGE_RESULT) &&
           verifier.EndTable();
  }
  SenseResultInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SenseResultInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SenseResultInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SenseResultInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SenseResultInfoBuilder {
  typedef SenseResultInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_back_data(flatbuffers::Offset<prediction::Lidardis> back_data) {
    fbb_.AddOffset(SenseResultInfo::VT_BACK_DATA, back_data);
  }
  void add_lidar_front_data(flatbuffers::Offset<prediction::Lidardis> lidar_front_data) {
    fbb_.AddOffset(SenseResultInfo::VT_LIDAR_FRONT_DATA, lidar_front_data);
  }
  void add_steer_para(flatbuffers::Offset<prediction::SteerPara> steer_para) {
    fbb_.AddOffset(SenseResultInfo::VT_STEER_PARA, steer_para);
  }
  void add_lidar_back_judge_result(bool lidar_back_judge_result) {
    fbb_.AddElement<uint8_t>(SenseResultInfo::VT_LIDAR_BACK_JUDGE_RESULT, static_cast<uint8_t>(lidar_back_judge_result), 0);
  }
  explicit SenseResultInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SenseResultInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SenseResultInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<SenseResultInfo> CreateSenseResultInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<prediction::Lidardis> back_data = 0,
    flatbuffers::Offset<prediction::Lidardis> lidar_front_data = 0,
    flatbuffers::Offset<prediction::SteerPara> steer_para = 0,
    bool lidar_back_judge_result = false) {
  SenseResultInfoBuilder builder_(_fbb);
  builder_.add_steer_para(steer_para);
  builder_.add_lidar_front_data(lidar_front_data);
  builder_.add_back_data(back_data);
  builder_.add_lidar_back_judge_result(lidar_back_judge_result);
  return builder_.Finish();
}

flatbuffers::Offset<SenseResultInfo> CreateSenseResultInfo(flatbuffers::FlatBufferBuilder &_fbb, const SenseResultInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline LidarSickInfoT *LidarSickInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<prediction::LidarSickInfoT> _o = std::unique_ptr<prediction::LidarSickInfoT>(new LidarSickInfoT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LidarSickInfo::UnPackTo(LidarSickInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = Time(); _o->Time = _e; }
  { auto _e = object_number(); _o->object_number = _e; }
  { auto _e = object_type(); _o->object_type = _e; }
  { auto _e = detection_type(); _o->detection_type = _e; }
  { auto _e = object_dist_long(); _o->object_dist_long = _e; }
  { auto _e = object_dist_lat(); _o->object_dist_lat = _e; }
  { auto _e = object_length(); _o->object_length = _e; }
  { auto _e = object_width(); _o->object_width = _e; }
  { auto _e = object_height(); _o->object_height = _e; }
  { auto _e = object_head(); _o->object_head = _e; }
  { auto _e = object_vrel_long(); _o->object_vrel_long = _e; }
  { auto _e = object_vrel_lat(); _o->object_vrel_lat = _e; }
  { auto _e = object_min_long(); _o->object_min_long = _e; }
  { auto _e = stop_flag(); _o->stop_flag = _e; }
}

inline flatbuffers::Offset<LidarSickInfo> LidarSickInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LidarSickInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLidarSickInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LidarSickInfo> CreateLidarSickInfo(flatbuffers::FlatBufferBuilder &_fbb, const LidarSickInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LidarSickInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _Time = _o->Time;
  auto _object_number = _o->object_number;
  auto _object_type = _o->object_type;
  auto _detection_type = _o->detection_type;
  auto _object_dist_long = _o->object_dist_long;
  auto _object_dist_lat = _o->object_dist_lat;
  auto _object_length = _o->object_length;
  auto _object_width = _o->object_width;
  auto _object_height = _o->object_height;
  auto _object_head = _o->object_head;
  auto _object_vrel_long = _o->object_vrel_long;
  auto _object_vrel_lat = _o->object_vrel_lat;
  auto _object_min_long = _o->object_min_long;
  auto _stop_flag = _o->stop_flag;
  return prediction::CreateLidarSickInfo(
      _fbb,
      _Time,
      _object_number,
      _object_type,
      _detection_type,
      _object_dist_long,
      _object_dist_lat,
      _object_length,
      _object_width,
      _object_height,
      _object_head,
      _object_vrel_long,
      _object_vrel_lat,
      _object_min_long,
      _stop_flag);
}

inline DataRecord_fuseT *DataRecord_fuse::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<prediction::DataRecord_fuseT> _o = std::unique_ptr<prediction::DataRecord_fuseT>(new DataRecord_fuseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DataRecord_fuse::UnPackTo(DataRecord_fuseT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = count(); _o->count = _e; }
  { auto _e = Time(); _o->Time = _e; }
  { auto _e = record_time(); _o->record_time = _e; }
  { auto _e = path_flag(); _o->path_flag = _e; }
  { auto _e = path_id(); _o->path_id = _e; }
  { auto _e = key_obstacle(); _o->key_obstacle = _e; }
  { auto _e = object_couter(); _o->object_couter = _e; }
  { auto _e = is_impact(); _o->is_impact = _e; }
  { auto _e = object_type(); _o->object_type = _e; }
  { auto _e = detection_type(); _o->detection_type = _e; }
  { auto _e = object_dist_long(); _o->object_dist_long = _e; }
  { auto _e = object_dist_lat(); _o->object_dist_lat = _e; }
  { auto _e = object_length(); _o->object_length = _e; }
  { auto _e = object_width(); _o->object_width = _e; }
  { auto _e = object_height(); _o->object_height = _e; }
  { auto _e = object_head(); _o->object_head = _e; }
  { auto _e = object_vrel_long(); _o->object_vrel_long = _e; }
  { auto _e = object_vrel_lat(); _o->object_vrel_lat = _e; }
  { auto _e = p_corner(); if (_e) _o->p_corner = std::unique_ptr<prediction::Points>(new prediction::Points(*_e)); }
  { auto _e = object_min_long(); _o->object_min_long = _e; }
  { auto _e = stop_flag(); _o->stop_flag = _e; }
  { auto _e = front_x(); _o->front_x = _e; }
  { auto _e = front_y(); _o->front_y = _e; }
  { auto _e = path_dis(); _o->path_dis = _e; }
  { auto _e = bia_dis(); _o->bia_dis = _e; }
  { auto _e = cur_max(); _o->cur_max = _e; }
  { auto _e = point_car(); if (_e) _o->point_car = std::unique_ptr<prediction::Pointcar>(new prediction::Pointcar(*_e)); }
  { auto _e = min_impact_point(); _o->min_impact_point = _e; }
  { auto _e = wall_count(); _o->wall_count = _e; }
  { auto _e = point_wall(); if (_e) _o->point_wall = std::unique_ptr<prediction::Pointwall>(new prediction::Pointwall(*_e)); }
  { auto _e = wall_y(); _o->wall_y = _e; }
  { auto _e = wall_x(); _o->wall_x = _e; }
  { auto _e = point_wall_left(); if (_e) _o->point_wall_left = std::unique_ptr<prediction::Pointwall>(new prediction::Pointwall(*_e)); }
}

inline flatbuffers::Offset<DataRecord_fuse> DataRecord_fuse::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DataRecord_fuseT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDataRecord_fuse(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DataRecord_fuse> CreateDataRecord_fuse(flatbuffers::FlatBufferBuilder &_fbb, const DataRecord_fuseT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DataRecord_fuseT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _count = _o->count;
  auto _Time = _o->Time;
  auto _record_time = _o->record_time;
  auto _path_flag = _o->path_flag;
  auto _path_id = _o->path_id;
  auto _key_obstacle = _o->key_obstacle;
  auto _object_couter = _o->object_couter;
  auto _is_impact = _o->is_impact;
  auto _object_type = _o->object_type;
  auto _detection_type = _o->detection_type;
  auto _object_dist_long = _o->object_dist_long;
  auto _object_dist_lat = _o->object_dist_lat;
  auto _object_length = _o->object_length;
  auto _object_width = _o->object_width;
  auto _object_height = _o->object_height;
  auto _object_head = _o->object_head;
  auto _object_vrel_long = _o->object_vrel_long;
  auto _object_vrel_lat = _o->object_vrel_lat;
  auto _p_corner = _o->p_corner ? _o->p_corner.get() : 0;
  auto _object_min_long = _o->object_min_long;
  auto _stop_flag = _o->stop_flag;
  auto _front_x = _o->front_x;
  auto _front_y = _o->front_y;
  auto _path_dis = _o->path_dis;
  auto _bia_dis = _o->bia_dis;
  auto _cur_max = _o->cur_max;
  auto _point_car = _o->point_car ? _o->point_car.get() : 0;
  auto _min_impact_point = _o->min_impact_point;
  auto _wall_count = _o->wall_count;
  auto _point_wall = _o->point_wall ? _o->point_wall.get() : 0;
  auto _wall_y = _o->wall_y;
  auto _wall_x = _o->wall_x;
  auto _point_wall_left = _o->point_wall_left ? _o->point_wall_left.get() : 0;
  return prediction::CreateDataRecord_fuse(
      _fbb,
      _count,
      _Time,
      _record_time,
      _path_flag,
      _path_id,
      _key_obstacle,
      _object_couter,
      _is_impact,
      _object_type,
      _detection_type,
      _object_dist_long,
      _object_dist_lat,
      _object_length,
      _object_width,
      _object_height,
      _object_head,
      _object_vrel_long,
      _object_vrel_lat,
      _p_corner,
      _object_min_long,
      _stop_flag,
      _front_x,
      _front_y,
      _path_dis,
      _bia_dis,
      _cur_max,
      _point_car,
      _min_impact_point,
      _wall_count,
      _point_wall,
      _wall_y,
      _wall_x,
      _point_wall_left);
}

inline DataRecord_v2iT *DataRecord_v2i::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<prediction::DataRecord_v2iT> _o = std::unique_ptr<prediction::DataRecord_v2iT>(new DataRecord_v2iT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DataRecord_v2i::UnPackTo(DataRecord_v2iT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = count(); _o->count = _e; }
  { auto _e = path_id(); _o->path_id = _e; }
  { auto _e = key_obstacle(); _o->key_obstacle = _e; }
  { auto _e = record_time(); _o->record_time = _e; }
  { auto _e = is_impact(); _o->is_impact = _e; }
  { auto _e = is_expand_impact_result(); _o->is_expand_impact_result = _e; }
  { auto _e = y_V2Vcar(); _o->y_V2Vcar = _e; }
  { auto _e = x_V2Vcar(); _o->x_V2Vcar = _e; }
  { auto _e = x_center(); _o->x_center = _e; }
  { auto _e = y_center(); _o->y_center = _e; }
  { auto _e = width_V2Vcar(); _o->width_V2Vcar = _e; }
  { auto _e = height_V2Vcar(); _o->height_V2Vcar = _e; }
  { auto _e = p_coner(); if (_e) _o->p_coner = std::unique_ptr<prediction::Pointcar>(new prediction::Pointcar(*_e)); }
  { auto _e = huiche_flag(); _o->huiche_flag = _e; }
  { auto _e = point_car(); if (_e) _o->point_car = std::unique_ptr<prediction::Pointcar>(new prediction::Pointcar(*_e)); }
  { auto _e = dis_path(); _o->dis_path = _e; }
  { auto _e = v2i_stop_x(); _o->v2i_stop_x = _e; }
  { auto _e = v2i_stop_y(); _o->v2i_stop_y = _e; }
  { auto _e = y_limit(); _o->y_limit = _e; }
  { auto _e = x_limit(); _o->x_limit = _e; }
  { auto _e = width_limit(); _o->width_limit = _e; }
  { auto _e = V2V_limit_flag(); _o->V2V_limit_flag = _e; }
}

inline flatbuffers::Offset<DataRecord_v2i> DataRecord_v2i::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DataRecord_v2iT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDataRecord_v2i(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DataRecord_v2i> CreateDataRecord_v2i(flatbuffers::FlatBufferBuilder &_fbb, const DataRecord_v2iT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DataRecord_v2iT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _count = _o->count;
  auto _path_id = _o->path_id;
  auto _key_obstacle = _o->key_obstacle;
  auto _record_time = _o->record_time;
  auto _is_impact = _o->is_impact;
  auto _is_expand_impact_result = _o->is_expand_impact_result;
  auto _y_V2Vcar = _o->y_V2Vcar;
  auto _x_V2Vcar = _o->x_V2Vcar;
  auto _x_center = _o->x_center;
  auto _y_center = _o->y_center;
  auto _width_V2Vcar = _o->width_V2Vcar;
  auto _height_V2Vcar = _o->height_V2Vcar;
  auto _p_coner = _o->p_coner ? _o->p_coner.get() : 0;
  auto _huiche_flag = _o->huiche_flag;
  auto _point_car = _o->point_car ? _o->point_car.get() : 0;
  auto _dis_path = _o->dis_path;
  auto _v2i_stop_x = _o->v2i_stop_x;
  auto _v2i_stop_y = _o->v2i_stop_y;
  auto _y_limit = _o->y_limit;
  auto _x_limit = _o->x_limit;
  auto _width_limit = _o->width_limit;
  auto _V2V_limit_flag = _o->V2V_limit_flag;
  return prediction::CreateDataRecord_v2i(
      _fbb,
      _count,
      _path_id,
      _key_obstacle,
      _record_time,
      _is_impact,
      _is_expand_impact_result,
      _y_V2Vcar,
      _x_V2Vcar,
      _x_center,
      _y_center,
      _width_V2Vcar,
      _height_V2Vcar,
      _p_coner,
      _huiche_flag,
      _point_car,
      _dis_path,
      _v2i_stop_x,
      _v2i_stop_y,
      _y_limit,
      _x_limit,
      _width_limit,
      _V2V_limit_flag);
}

inline SteerParaT *SteerPara::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<prediction::SteerParaT> _o = std::unique_ptr<prediction::SteerParaT>(new SteerParaT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SteerPara::UnPackTo(SteerParaT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = X_center(); _o->X_center = _e; }
  { auto _e = Y_center(); _o->Y_center = _e; }
  { auto _e = R_car_left(); _o->R_car_left = _e; }
  { auto _e = R_car_right(); _o->R_car_right = _e; }
  { auto _e = R_left_side(); _o->R_left_side = _e; }
  { auto _e = R_right_side(); _o->R_right_side = _e; }
  { auto _e = R_left_lane(); _o->R_left_lane = _e; }
  { auto _e = R_right_lane(); _o->R_right_lane = _e; }
}

inline flatbuffers::Offset<SteerPara> SteerPara::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SteerParaT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSteerPara(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SteerPara> CreateSteerPara(flatbuffers::FlatBufferBuilder &_fbb, const SteerParaT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SteerParaT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _X_center = _o->X_center;
  auto _Y_center = _o->Y_center;
  auto _R_car_left = _o->R_car_left;
  auto _R_car_right = _o->R_car_right;
  auto _R_left_side = _o->R_left_side;
  auto _R_right_side = _o->R_right_side;
  auto _R_left_lane = _o->R_left_lane;
  auto _R_right_lane = _o->R_right_lane;
  return prediction::CreateSteerPara(
      _fbb,
      _X_center,
      _Y_center,
      _R_car_left,
      _R_car_right,
      _R_left_side,
      _R_right_side,
      _R_left_lane,
      _R_right_lane);
}

inline LidardisT *Lidardis::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<prediction::LidardisT> _o = std::unique_ptr<prediction::LidardisT>(new LidardisT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Lidardis::UnPackTo(LidardisT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = front(); _o->front = _e; }
  { auto _e = back_y(); _o->back_y = _e; }
  { auto _e = back_x(); _o->back_x = _e; }
  { auto _e = back_wall_heading_Projectionlength(); _o->back_wall_heading_Projectionlength = _e; }
  { auto _e = right_lane(); _o->right_lane = _e; }
  { auto _e = y_limit(); _o->y_limit = _e; }
  { auto _e = x_limit(); _o->x_limit = _e; }
  { auto _e = width_limit(); _o->width_limit = _e; }
  { auto _e = x_stop(); _o->x_stop = _e; }
  { auto _e = dis_path(); _o->dis_path = _e; }
  { auto _e = impact_point_x(); _o->impact_point_x = _e; }
  { auto _e = impact_point_y(); _o->impact_point_y = _e; }
  { auto _e = object_stop_flag(); _o->object_stop_flag = _e; }
  { auto _e = V2V_limit_flag(); _o->V2V_limit_flag = _e; }
  { auto _e = width_stop(); _o->width_stop = _e; }
  { auto _e = isin_path(); _o->isin_path = _e; }
  { auto _e = impact_load_id(); _o->impact_load_id = _e; }
}

inline flatbuffers::Offset<Lidardis> Lidardis::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LidardisT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLidardis(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Lidardis> CreateLidardis(flatbuffers::FlatBufferBuilder &_fbb, const LidardisT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LidardisT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _front = _o->front;
  auto _back_y = _o->back_y;
  auto _back_x = _o->back_x;
  auto _back_wall_heading_Projectionlength = _o->back_wall_heading_Projectionlength;
  auto _right_lane = _o->right_lane;
  auto _y_limit = _o->y_limit;
  auto _x_limit = _o->x_limit;
  auto _width_limit = _o->width_limit;
  auto _x_stop = _o->x_stop;
  auto _dis_path = _o->dis_path;
  auto _impact_point_x = _o->impact_point_x;
  auto _impact_point_y = _o->impact_point_y;
  auto _object_stop_flag = _o->object_stop_flag;
  auto _V2V_limit_flag = _o->V2V_limit_flag;
  auto _width_stop = _o->width_stop;
  auto _isin_path = _o->isin_path;
  auto _impact_load_id = _o->impact_load_id;
  return prediction::CreateLidardis(
      _fbb,
      _front,
      _back_y,
      _back_x,
      _back_wall_heading_Projectionlength,
      _right_lane,
      _y_limit,
      _x_limit,
      _width_limit,
      _x_stop,
      _dis_path,
      _impact_point_x,
      _impact_point_y,
      _object_stop_flag,
      _V2V_limit_flag,
      _width_stop,
      _isin_path,
      _impact_load_id);
}

inline SenseResultInfoT *SenseResultInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<prediction::SenseResultInfoT> _o = std::unique_ptr<prediction::SenseResultInfoT>(new SenseResultInfoT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SenseResultInfo::UnPackTo(SenseResultInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = back_data(); if (_e) _o->back_data = std::unique_ptr<prediction::LidardisT>(_e->UnPack(_resolver)); }
  { auto _e = lidar_front_data(); if (_e) _o->lidar_front_data = std::unique_ptr<prediction::LidardisT>(_e->UnPack(_resolver)); }
  { auto _e = steer_para(); if (_e) _o->steer_para = std::unique_ptr<prediction::SteerParaT>(_e->UnPack(_resolver)); }
  { auto _e = lidar_back_judge_result(); _o->lidar_back_judge_result = _e; }
}

inline flatbuffers::Offset<SenseResultInfo> SenseResultInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SenseResultInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSenseResultInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SenseResultInfo> CreateSenseResultInfo(flatbuffers::FlatBufferBuilder &_fbb, const SenseResultInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SenseResultInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _back_data = _o->back_data ? CreateLidardis(_fbb, _o->back_data.get(), _rehasher) : 0;
  auto _lidar_front_data = _o->lidar_front_data ? CreateLidardis(_fbb, _o->lidar_front_data.get(), _rehasher) : 0;
  auto _steer_para = _o->steer_para ? CreateSteerPara(_fbb, _o->steer_para.get(), _rehasher) : 0;
  auto _lidar_back_judge_result = _o->lidar_back_judge_result;
  return prediction::CreateSenseResultInfo(
      _fbb,
      _back_data,
      _lidar_front_data,
      _steer_para,
      _lidar_back_judge_result);
}

inline const flatbuffers::TypeTable *Point_xyTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 }
  };
  static const int64_t values[] = { 0, 8 };
  static const char * const names[] = {
    "xy"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_STRUCT, 1, type_codes, nullptr, values, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Point_xyzTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 }
  };
  static const int64_t values[] = { 0, 12 };
  static const char * const names[] = {
    "xyz"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_STRUCT, 1, type_codes, nullptr, values, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PointsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    prediction::Point_xyzTypeTable
  };
  static const int64_t values[] = { 0, 48 };
  static const char * const names[] = {
    "vertex"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_STRUCT, 1, type_codes, type_refs, values, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PointcarTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    prediction::Point_xyTypeTable
  };
  static const int64_t values[] = { 0, 32 };
  static const char * const names[] = {
    "vertex"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_STRUCT, 1, type_codes, type_refs, values, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PointwallTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    prediction::Point_xyTypeTable
  };
  static const int64_t values[] = { 0, 200 };
  static const char * const names[] = {
    "wall"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_STRUCT, 1, type_codes, type_refs, values, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LidarSickInfoTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const char * const names[] = {
    "Time",
    "object_number",
    "object_type",
    "detection_type",
    "object_dist_long",
    "object_dist_lat",
    "object_length",
    "object_width",
    "object_height",
    "object_head",
    "object_vrel_long",
    "object_vrel_lat",
    "object_min_long",
    "stop_flag"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 14, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DataRecord_fuseTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    prediction::PointsTypeTable,
    prediction::PointcarTypeTable,
    prediction::PointwallTypeTable
  };
  static const char * const names[] = {
    "count",
    "Time",
    "record_time",
    "path_flag",
    "path_id",
    "key_obstacle",
    "object_couter",
    "is_impact",
    "object_type",
    "detection_type",
    "object_dist_long",
    "object_dist_lat",
    "object_length",
    "object_width",
    "object_height",
    "object_head",
    "object_vrel_long",
    "object_vrel_lat",
    "p_corner",
    "object_min_long",
    "stop_flag",
    "front_x",
    "front_y",
    "path_dis",
    "bia_dis",
    "cur_max",
    "point_car",
    "min_impact_point",
    "wall_count",
    "point_wall",
    "wall_y",
    "wall_x",
    "point_wall_left"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 33, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DataRecord_v2iTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    prediction::PointcarTypeTable
  };
  static const char * const names[] = {
    "count",
    "path_id",
    "key_obstacle",
    "record_time",
    "is_impact",
    "is_expand_impact_result",
    "y_V2Vcar",
    "x_V2Vcar",
    "x_center",
    "y_center",
    "width_V2Vcar",
    "height_V2Vcar",
    "p_coner",
    "huiche_flag",
    "point_car",
    "dis_path",
    "v2i_stop_x",
    "v2i_stop_y",
    "y_limit",
    "x_limit",
    "width_limit",
    "V2V_limit_flag"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 22, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SteerParaTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "X_center",
    "Y_center",
    "R_car_left",
    "R_car_right",
    "R_left_side",
    "R_right_side",
    "R_left_lane",
    "R_right_lane"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 8, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LidardisTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 }
  };
  static const char * const names[] = {
    "front",
    "back_y",
    "back_x",
    "back_wall_heading_Projectionlength",
    "right_lane",
    "y_limit",
    "x_limit",
    "width_limit",
    "x_stop",
    "dis_path",
    "impact_point_x",
    "impact_point_y",
    "object_stop_flag",
    "V2V_limit_flag",
    "width_stop",
    "isin_path",
    "impact_load_id"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 17, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SenseResultInfoTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    prediction::LidardisTypeTable,
    prediction::SteerParaTypeTable
  };
  static const char * const names[] = {
    "back_data",
    "lidar_front_data",
    "steer_para",
    "lidar_back_judge_result"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const prediction::SenseResultInfo *GetSenseResultInfo(const void *buf) {
  return flatbuffers::GetRoot<prediction::SenseResultInfo>(buf);
}

inline const prediction::SenseResultInfo *GetSizePrefixedSenseResultInfo(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<prediction::SenseResultInfo>(buf);
}

inline SenseResultInfo *GetMutableSenseResultInfo(void *buf) {
  return flatbuffers::GetMutableRoot<SenseResultInfo>(buf);
}

inline const char *SenseResultInfoIdentifier() {
  return "PERO";
}

inline bool SenseResultInfoBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, SenseResultInfoIdentifier());
}

inline bool VerifySenseResultInfoBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<prediction::SenseResultInfo>(SenseResultInfoIdentifier());
}

inline bool VerifySizePrefixedSenseResultInfoBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<prediction::SenseResultInfo>(SenseResultInfoIdentifier());
}

inline void FinishSenseResultInfoBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<prediction::SenseResultInfo> root) {
  fbb.Finish(root, SenseResultInfoIdentifier());
}

inline void FinishSizePrefixedSenseResultInfoBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<prediction::SenseResultInfo> root) {
  fbb.FinishSizePrefixed(root, SenseResultInfoIdentifier());
}

inline std::unique_ptr<prediction::SenseResultInfoT> UnPackSenseResultInfo(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<prediction::SenseResultInfoT>(GetSenseResultInfo(buf)->UnPack(res));
}

inline std::unique_ptr<prediction::SenseResultInfoT> UnPackSizePrefixedSenseResultInfo(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<prediction::SenseResultInfoT>(GetSizePrefixedSenseResultInfo(buf)->UnPack(res));
}

}  // namespace prediction

#endif  // FLATBUFFERS_GENERATED_PREDICTION_PREDICTION_H_
