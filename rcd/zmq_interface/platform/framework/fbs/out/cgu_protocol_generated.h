// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CGUPROTOCOL_H_
#define FLATBUFFERS_GENERATED_CGUPROTOCOL_H_

#include "flatbuffers/flatbuffers.h"

struct Msg2050;
struct Msg2050Builder;
struct Msg2050T;

struct Msg8306;
struct Msg8306Builder;
struct Msg8306T;

struct Msg8F02;
struct Msg8F02Builder;
struct Msg8F02T;

struct Msg8401;
struct Msg8401Builder;
struct Msg8401T;

struct Msg8F0C;
struct Msg8F0CBuilder;
struct Msg8F0CT;

struct Msg8F0D;
struct Msg8F0DBuilder;
struct Msg8F0DT;

struct Msg8403;
struct Msg8403Builder;
struct Msg8403T;

struct MovementAuthority;
struct MovementAuthorityBuilder;
struct MovementAuthorityT;

struct Msg8F0F;
struct Msg8F0FBuilder;
struct Msg8F0FT;

struct Msg8F10;
struct Msg8F10Builder;
struct Msg8F10T;

struct Msg8C01;
struct Msg8C01Builder;
struct Msg8C01T;

struct Msg8F04;
struct Msg8F04Builder;
struct Msg8F04T;

struct Msg8F0A;
struct Msg8F0ABuilder;
struct Msg8F0AT;

struct WarningArray;

struct Msg8F09;
struct Msg8F09Builder;
struct Msg8F09T;

struct GroupStatusList;
struct GroupStatusListBuilder;
struct GroupStatusListT;

struct Msg8B01;
struct Msg8B01Builder;
struct Msg8B01T;

struct GroupStatusList_WaitInLine;
struct GroupStatusList_WaitInLineBuilder;
struct GroupStatusList_WaitInLineT;

struct Msg8B03;
struct Msg8B03Builder;
struct Msg8B03T;

struct Msg8307;
struct Msg8307Builder;
struct Msg8307T;

struct Msg8308;
struct Msg8308Builder;
struct Msg8308T;

struct Msg0F21;
struct Msg0F21Builder;
struct Msg0F21T;

struct Msg0503;
struct Msg0503Builder;
struct Msg0503T;

struct Msg8105;
struct Msg8105Builder;
struct Msg8105T;

struct Msg8B10;
struct Msg8B10Builder;
struct Msg8B10T;

struct Msg8B11;
struct Msg8B11Builder;
struct Msg8B11T;

struct Msg0F0B;
struct Msg0F0BBuilder;
struct Msg0F0BT;

struct MsgVector;
struct MsgVectorBuilder;
struct MsgVectorT;

struct MsgVoiceName;
struct MsgVoiceNameBuilder;
struct MsgVoiceNameT;

struct Msg1040;
struct Msg1040Builder;
struct Msg1040T;

struct Msg0305;
struct Msg0305Builder;
struct Msg0305T;

struct Msg8305_V2X;
struct Msg8305_V2XBuilder;
struct Msg8305_V2XT;

struct Msg8F0B;
struct Msg8F0BBuilder;
struct Msg8F0BT;

struct Msg0502;
struct Msg0502Builder;
struct Msg0502T;

struct Msg0F01;
struct Msg0F01Builder;
struct Msg0F01T;

struct apply_numberArray;

struct Msg0F0E;
struct Msg0F0EBuilder;
struct Msg0F0ET;

struct Msg0F1C;
struct Msg0F1CBuilder;
struct Msg0F1CT;

struct passwordArray;

struct Msg0F10;
struct Msg0F10Builder;
struct Msg0F10T;

struct Msg0F11;
struct Msg0F11Builder;
struct Msg0F11T;

struct MsgTx_0104;
struct MsgTx_0104Builder;
struct MsgTx_0104T;

struct MsgTx_0F03;
struct MsgTx_0F03Builder;
struct MsgTx_0F03T;

struct MsgTx_0F09;
struct MsgTx_0F09Builder;
struct MsgTx_0F09T;

struct MsgTx_8305;
struct MsgTx_8305Builder;
struct MsgTx_8305T;

struct MsgTx_8B02;
struct MsgTx_8B02Builder;
struct MsgTx_8B02T;

struct MsgTx_8B07_list;
struct MsgTx_8B07_listBuilder;
struct MsgTx_8B07_listT;

struct MsgTx_8B07;
struct MsgTx_8B07Builder;
struct MsgTx_8B07T;

struct MsgTx_8B08_list;
struct MsgTx_8B08_listBuilder;
struct MsgTx_8B08_listT;

struct MsgTx_8B08;
struct MsgTx_8B08Builder;
struct MsgTx_8B08T;

struct MsgTx_0002;
struct MsgTx_0002Builder;
struct MsgTx_0002T;

struct MsgCguVersion;
struct MsgCguVersionBuilder;
struct MsgCguVersionT;

struct MsgVechWarnStat;
struct MsgVechWarnStatBuilder;
struct MsgVechWarnStatT;

bool operator==(const Msg2050T &lhs, const Msg2050T &rhs);
bool operator!=(const Msg2050T &lhs, const Msg2050T &rhs);
bool operator==(const Msg8306T &lhs, const Msg8306T &rhs);
bool operator!=(const Msg8306T &lhs, const Msg8306T &rhs);
bool operator==(const Msg8F02T &lhs, const Msg8F02T &rhs);
bool operator!=(const Msg8F02T &lhs, const Msg8F02T &rhs);
bool operator==(const Msg8401T &lhs, const Msg8401T &rhs);
bool operator!=(const Msg8401T &lhs, const Msg8401T &rhs);
bool operator==(const Msg8F0CT &lhs, const Msg8F0CT &rhs);
bool operator!=(const Msg8F0CT &lhs, const Msg8F0CT &rhs);
bool operator==(const Msg8F0DT &lhs, const Msg8F0DT &rhs);
bool operator!=(const Msg8F0DT &lhs, const Msg8F0DT &rhs);
bool operator==(const Msg8403T &lhs, const Msg8403T &rhs);
bool operator!=(const Msg8403T &lhs, const Msg8403T &rhs);
bool operator==(const MovementAuthorityT &lhs, const MovementAuthorityT &rhs);
bool operator!=(const MovementAuthorityT &lhs, const MovementAuthorityT &rhs);
bool operator==(const Msg8F0FT &lhs, const Msg8F0FT &rhs);
bool operator!=(const Msg8F0FT &lhs, const Msg8F0FT &rhs);
bool operator==(const Msg8F10T &lhs, const Msg8F10T &rhs);
bool operator!=(const Msg8F10T &lhs, const Msg8F10T &rhs);
bool operator==(const Msg8C01T &lhs, const Msg8C01T &rhs);
bool operator!=(const Msg8C01T &lhs, const Msg8C01T &rhs);
bool operator==(const Msg8F04T &lhs, const Msg8F04T &rhs);
bool operator!=(const Msg8F04T &lhs, const Msg8F04T &rhs);
bool operator==(const Msg8F0AT &lhs, const Msg8F0AT &rhs);
bool operator!=(const Msg8F0AT &lhs, const Msg8F0AT &rhs);
bool operator==(const WarningArray &lhs, const WarningArray &rhs);
bool operator!=(const WarningArray &lhs, const WarningArray &rhs);
bool operator==(const Msg8F09T &lhs, const Msg8F09T &rhs);
bool operator!=(const Msg8F09T &lhs, const Msg8F09T &rhs);
bool operator==(const GroupStatusListT &lhs, const GroupStatusListT &rhs);
bool operator!=(const GroupStatusListT &lhs, const GroupStatusListT &rhs);
bool operator==(const Msg8B01T &lhs, const Msg8B01T &rhs);
bool operator!=(const Msg8B01T &lhs, const Msg8B01T &rhs);
bool operator==(const GroupStatusList_WaitInLineT &lhs, const GroupStatusList_WaitInLineT &rhs);
bool operator!=(const GroupStatusList_WaitInLineT &lhs, const GroupStatusList_WaitInLineT &rhs);
bool operator==(const Msg8B03T &lhs, const Msg8B03T &rhs);
bool operator!=(const Msg8B03T &lhs, const Msg8B03T &rhs);
bool operator==(const Msg8307T &lhs, const Msg8307T &rhs);
bool operator!=(const Msg8307T &lhs, const Msg8307T &rhs);
bool operator==(const Msg8308T &lhs, const Msg8308T &rhs);
bool operator!=(const Msg8308T &lhs, const Msg8308T &rhs);
bool operator==(const Msg0F21T &lhs, const Msg0F21T &rhs);
bool operator!=(const Msg0F21T &lhs, const Msg0F21T &rhs);
bool operator==(const Msg0503T &lhs, const Msg0503T &rhs);
bool operator!=(const Msg0503T &lhs, const Msg0503T &rhs);
bool operator==(const Msg8105T &lhs, const Msg8105T &rhs);
bool operator!=(const Msg8105T &lhs, const Msg8105T &rhs);
bool operator==(const Msg8B10T &lhs, const Msg8B10T &rhs);
bool operator!=(const Msg8B10T &lhs, const Msg8B10T &rhs);
bool operator==(const Msg8B11T &lhs, const Msg8B11T &rhs);
bool operator!=(const Msg8B11T &lhs, const Msg8B11T &rhs);
bool operator==(const Msg0F0BT &lhs, const Msg0F0BT &rhs);
bool operator!=(const Msg0F0BT &lhs, const Msg0F0BT &rhs);
bool operator==(const MsgVectorT &lhs, const MsgVectorT &rhs);
bool operator!=(const MsgVectorT &lhs, const MsgVectorT &rhs);
bool operator==(const MsgVoiceNameT &lhs, const MsgVoiceNameT &rhs);
bool operator!=(const MsgVoiceNameT &lhs, const MsgVoiceNameT &rhs);
bool operator==(const Msg1040T &lhs, const Msg1040T &rhs);
bool operator!=(const Msg1040T &lhs, const Msg1040T &rhs);
bool operator==(const Msg0305T &lhs, const Msg0305T &rhs);
bool operator!=(const Msg0305T &lhs, const Msg0305T &rhs);
bool operator==(const Msg8305_V2XT &lhs, const Msg8305_V2XT &rhs);
bool operator!=(const Msg8305_V2XT &lhs, const Msg8305_V2XT &rhs);
bool operator==(const Msg8F0BT &lhs, const Msg8F0BT &rhs);
bool operator!=(const Msg8F0BT &lhs, const Msg8F0BT &rhs);
bool operator==(const Msg0502T &lhs, const Msg0502T &rhs);
bool operator!=(const Msg0502T &lhs, const Msg0502T &rhs);
bool operator==(const Msg0F01T &lhs, const Msg0F01T &rhs);
bool operator!=(const Msg0F01T &lhs, const Msg0F01T &rhs);
bool operator==(const apply_numberArray &lhs, const apply_numberArray &rhs);
bool operator!=(const apply_numberArray &lhs, const apply_numberArray &rhs);
bool operator==(const Msg0F0ET &lhs, const Msg0F0ET &rhs);
bool operator!=(const Msg0F0ET &lhs, const Msg0F0ET &rhs);
bool operator==(const Msg0F1CT &lhs, const Msg0F1CT &rhs);
bool operator!=(const Msg0F1CT &lhs, const Msg0F1CT &rhs);
bool operator==(const passwordArray &lhs, const passwordArray &rhs);
bool operator!=(const passwordArray &lhs, const passwordArray &rhs);
bool operator==(const Msg0F10T &lhs, const Msg0F10T &rhs);
bool operator!=(const Msg0F10T &lhs, const Msg0F10T &rhs);
bool operator==(const Msg0F11T &lhs, const Msg0F11T &rhs);
bool operator!=(const Msg0F11T &lhs, const Msg0F11T &rhs);
bool operator==(const MsgTx_0104T &lhs, const MsgTx_0104T &rhs);
bool operator!=(const MsgTx_0104T &lhs, const MsgTx_0104T &rhs);
bool operator==(const MsgTx_0F03T &lhs, const MsgTx_0F03T &rhs);
bool operator!=(const MsgTx_0F03T &lhs, const MsgTx_0F03T &rhs);
bool operator==(const MsgTx_0F09T &lhs, const MsgTx_0F09T &rhs);
bool operator!=(const MsgTx_0F09T &lhs, const MsgTx_0F09T &rhs);
bool operator==(const MsgTx_8305T &lhs, const MsgTx_8305T &rhs);
bool operator!=(const MsgTx_8305T &lhs, const MsgTx_8305T &rhs);
bool operator==(const MsgTx_8B02T &lhs, const MsgTx_8B02T &rhs);
bool operator!=(const MsgTx_8B02T &lhs, const MsgTx_8B02T &rhs);
bool operator==(const MsgTx_8B07_listT &lhs, const MsgTx_8B07_listT &rhs);
bool operator!=(const MsgTx_8B07_listT &lhs, const MsgTx_8B07_listT &rhs);
bool operator==(const MsgTx_8B07T &lhs, const MsgTx_8B07T &rhs);
bool operator!=(const MsgTx_8B07T &lhs, const MsgTx_8B07T &rhs);
bool operator==(const MsgTx_8B08_listT &lhs, const MsgTx_8B08_listT &rhs);
bool operator!=(const MsgTx_8B08_listT &lhs, const MsgTx_8B08_listT &rhs);
bool operator==(const MsgTx_8B08T &lhs, const MsgTx_8B08T &rhs);
bool operator!=(const MsgTx_8B08T &lhs, const MsgTx_8B08T &rhs);
bool operator==(const MsgTx_0002T &lhs, const MsgTx_0002T &rhs);
bool operator!=(const MsgTx_0002T &lhs, const MsgTx_0002T &rhs);
bool operator==(const MsgCguVersionT &lhs, const MsgCguVersionT &rhs);
bool operator!=(const MsgCguVersionT &lhs, const MsgCguVersionT &rhs);
bool operator==(const MsgVechWarnStatT &lhs, const MsgVechWarnStatT &rhs);
bool operator!=(const MsgVechWarnStatT &lhs, const MsgVechWarnStatT &rhs);

inline const flatbuffers::TypeTable *Msg2050TypeTable();

inline const flatbuffers::TypeTable *Msg8306TypeTable();

inline const flatbuffers::TypeTable *Msg8F02TypeTable();

inline const flatbuffers::TypeTable *Msg8401TypeTable();

inline const flatbuffers::TypeTable *Msg8F0CTypeTable();

inline const flatbuffers::TypeTable *Msg8F0DTypeTable();

inline const flatbuffers::TypeTable *Msg8403TypeTable();

inline const flatbuffers::TypeTable *MovementAuthorityTypeTable();

inline const flatbuffers::TypeTable *Msg8F0FTypeTable();

inline const flatbuffers::TypeTable *Msg8F10TypeTable();

inline const flatbuffers::TypeTable *Msg8C01TypeTable();

inline const flatbuffers::TypeTable *Msg8F04TypeTable();

inline const flatbuffers::TypeTable *Msg8F0ATypeTable();

inline const flatbuffers::TypeTable *WarningArrayTypeTable();

inline const flatbuffers::TypeTable *Msg8F09TypeTable();

inline const flatbuffers::TypeTable *GroupStatusListTypeTable();

inline const flatbuffers::TypeTable *Msg8B01TypeTable();

inline const flatbuffers::TypeTable *GroupStatusList_WaitInLineTypeTable();

inline const flatbuffers::TypeTable *Msg8B03TypeTable();

inline const flatbuffers::TypeTable *Msg8307TypeTable();

inline const flatbuffers::TypeTable *Msg8308TypeTable();

inline const flatbuffers::TypeTable *Msg0F21TypeTable();

inline const flatbuffers::TypeTable *Msg0503TypeTable();

inline const flatbuffers::TypeTable *Msg8105TypeTable();

inline const flatbuffers::TypeTable *Msg8B10TypeTable();

inline const flatbuffers::TypeTable *Msg8B11TypeTable();

inline const flatbuffers::TypeTable *Msg0F0BTypeTable();

inline const flatbuffers::TypeTable *MsgVectorTypeTable();

inline const flatbuffers::TypeTable *MsgVoiceNameTypeTable();

inline const flatbuffers::TypeTable *Msg1040TypeTable();

inline const flatbuffers::TypeTable *Msg0305TypeTable();

inline const flatbuffers::TypeTable *Msg8305_V2XTypeTable();

inline const flatbuffers::TypeTable *Msg8F0BTypeTable();

inline const flatbuffers::TypeTable *Msg0502TypeTable();

inline const flatbuffers::TypeTable *Msg0F01TypeTable();

inline const flatbuffers::TypeTable *apply_numberArrayTypeTable();

inline const flatbuffers::TypeTable *Msg0F0ETypeTable();

inline const flatbuffers::TypeTable *Msg0F1CTypeTable();

inline const flatbuffers::TypeTable *passwordArrayTypeTable();

inline const flatbuffers::TypeTable *Msg0F10TypeTable();

inline const flatbuffers::TypeTable *Msg0F11TypeTable();

inline const flatbuffers::TypeTable *MsgTx_0104TypeTable();

inline const flatbuffers::TypeTable *MsgTx_0F03TypeTable();

inline const flatbuffers::TypeTable *MsgTx_0F09TypeTable();

inline const flatbuffers::TypeTable *MsgTx_8305TypeTable();

inline const flatbuffers::TypeTable *MsgTx_8B02TypeTable();

inline const flatbuffers::TypeTable *MsgTx_8B07_listTypeTable();

inline const flatbuffers::TypeTable *MsgTx_8B07TypeTable();

inline const flatbuffers::TypeTable *MsgTx_8B08_listTypeTable();

inline const flatbuffers::TypeTable *MsgTx_8B08TypeTable();

inline const flatbuffers::TypeTable *MsgTx_0002TypeTable();

inline const flatbuffers::TypeTable *MsgCguVersionTypeTable();

inline const flatbuffers::TypeTable *MsgVechWarnStatTypeTable();

enum TaskDispatchResult {
  TaskDispatchResult_Unknown = 0,
  TaskDispatchResult_Success = 1,
  TaskDispatchResult_TargetFailed = 2,
  TaskDispatchResult_RoadFailed = 3,
  TaskDispatchResult_MIN = TaskDispatchResult_Unknown,
  TaskDispatchResult_MAX = TaskDispatchResult_RoadFailed
};

inline const TaskDispatchResult (&EnumValuesTaskDispatchResult())[4] {
  static const TaskDispatchResult values[] = {
    TaskDispatchResult_Unknown,
    TaskDispatchResult_Success,
    TaskDispatchResult_TargetFailed,
    TaskDispatchResult_RoadFailed
  };
  return values;
}

inline const char * const *EnumNamesTaskDispatchResult() {
  static const char * const names[5] = {
    "Unknown",
    "Success",
    "TargetFailed",
    "RoadFailed",
    nullptr
  };
  return names;
}

inline const char *EnumNameTaskDispatchResult(TaskDispatchResult e) {
  if (flatbuffers::IsOutRange(e, TaskDispatchResult_Unknown, TaskDispatchResult_RoadFailed)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTaskDispatchResult()[index];
}

enum TaskFileDownloadResult {
  TaskFileDownloadResult_Unknown = 0,
  TaskFileDownloadResult_Success = 1,
  TaskFileDownloadResult_DownloadFailed = 2,
  TaskFileDownloadResult_ExtractFailed = 3,
  TaskFileDownloadResult_MIN = TaskFileDownloadResult_Unknown,
  TaskFileDownloadResult_MAX = TaskFileDownloadResult_ExtractFailed
};

inline const TaskFileDownloadResult (&EnumValuesTaskFileDownloadResult())[4] {
  static const TaskFileDownloadResult values[] = {
    TaskFileDownloadResult_Unknown,
    TaskFileDownloadResult_Success,
    TaskFileDownloadResult_DownloadFailed,
    TaskFileDownloadResult_ExtractFailed
  };
  return values;
}

inline const char * const *EnumNamesTaskFileDownloadResult() {
  static const char * const names[5] = {
    "Unknown",
    "Success",
    "DownloadFailed",
    "ExtractFailed",
    nullptr
  };
  return names;
}

inline const char *EnumNameTaskFileDownloadResult(TaskFileDownloadResult e) {
  if (flatbuffers::IsOutRange(e, TaskFileDownloadResult_Unknown, TaskFileDownloadResult_ExtractFailed)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTaskFileDownloadResult()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) WarningArray FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t warning_[16];

 public:
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return WarningArrayTypeTable();
  }
  WarningArray()
      : warning_() {
  }
  const flatbuffers::Array<uint8_t, 16> *warning() const {
    return reinterpret_cast<const flatbuffers::Array<uint8_t, 16> *>(warning_);
  }
  flatbuffers::Array<uint8_t, 16> *mutable_warning() {
    return reinterpret_cast<flatbuffers::Array<uint8_t, 16> *>(warning_);
  }
};
FLATBUFFERS_STRUCT_END(WarningArray, 16);

inline bool operator==(const WarningArray &lhs, const WarningArray &rhs) {
  return
      (lhs.warning() == rhs.warning());
}

inline bool operator!=(const WarningArray &lhs, const WarningArray &rhs) {
    return !(lhs == rhs);
}


FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) apply_numberArray FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t apply_number_[8];

 public:
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return apply_numberArrayTypeTable();
  }
  apply_numberArray()
      : apply_number_() {
  }
  const flatbuffers::Array<uint8_t, 8> *apply_number() const {
    return reinterpret_cast<const flatbuffers::Array<uint8_t, 8> *>(apply_number_);
  }
  flatbuffers::Array<uint8_t, 8> *mutable_apply_number() {
    return reinterpret_cast<flatbuffers::Array<uint8_t, 8> *>(apply_number_);
  }
};
FLATBUFFERS_STRUCT_END(apply_numberArray, 8);

inline bool operator==(const apply_numberArray &lhs, const apply_numberArray &rhs) {
  return
      (lhs.apply_number() == rhs.apply_number());
}

inline bool operator!=(const apply_numberArray &lhs, const apply_numberArray &rhs) {
    return !(lhs == rhs);
}


FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) passwordArray FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t password_[6];

 public:
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return passwordArrayTypeTable();
  }
  passwordArray()
      : password_() {
  }
  const flatbuffers::Array<uint8_t, 6> *password() const {
    return reinterpret_cast<const flatbuffers::Array<uint8_t, 6> *>(password_);
  }
  flatbuffers::Array<uint8_t, 6> *mutable_password() {
    return reinterpret_cast<flatbuffers::Array<uint8_t, 6> *>(password_);
  }
};
FLATBUFFERS_STRUCT_END(passwordArray, 6);

inline bool operator==(const passwordArray &lhs, const passwordArray &rhs) {
  return
      (lhs.password() == rhs.password());
}

inline bool operator!=(const passwordArray &lhs, const passwordArray &rhs) {
    return !(lhs == rhs);
}


struct Msg2050T : public flatbuffers::NativeTable {
  typedef Msg2050 TableType;
  uint16_t id;
  uint16_t turn_off_cmd;
  uint16_t turn_off_cmd_reverse;
  Msg2050T()
      : id(0),
        turn_off_cmd(0),
        turn_off_cmd_reverse(0) {
  }
};

inline bool operator==(const Msg2050T &lhs, const Msg2050T &rhs) {
  return
      (lhs.id == rhs.id) &&
      (lhs.turn_off_cmd == rhs.turn_off_cmd) &&
      (lhs.turn_off_cmd_reverse == rhs.turn_off_cmd_reverse);
}

inline bool operator!=(const Msg2050T &lhs, const Msg2050T &rhs) {
    return !(lhs == rhs);
}


struct Msg2050 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Msg2050T NativeTableType;
  typedef Msg2050Builder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Msg2050TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TURN_OFF_CMD = 6,
    VT_TURN_OFF_CMD_REVERSE = 8
  };
  uint16_t id() const {
    return GetField<uint16_t>(VT_ID, 0);
  }
  bool mutate_id(uint16_t _id) {
    return SetField<uint16_t>(VT_ID, _id, 0);
  }
  uint16_t turn_off_cmd() const {
    return GetField<uint16_t>(VT_TURN_OFF_CMD, 0);
  }
  bool mutate_turn_off_cmd(uint16_t _turn_off_cmd) {
    return SetField<uint16_t>(VT_TURN_OFF_CMD, _turn_off_cmd, 0);
  }
  uint16_t turn_off_cmd_reverse() const {
    return GetField<uint16_t>(VT_TURN_OFF_CMD_REVERSE, 0);
  }
  bool mutate_turn_off_cmd_reverse(uint16_t _turn_off_cmd_reverse) {
    return SetField<uint16_t>(VT_TURN_OFF_CMD_REVERSE, _turn_off_cmd_reverse, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ID) &&
           VerifyField<uint16_t>(verifier, VT_TURN_OFF_CMD) &&
           VerifyField<uint16_t>(verifier, VT_TURN_OFF_CMD_REVERSE) &&
           verifier.EndTable();
  }
  Msg2050T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Msg2050T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Msg2050> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg2050T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Msg2050Builder {
  typedef Msg2050 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint16_t id) {
    fbb_.AddElement<uint16_t>(Msg2050::VT_ID, id, 0);
  }
  void add_turn_off_cmd(uint16_t turn_off_cmd) {
    fbb_.AddElement<uint16_t>(Msg2050::VT_TURN_OFF_CMD, turn_off_cmd, 0);
  }
  void add_turn_off_cmd_reverse(uint16_t turn_off_cmd_reverse) {
    fbb_.AddElement<uint16_t>(Msg2050::VT_TURN_OFF_CMD_REVERSE, turn_off_cmd_reverse, 0);
  }
  explicit Msg2050Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Msg2050> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Msg2050>(end);
    return o;
  }
};

inline flatbuffers::Offset<Msg2050> CreateMsg2050(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t id = 0,
    uint16_t turn_off_cmd = 0,
    uint16_t turn_off_cmd_reverse = 0) {
  Msg2050Builder builder_(_fbb);
  builder_.add_turn_off_cmd_reverse(turn_off_cmd_reverse);
  builder_.add_turn_off_cmd(turn_off_cmd);
  builder_.add_id(id);
  return builder_.Finish();
}

flatbuffers::Offset<Msg2050> CreateMsg2050(flatbuffers::FlatBufferBuilder &_fbb, const Msg2050T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Msg8306T : public flatbuffers::NativeTable {
  typedef Msg8306 TableType;
  uint16_t id;
  std::string self_vehicle_id;
  std::string target_id;
  uint8_t work_class;
  uint8_t cmd_flag;
  uint8_t load_status;
  uint16_t material_type;
  double parking_lat;
  double parking_lng;
  double parking_head;
  std::string self_vehicle_name;
  std::string target_name;
  Msg8306T()
      : id(0),
        work_class(0),
        cmd_flag(0),
        load_status(0),
        material_type(0),
        parking_lat(0.0),
        parking_lng(0.0),
        parking_head(0.0) {
  }
};

inline bool operator==(const Msg8306T &lhs, const Msg8306T &rhs) {
  return
      (lhs.id == rhs.id) &&
      (lhs.self_vehicle_id == rhs.self_vehicle_id) &&
      (lhs.target_id == rhs.target_id) &&
      (lhs.work_class == rhs.work_class) &&
      (lhs.cmd_flag == rhs.cmd_flag) &&
      (lhs.load_status == rhs.load_status) &&
      (lhs.material_type == rhs.material_type) &&
      (lhs.parking_lat == rhs.parking_lat) &&
      (lhs.parking_lng == rhs.parking_lng) &&
      (lhs.parking_head == rhs.parking_head) &&
      (lhs.self_vehicle_name == rhs.self_vehicle_name) &&
      (lhs.target_name == rhs.target_name);
}

inline bool operator!=(const Msg8306T &lhs, const Msg8306T &rhs) {
    return !(lhs == rhs);
}


struct Msg8306 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Msg8306T NativeTableType;
  typedef Msg8306Builder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Msg8306TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_SELF_VEHICLE_ID = 6,
    VT_TARGET_ID = 8,
    VT_WORK_CLASS = 10,
    VT_CMD_FLAG = 12,
    VT_LOAD_STATUS = 14,
    VT_MATERIAL_TYPE = 16,
    VT_PARKING_LAT = 18,
    VT_PARKING_LNG = 20,
    VT_PARKING_HEAD = 22,
    VT_SELF_VEHICLE_NAME = 24,
    VT_TARGET_NAME = 26
  };
  uint16_t id() const {
    return GetField<uint16_t>(VT_ID, 0);
  }
  bool mutate_id(uint16_t _id) {
    return SetField<uint16_t>(VT_ID, _id, 0);
  }
  const flatbuffers::String *self_vehicle_id() const {
    return GetPointer<const flatbuffers::String *>(VT_SELF_VEHICLE_ID);
  }
  flatbuffers::String *mutable_self_vehicle_id() {
    return GetPointer<flatbuffers::String *>(VT_SELF_VEHICLE_ID);
  }
  const flatbuffers::String *target_id() const {
    return GetPointer<const flatbuffers::String *>(VT_TARGET_ID);
  }
  flatbuffers::String *mutable_target_id() {
    return GetPointer<flatbuffers::String *>(VT_TARGET_ID);
  }
  uint8_t work_class() const {
    return GetField<uint8_t>(VT_WORK_CLASS, 0);
  }
  bool mutate_work_class(uint8_t _work_class) {
    return SetField<uint8_t>(VT_WORK_CLASS, _work_class, 0);
  }
  uint8_t cmd_flag() const {
    return GetField<uint8_t>(VT_CMD_FLAG, 0);
  }
  bool mutate_cmd_flag(uint8_t _cmd_flag) {
    return SetField<uint8_t>(VT_CMD_FLAG, _cmd_flag, 0);
  }
  uint8_t load_status() const {
    return GetField<uint8_t>(VT_LOAD_STATUS, 0);
  }
  bool mutate_load_status(uint8_t _load_status) {
    return SetField<uint8_t>(VT_LOAD_STATUS, _load_status, 0);
  }
  uint16_t material_type() const {
    return GetField<uint16_t>(VT_MATERIAL_TYPE, 0);
  }
  bool mutate_material_type(uint16_t _material_type) {
    return SetField<uint16_t>(VT_MATERIAL_TYPE, _material_type, 0);
  }
  double parking_lat() const {
    return GetField<double>(VT_PARKING_LAT, 0.0);
  }
  bool mutate_parking_lat(double _parking_lat) {
    return SetField<double>(VT_PARKING_LAT, _parking_lat, 0.0);
  }
  double parking_lng() const {
    return GetField<double>(VT_PARKING_LNG, 0.0);
  }
  bool mutate_parking_lng(double _parking_lng) {
    return SetField<double>(VT_PARKING_LNG, _parking_lng, 0.0);
  }
  double parking_head() const {
    return GetField<double>(VT_PARKING_HEAD, 0.0);
  }
  bool mutate_parking_head(double _parking_head) {
    return SetField<double>(VT_PARKING_HEAD, _parking_head, 0.0);
  }
  const flatbuffers::String *self_vehicle_name() const {
    return GetPointer<const flatbuffers::String *>(VT_SELF_VEHICLE_NAME);
  }
  flatbuffers::String *mutable_self_vehicle_name() {
    return GetPointer<flatbuffers::String *>(VT_SELF_VEHICLE_NAME);
  }
  const flatbuffers::String *target_name() const {
    return GetPointer<const flatbuffers::String *>(VT_TARGET_NAME);
  }
  flatbuffers::String *mutable_target_name() {
    return GetPointer<flatbuffers::String *>(VT_TARGET_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ID) &&
           VerifyOffset(verifier, VT_SELF_VEHICLE_ID) &&
           verifier.VerifyString(self_vehicle_id()) &&
           VerifyOffset(verifier, VT_TARGET_ID) &&
           verifier.VerifyString(target_id()) &&
           VerifyField<uint8_t>(verifier, VT_WORK_CLASS) &&
           VerifyField<uint8_t>(verifier, VT_CMD_FLAG) &&
           VerifyField<uint8_t>(verifier, VT_LOAD_STATUS) &&
           VerifyField<uint16_t>(verifier, VT_MATERIAL_TYPE) &&
           VerifyField<double>(verifier, VT_PARKING_LAT) &&
           VerifyField<double>(verifier, VT_PARKING_LNG) &&
           VerifyField<double>(verifier, VT_PARKING_HEAD) &&
           VerifyOffset(verifier, VT_SELF_VEHICLE_NAME) &&
           verifier.VerifyString(self_vehicle_name()) &&
           VerifyOffset(verifier, VT_TARGET_NAME) &&
           verifier.VerifyString(target_name()) &&
           verifier.EndTable();
  }
  Msg8306T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Msg8306T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Msg8306> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg8306T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Msg8306Builder {
  typedef Msg8306 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint16_t id) {
    fbb_.AddElement<uint16_t>(Msg8306::VT_ID, id, 0);
  }
  void add_self_vehicle_id(flatbuffers::Offset<flatbuffers::String> self_vehicle_id) {
    fbb_.AddOffset(Msg8306::VT_SELF_VEHICLE_ID, self_vehicle_id);
  }
  void add_target_id(flatbuffers::Offset<flatbuffers::String> target_id) {
    fbb_.AddOffset(Msg8306::VT_TARGET_ID, target_id);
  }
  void add_work_class(uint8_t work_class) {
    fbb_.AddElement<uint8_t>(Msg8306::VT_WORK_CLASS, work_class, 0);
  }
  void add_cmd_flag(uint8_t cmd_flag) {
    fbb_.AddElement<uint8_t>(Msg8306::VT_CMD_FLAG, cmd_flag, 0);
  }
  void add_load_status(uint8_t load_status) {
    fbb_.AddElement<uint8_t>(Msg8306::VT_LOAD_STATUS, load_status, 0);
  }
  void add_material_type(uint16_t material_type) {
    fbb_.AddElement<uint16_t>(Msg8306::VT_MATERIAL_TYPE, material_type, 0);
  }
  void add_parking_lat(double parking_lat) {
    fbb_.AddElement<double>(Msg8306::VT_PARKING_LAT, parking_lat, 0.0);
  }
  void add_parking_lng(double parking_lng) {
    fbb_.AddElement<double>(Msg8306::VT_PARKING_LNG, parking_lng, 0.0);
  }
  void add_parking_head(double parking_head) {
    fbb_.AddElement<double>(Msg8306::VT_PARKING_HEAD, parking_head, 0.0);
  }
  void add_self_vehicle_name(flatbuffers::Offset<flatbuffers::String> self_vehicle_name) {
    fbb_.AddOffset(Msg8306::VT_SELF_VEHICLE_NAME, self_vehicle_name);
  }
  void add_target_name(flatbuffers::Offset<flatbuffers::String> target_name) {
    fbb_.AddOffset(Msg8306::VT_TARGET_NAME, target_name);
  }
  explicit Msg8306Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Msg8306> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Msg8306>(end);
    return o;
  }
};

inline flatbuffers::Offset<Msg8306> CreateMsg8306(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t id = 0,
    flatbuffers::Offset<flatbuffers::String> self_vehicle_id = 0,
    flatbuffers::Offset<flatbuffers::String> target_id = 0,
    uint8_t work_class = 0,
    uint8_t cmd_flag = 0,
    uint8_t load_status = 0,
    uint16_t material_type = 0,
    double parking_lat = 0.0,
    double parking_lng = 0.0,
    double parking_head = 0.0,
    flatbuffers::Offset<flatbuffers::String> self_vehicle_name = 0,
    flatbuffers::Offset<flatbuffers::String> target_name = 0) {
  Msg8306Builder builder_(_fbb);
  builder_.add_parking_head(parking_head);
  builder_.add_parking_lng(parking_lng);
  builder_.add_parking_lat(parking_lat);
  builder_.add_target_name(target_name);
  builder_.add_self_vehicle_name(self_vehicle_name);
  builder_.add_target_id(target_id);
  builder_.add_self_vehicle_id(self_vehicle_id);
  builder_.add_material_type(material_type);
  builder_.add_id(id);
  builder_.add_load_status(load_status);
  builder_.add_cmd_flag(cmd_flag);
  builder_.add_work_class(work_class);
  return builder_.Finish();
}

inline flatbuffers::Offset<Msg8306> CreateMsg8306Direct(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t id = 0,
    const char *self_vehicle_id = nullptr,
    const char *target_id = nullptr,
    uint8_t work_class = 0,
    uint8_t cmd_flag = 0,
    uint8_t load_status = 0,
    uint16_t material_type = 0,
    double parking_lat = 0.0,
    double parking_lng = 0.0,
    double parking_head = 0.0,
    const char *self_vehicle_name = nullptr,
    const char *target_name = nullptr) {
  auto self_vehicle_id__ = self_vehicle_id ? _fbb.CreateString(self_vehicle_id) : 0;
  auto target_id__ = target_id ? _fbb.CreateString(target_id) : 0;
  auto self_vehicle_name__ = self_vehicle_name ? _fbb.CreateString(self_vehicle_name) : 0;
  auto target_name__ = target_name ? _fbb.CreateString(target_name) : 0;
  return CreateMsg8306(
      _fbb,
      id,
      self_vehicle_id__,
      target_id__,
      work_class,
      cmd_flag,
      load_status,
      material_type,
      parking_lat,
      parking_lng,
      parking_head,
      self_vehicle_name__,
      target_name__);
}

flatbuffers::Offset<Msg8306> CreateMsg8306(flatbuffers::FlatBufferBuilder &_fbb, const Msg8306T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Msg8F02T : public flatbuffers::NativeTable {
  typedef Msg8F02 TableType;
  uint16_t id;
  uint8_t service_state_type;
  uint16_t service_delay_reason;
  uint16_t time_delay;
  Msg8F02T()
      : id(0),
        service_state_type(0),
        service_delay_reason(0),
        time_delay(0) {
  }
};

inline bool operator==(const Msg8F02T &lhs, const Msg8F02T &rhs) {
  return
      (lhs.id == rhs.id) &&
      (lhs.service_state_type == rhs.service_state_type) &&
      (lhs.service_delay_reason == rhs.service_delay_reason) &&
      (lhs.time_delay == rhs.time_delay);
}

inline bool operator!=(const Msg8F02T &lhs, const Msg8F02T &rhs) {
    return !(lhs == rhs);
}


struct Msg8F02 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Msg8F02T NativeTableType;
  typedef Msg8F02Builder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Msg8F02TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_SERVICE_STATE_TYPE = 6,
    VT_SERVICE_DELAY_REASON = 8,
    VT_TIME_DELAY = 10
  };
  uint16_t id() const {
    return GetField<uint16_t>(VT_ID, 0);
  }
  bool mutate_id(uint16_t _id) {
    return SetField<uint16_t>(VT_ID, _id, 0);
  }
  uint8_t service_state_type() const {
    return GetField<uint8_t>(VT_SERVICE_STATE_TYPE, 0);
  }
  bool mutate_service_state_type(uint8_t _service_state_type) {
    return SetField<uint8_t>(VT_SERVICE_STATE_TYPE, _service_state_type, 0);
  }
  uint16_t service_delay_reason() const {
    return GetField<uint16_t>(VT_SERVICE_DELAY_REASON, 0);
  }
  bool mutate_service_delay_reason(uint16_t _service_delay_reason) {
    return SetField<uint16_t>(VT_SERVICE_DELAY_REASON, _service_delay_reason, 0);
  }
  uint16_t time_delay() const {
    return GetField<uint16_t>(VT_TIME_DELAY, 0);
  }
  bool mutate_time_delay(uint16_t _time_delay) {
    return SetField<uint16_t>(VT_TIME_DELAY, _time_delay, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ID) &&
           VerifyField<uint8_t>(verifier, VT_SERVICE_STATE_TYPE) &&
           VerifyField<uint16_t>(verifier, VT_SERVICE_DELAY_REASON) &&
           VerifyField<uint16_t>(verifier, VT_TIME_DELAY) &&
           verifier.EndTable();
  }
  Msg8F02T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Msg8F02T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Msg8F02> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg8F02T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Msg8F02Builder {
  typedef Msg8F02 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint16_t id) {
    fbb_.AddElement<uint16_t>(Msg8F02::VT_ID, id, 0);
  }
  void add_service_state_type(uint8_t service_state_type) {
    fbb_.AddElement<uint8_t>(Msg8F02::VT_SERVICE_STATE_TYPE, service_state_type, 0);
  }
  void add_service_delay_reason(uint16_t service_delay_reason) {
    fbb_.AddElement<uint16_t>(Msg8F02::VT_SERVICE_DELAY_REASON, service_delay_reason, 0);
  }
  void add_time_delay(uint16_t time_delay) {
    fbb_.AddElement<uint16_t>(Msg8F02::VT_TIME_DELAY, time_delay, 0);
  }
  explicit Msg8F02Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Msg8F02> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Msg8F02>(end);
    return o;
  }
};

inline flatbuffers::Offset<Msg8F02> CreateMsg8F02(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t id = 0,
    uint8_t service_state_type = 0,
    uint16_t service_delay_reason = 0,
    uint16_t time_delay = 0) {
  Msg8F02Builder builder_(_fbb);
  builder_.add_time_delay(time_delay);
  builder_.add_service_delay_reason(service_delay_reason);
  builder_.add_id(id);
  builder_.add_service_state_type(service_state_type);
  return builder_.Finish();
}

flatbuffers::Offset<Msg8F02> CreateMsg8F02(flatbuffers::FlatBufferBuilder &_fbb, const Msg8F02T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Msg8401T : public flatbuffers::NativeTable {
  typedef Msg8401 TableType;
  uint16_t id;
  std::string target_id;
  uint8_t warning_type;
  float distance;
  float collision_time;
  uint8_t vehicle_type;
  float length;
  float width;
  float height;
  double lat;
  double lng;
  float head;
  float speed;
  float east_speed;
  float north_speed;
  float front_angle;
  uint16_t road_id;
  uint8_t road_direction;
  uint64_t gps_time;
  std::string dname;
  Msg8401T()
      : id(0),
        warning_type(0),
        distance(0.0f),
        collision_time(0.0f),
        vehicle_type(0),
        length(0.0f),
        width(0.0f),
        height(0.0f),
        lat(0.0),
        lng(0.0),
        head(0.0f),
        speed(0.0f),
        east_speed(0.0f),
        north_speed(0.0f),
        front_angle(0.0f),
        road_id(0),
        road_direction(0),
        gps_time(0) {
  }
};

inline bool operator==(const Msg8401T &lhs, const Msg8401T &rhs) {
  return
      (lhs.id == rhs.id) &&
      (lhs.target_id == rhs.target_id) &&
      (lhs.warning_type == rhs.warning_type) &&
      (lhs.distance == rhs.distance) &&
      (lhs.collision_time == rhs.collision_time) &&
      (lhs.vehicle_type == rhs.vehicle_type) &&
      (lhs.length == rhs.length) &&
      (lhs.width == rhs.width) &&
      (lhs.height == rhs.height) &&
      (lhs.lat == rhs.lat) &&
      (lhs.lng == rhs.lng) &&
      (lhs.head == rhs.head) &&
      (lhs.speed == rhs.speed) &&
      (lhs.east_speed == rhs.east_speed) &&
      (lhs.north_speed == rhs.north_speed) &&
      (lhs.front_angle == rhs.front_angle) &&
      (lhs.road_id == rhs.road_id) &&
      (lhs.road_direction == rhs.road_direction) &&
      (lhs.gps_time == rhs.gps_time) &&
      (lhs.dname == rhs.dname);
}

inline bool operator!=(const Msg8401T &lhs, const Msg8401T &rhs) {
    return !(lhs == rhs);
}


struct Msg8401 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Msg8401T NativeTableType;
  typedef Msg8401Builder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Msg8401TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TARGET_ID = 6,
    VT_WARNING_TYPE = 8,
    VT_DISTANCE = 10,
    VT_COLLISION_TIME = 12,
    VT_VEHICLE_TYPE = 14,
    VT_LENGTH = 16,
    VT_WIDTH = 18,
    VT_HEIGHT = 20,
    VT_LAT = 22,
    VT_LNG = 24,
    VT_HEAD = 26,
    VT_SPEED = 28,
    VT_EAST_SPEED = 30,
    VT_NORTH_SPEED = 32,
    VT_FRONT_ANGLE = 34,
    VT_ROAD_ID = 36,
    VT_ROAD_DIRECTION = 38,
    VT_GPS_TIME = 40,
    VT_DNAME = 42
  };
  uint16_t id() const {
    return GetField<uint16_t>(VT_ID, 0);
  }
  bool mutate_id(uint16_t _id) {
    return SetField<uint16_t>(VT_ID, _id, 0);
  }
  const flatbuffers::String *target_id() const {
    return GetPointer<const flatbuffers::String *>(VT_TARGET_ID);
  }
  flatbuffers::String *mutable_target_id() {
    return GetPointer<flatbuffers::String *>(VT_TARGET_ID);
  }
  uint8_t warning_type() const {
    return GetField<uint8_t>(VT_WARNING_TYPE, 0);
  }
  bool mutate_warning_type(uint8_t _warning_type) {
    return SetField<uint8_t>(VT_WARNING_TYPE, _warning_type, 0);
  }
  float distance() const {
    return GetField<float>(VT_DISTANCE, 0.0f);
  }
  bool mutate_distance(float _distance) {
    return SetField<float>(VT_DISTANCE, _distance, 0.0f);
  }
  float collision_time() const {
    return GetField<float>(VT_COLLISION_TIME, 0.0f);
  }
  bool mutate_collision_time(float _collision_time) {
    return SetField<float>(VT_COLLISION_TIME, _collision_time, 0.0f);
  }
  uint8_t vehicle_type() const {
    return GetField<uint8_t>(VT_VEHICLE_TYPE, 0);
  }
  bool mutate_vehicle_type(uint8_t _vehicle_type) {
    return SetField<uint8_t>(VT_VEHICLE_TYPE, _vehicle_type, 0);
  }
  float length() const {
    return GetField<float>(VT_LENGTH, 0.0f);
  }
  bool mutate_length(float _length) {
    return SetField<float>(VT_LENGTH, _length, 0.0f);
  }
  float width() const {
    return GetField<float>(VT_WIDTH, 0.0f);
  }
  bool mutate_width(float _width) {
    return SetField<float>(VT_WIDTH, _width, 0.0f);
  }
  float height() const {
    return GetField<float>(VT_HEIGHT, 0.0f);
  }
  bool mutate_height(float _height) {
    return SetField<float>(VT_HEIGHT, _height, 0.0f);
  }
  double lat() const {
    return GetField<double>(VT_LAT, 0.0);
  }
  bool mutate_lat(double _lat) {
    return SetField<double>(VT_LAT, _lat, 0.0);
  }
  double lng() const {
    return GetField<double>(VT_LNG, 0.0);
  }
  bool mutate_lng(double _lng) {
    return SetField<double>(VT_LNG, _lng, 0.0);
  }
  float head() const {
    return GetField<float>(VT_HEAD, 0.0f);
  }
  bool mutate_head(float _head) {
    return SetField<float>(VT_HEAD, _head, 0.0f);
  }
  float speed() const {
    return GetField<float>(VT_SPEED, 0.0f);
  }
  bool mutate_speed(float _speed) {
    return SetField<float>(VT_SPEED, _speed, 0.0f);
  }
  float east_speed() const {
    return GetField<float>(VT_EAST_SPEED, 0.0f);
  }
  bool mutate_east_speed(float _east_speed) {
    return SetField<float>(VT_EAST_SPEED, _east_speed, 0.0f);
  }
  float north_speed() const {
    return GetField<float>(VT_NORTH_SPEED, 0.0f);
  }
  bool mutate_north_speed(float _north_speed) {
    return SetField<float>(VT_NORTH_SPEED, _north_speed, 0.0f);
  }
  float front_angle() const {
    return GetField<float>(VT_FRONT_ANGLE, 0.0f);
  }
  bool mutate_front_angle(float _front_angle) {
    return SetField<float>(VT_FRONT_ANGLE, _front_angle, 0.0f);
  }
  uint16_t road_id() const {
    return GetField<uint16_t>(VT_ROAD_ID, 0);
  }
  bool mutate_road_id(uint16_t _road_id) {
    return SetField<uint16_t>(VT_ROAD_ID, _road_id, 0);
  }
  uint8_t road_direction() const {
    return GetField<uint8_t>(VT_ROAD_DIRECTION, 0);
  }
  bool mutate_road_direction(uint8_t _road_direction) {
    return SetField<uint8_t>(VT_ROAD_DIRECTION, _road_direction, 0);
  }
  uint64_t gps_time() const {
    return GetField<uint64_t>(VT_GPS_TIME, 0);
  }
  bool mutate_gps_time(uint64_t _gps_time) {
    return SetField<uint64_t>(VT_GPS_TIME, _gps_time, 0);
  }
  const flatbuffers::String *dname() const {
    return GetPointer<const flatbuffers::String *>(VT_DNAME);
  }
  flatbuffers::String *mutable_dname() {
    return GetPointer<flatbuffers::String *>(VT_DNAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ID) &&
           VerifyOffset(verifier, VT_TARGET_ID) &&
           verifier.VerifyString(target_id()) &&
           VerifyField<uint8_t>(verifier, VT_WARNING_TYPE) &&
           VerifyField<float>(verifier, VT_DISTANCE) &&
           VerifyField<float>(verifier, VT_COLLISION_TIME) &&
           VerifyField<uint8_t>(verifier, VT_VEHICLE_TYPE) &&
           VerifyField<float>(verifier, VT_LENGTH) &&
           VerifyField<float>(verifier, VT_WIDTH) &&
           VerifyField<float>(verifier, VT_HEIGHT) &&
           VerifyField<double>(verifier, VT_LAT) &&
           VerifyField<double>(verifier, VT_LNG) &&
           VerifyField<float>(verifier, VT_HEAD) &&
           VerifyField<float>(verifier, VT_SPEED) &&
           VerifyField<float>(verifier, VT_EAST_SPEED) &&
           VerifyField<float>(verifier, VT_NORTH_SPEED) &&
           VerifyField<float>(verifier, VT_FRONT_ANGLE) &&
           VerifyField<uint16_t>(verifier, VT_ROAD_ID) &&
           VerifyField<uint8_t>(verifier, VT_ROAD_DIRECTION) &&
           VerifyField<uint64_t>(verifier, VT_GPS_TIME) &&
           VerifyOffset(verifier, VT_DNAME) &&
           verifier.VerifyString(dname()) &&
           verifier.EndTable();
  }
  Msg8401T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Msg8401T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Msg8401> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg8401T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Msg8401Builder {
  typedef Msg8401 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint16_t id) {
    fbb_.AddElement<uint16_t>(Msg8401::VT_ID, id, 0);
  }
  void add_target_id(flatbuffers::Offset<flatbuffers::String> target_id) {
    fbb_.AddOffset(Msg8401::VT_TARGET_ID, target_id);
  }
  void add_warning_type(uint8_t warning_type) {
    fbb_.AddElement<uint8_t>(Msg8401::VT_WARNING_TYPE, warning_type, 0);
  }
  void add_distance(float distance) {
    fbb_.AddElement<float>(Msg8401::VT_DISTANCE, distance, 0.0f);
  }
  void add_collision_time(float collision_time) {
    fbb_.AddElement<float>(Msg8401::VT_COLLISION_TIME, collision_time, 0.0f);
  }
  void add_vehicle_type(uint8_t vehicle_type) {
    fbb_.AddElement<uint8_t>(Msg8401::VT_VEHICLE_TYPE, vehicle_type, 0);
  }
  void add_length(float length) {
    fbb_.AddElement<float>(Msg8401::VT_LENGTH, length, 0.0f);
  }
  void add_width(float width) {
    fbb_.AddElement<float>(Msg8401::VT_WIDTH, width, 0.0f);
  }
  void add_height(float height) {
    fbb_.AddElement<float>(Msg8401::VT_HEIGHT, height, 0.0f);
  }
  void add_lat(double lat) {
    fbb_.AddElement<double>(Msg8401::VT_LAT, lat, 0.0);
  }
  void add_lng(double lng) {
    fbb_.AddElement<double>(Msg8401::VT_LNG, lng, 0.0);
  }
  void add_head(float head) {
    fbb_.AddElement<float>(Msg8401::VT_HEAD, head, 0.0f);
  }
  void add_speed(float speed) {
    fbb_.AddElement<float>(Msg8401::VT_SPEED, speed, 0.0f);
  }
  void add_east_speed(float east_speed) {
    fbb_.AddElement<float>(Msg8401::VT_EAST_SPEED, east_speed, 0.0f);
  }
  void add_north_speed(float north_speed) {
    fbb_.AddElement<float>(Msg8401::VT_NORTH_SPEED, north_speed, 0.0f);
  }
  void add_front_angle(float front_angle) {
    fbb_.AddElement<float>(Msg8401::VT_FRONT_ANGLE, front_angle, 0.0f);
  }
  void add_road_id(uint16_t road_id) {
    fbb_.AddElement<uint16_t>(Msg8401::VT_ROAD_ID, road_id, 0);
  }
  void add_road_direction(uint8_t road_direction) {
    fbb_.AddElement<uint8_t>(Msg8401::VT_ROAD_DIRECTION, road_direction, 0);
  }
  void add_gps_time(uint64_t gps_time) {
    fbb_.AddElement<uint64_t>(Msg8401::VT_GPS_TIME, gps_time, 0);
  }
  void add_dname(flatbuffers::Offset<flatbuffers::String> dname) {
    fbb_.AddOffset(Msg8401::VT_DNAME, dname);
  }
  explicit Msg8401Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Msg8401> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Msg8401>(end);
    return o;
  }
};

inline flatbuffers::Offset<Msg8401> CreateMsg8401(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t id = 0,
    flatbuffers::Offset<flatbuffers::String> target_id = 0,
    uint8_t warning_type = 0,
    float distance = 0.0f,
    float collision_time = 0.0f,
    uint8_t vehicle_type = 0,
    float length = 0.0f,
    float width = 0.0f,
    float height = 0.0f,
    double lat = 0.0,
    double lng = 0.0,
    float head = 0.0f,
    float speed = 0.0f,
    float east_speed = 0.0f,
    float north_speed = 0.0f,
    float front_angle = 0.0f,
    uint16_t road_id = 0,
    uint8_t road_direction = 0,
    uint64_t gps_time = 0,
    flatbuffers::Offset<flatbuffers::String> dname = 0) {
  Msg8401Builder builder_(_fbb);
  builder_.add_gps_time(gps_time);
  builder_.add_lng(lng);
  builder_.add_lat(lat);
  builder_.add_dname(dname);
  builder_.add_front_angle(front_angle);
  builder_.add_north_speed(north_speed);
  builder_.add_east_speed(east_speed);
  builder_.add_speed(speed);
  builder_.add_head(head);
  builder_.add_height(height);
  builder_.add_width(width);
  builder_.add_length(length);
  builder_.add_collision_time(collision_time);
  builder_.add_distance(distance);
  builder_.add_target_id(target_id);
  builder_.add_road_id(road_id);
  builder_.add_id(id);
  builder_.add_road_direction(road_direction);
  builder_.add_vehicle_type(vehicle_type);
  builder_.add_warning_type(warning_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Msg8401> CreateMsg8401Direct(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t id = 0,
    const char *target_id = nullptr,
    uint8_t warning_type = 0,
    float distance = 0.0f,
    float collision_time = 0.0f,
    uint8_t vehicle_type = 0,
    float length = 0.0f,
    float width = 0.0f,
    float height = 0.0f,
    double lat = 0.0,
    double lng = 0.0,
    float head = 0.0f,
    float speed = 0.0f,
    float east_speed = 0.0f,
    float north_speed = 0.0f,
    float front_angle = 0.0f,
    uint16_t road_id = 0,
    uint8_t road_direction = 0,
    uint64_t gps_time = 0,
    const char *dname = nullptr) {
  auto target_id__ = target_id ? _fbb.CreateString(target_id) : 0;
  auto dname__ = dname ? _fbb.CreateString(dname) : 0;
  return CreateMsg8401(
      _fbb,
      id,
      target_id__,
      warning_type,
      distance,
      collision_time,
      vehicle_type,
      length,
      width,
      height,
      lat,
      lng,
      head,
      speed,
      east_speed,
      north_speed,
      front_angle,
      road_id,
      road_direction,
      gps_time,
      dname__);
}

flatbuffers::Offset<Msg8401> CreateMsg8401(flatbuffers::FlatBufferBuilder &_fbb, const Msg8401T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Msg8F0CT : public flatbuffers::NativeTable {
  typedef Msg8F0C TableType;
  uint16_t id;
  uint8_t task_type;
  uint16_t task_num;
  TaskDispatchResult task_dispatch_result;
  std::string task_target_imei;
  std::string task_file_md5;
  std::string targetDevName;
  uint16_t siteId;
  std::string task_file_name;
  Msg8F0CT()
      : id(0),
        task_type(0),
        task_num(0),
        task_dispatch_result(TaskDispatchResult_Unknown),
        siteId(0) {
  }
};

inline bool operator==(const Msg8F0CT &lhs, const Msg8F0CT &rhs) {
  return
      (lhs.id == rhs.id) &&
      (lhs.task_type == rhs.task_type) &&
      (lhs.task_num == rhs.task_num) &&
      (lhs.task_dispatch_result == rhs.task_dispatch_result) &&
      (lhs.task_target_imei == rhs.task_target_imei) &&
      (lhs.task_file_md5 == rhs.task_file_md5) &&
      (lhs.targetDevName == rhs.targetDevName) &&
      (lhs.siteId == rhs.siteId) &&
      (lhs.task_file_name == rhs.task_file_name);
}

inline bool operator!=(const Msg8F0CT &lhs, const Msg8F0CT &rhs) {
    return !(lhs == rhs);
}


struct Msg8F0C FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Msg8F0CT NativeTableType;
  typedef Msg8F0CBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Msg8F0CTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TASK_TYPE = 6,
    VT_TASK_NUM = 8,
    VT_TASK_DISPATCH_RESULT = 10,
    VT_TASK_TARGET_IMEI = 12,
    VT_TASK_FILE_MD5 = 14,
    VT_TARGETDEVNAME = 16,
    VT_SITEID = 18,
    VT_TASK_FILE_NAME = 20
  };
  uint16_t id() const {
    return GetField<uint16_t>(VT_ID, 0);
  }
  bool mutate_id(uint16_t _id) {
    return SetField<uint16_t>(VT_ID, _id, 0);
  }
  uint8_t task_type() const {
    return GetField<uint8_t>(VT_TASK_TYPE, 0);
  }
  bool mutate_task_type(uint8_t _task_type) {
    return SetField<uint8_t>(VT_TASK_TYPE, _task_type, 0);
  }
  uint16_t task_num() const {
    return GetField<uint16_t>(VT_TASK_NUM, 0);
  }
  bool mutate_task_num(uint16_t _task_num) {
    return SetField<uint16_t>(VT_TASK_NUM, _task_num, 0);
  }
  TaskDispatchResult task_dispatch_result() const {
    return static_cast<TaskDispatchResult>(GetField<uint8_t>(VT_TASK_DISPATCH_RESULT, 0));
  }
  bool mutate_task_dispatch_result(TaskDispatchResult _task_dispatch_result) {
    return SetField<uint8_t>(VT_TASK_DISPATCH_RESULT, static_cast<uint8_t>(_task_dispatch_result), 0);
  }
  const flatbuffers::String *task_target_imei() const {
    return GetPointer<const flatbuffers::String *>(VT_TASK_TARGET_IMEI);
  }
  flatbuffers::String *mutable_task_target_imei() {
    return GetPointer<flatbuffers::String *>(VT_TASK_TARGET_IMEI);
  }
  const flatbuffers::String *task_file_md5() const {
    return GetPointer<const flatbuffers::String *>(VT_TASK_FILE_MD5);
  }
  flatbuffers::String *mutable_task_file_md5() {
    return GetPointer<flatbuffers::String *>(VT_TASK_FILE_MD5);
  }
  const flatbuffers::String *targetDevName() const {
    return GetPointer<const flatbuffers::String *>(VT_TARGETDEVNAME);
  }
  flatbuffers::String *mutable_targetDevName() {
    return GetPointer<flatbuffers::String *>(VT_TARGETDEVNAME);
  }
  uint16_t siteId() const {
    return GetField<uint16_t>(VT_SITEID, 0);
  }
  bool mutate_siteId(uint16_t _siteId) {
    return SetField<uint16_t>(VT_SITEID, _siteId, 0);
  }
  const flatbuffers::String *task_file_name() const {
    return GetPointer<const flatbuffers::String *>(VT_TASK_FILE_NAME);
  }
  flatbuffers::String *mutable_task_file_name() {
    return GetPointer<flatbuffers::String *>(VT_TASK_FILE_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ID) &&
           VerifyField<uint8_t>(verifier, VT_TASK_TYPE) &&
           VerifyField<uint16_t>(verifier, VT_TASK_NUM) &&
           VerifyField<uint8_t>(verifier, VT_TASK_DISPATCH_RESULT) &&
           VerifyOffset(verifier, VT_TASK_TARGET_IMEI) &&
           verifier.VerifyString(task_target_imei()) &&
           VerifyOffset(verifier, VT_TASK_FILE_MD5) &&
           verifier.VerifyString(task_file_md5()) &&
           VerifyOffset(verifier, VT_TARGETDEVNAME) &&
           verifier.VerifyString(targetDevName()) &&
           VerifyField<uint16_t>(verifier, VT_SITEID) &&
           VerifyOffset(verifier, VT_TASK_FILE_NAME) &&
           verifier.VerifyString(task_file_name()) &&
           verifier.EndTable();
  }
  Msg8F0CT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Msg8F0CT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Msg8F0C> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg8F0CT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Msg8F0CBuilder {
  typedef Msg8F0C Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint16_t id) {
    fbb_.AddElement<uint16_t>(Msg8F0C::VT_ID, id, 0);
  }
  void add_task_type(uint8_t task_type) {
    fbb_.AddElement<uint8_t>(Msg8F0C::VT_TASK_TYPE, task_type, 0);
  }
  void add_task_num(uint16_t task_num) {
    fbb_.AddElement<uint16_t>(Msg8F0C::VT_TASK_NUM, task_num, 0);
  }
  void add_task_dispatch_result(TaskDispatchResult task_dispatch_result) {
    fbb_.AddElement<uint8_t>(Msg8F0C::VT_TASK_DISPATCH_RESULT, static_cast<uint8_t>(task_dispatch_result), 0);
  }
  void add_task_target_imei(flatbuffers::Offset<flatbuffers::String> task_target_imei) {
    fbb_.AddOffset(Msg8F0C::VT_TASK_TARGET_IMEI, task_target_imei);
  }
  void add_task_file_md5(flatbuffers::Offset<flatbuffers::String> task_file_md5) {
    fbb_.AddOffset(Msg8F0C::VT_TASK_FILE_MD5, task_file_md5);
  }
  void add_targetDevName(flatbuffers::Offset<flatbuffers::String> targetDevName) {
    fbb_.AddOffset(Msg8F0C::VT_TARGETDEVNAME, targetDevName);
  }
  void add_siteId(uint16_t siteId) {
    fbb_.AddElement<uint16_t>(Msg8F0C::VT_SITEID, siteId, 0);
  }
  void add_task_file_name(flatbuffers::Offset<flatbuffers::String> task_file_name) {
    fbb_.AddOffset(Msg8F0C::VT_TASK_FILE_NAME, task_file_name);
  }
  explicit Msg8F0CBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Msg8F0C> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Msg8F0C>(end);
    return o;
  }
};

inline flatbuffers::Offset<Msg8F0C> CreateMsg8F0C(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t id = 0,
    uint8_t task_type = 0,
    uint16_t task_num = 0,
    TaskDispatchResult task_dispatch_result = TaskDispatchResult_Unknown,
    flatbuffers::Offset<flatbuffers::String> task_target_imei = 0,
    flatbuffers::Offset<flatbuffers::String> task_file_md5 = 0,
    flatbuffers::Offset<flatbuffers::String> targetDevName = 0,
    uint16_t siteId = 0,
    flatbuffers::Offset<flatbuffers::String> task_file_name = 0) {
  Msg8F0CBuilder builder_(_fbb);
  builder_.add_task_file_name(task_file_name);
  builder_.add_targetDevName(targetDevName);
  builder_.add_task_file_md5(task_file_md5);
  builder_.add_task_target_imei(task_target_imei);
  builder_.add_siteId(siteId);
  builder_.add_task_num(task_num);
  builder_.add_id(id);
  builder_.add_task_dispatch_result(task_dispatch_result);
  builder_.add_task_type(task_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Msg8F0C> CreateMsg8F0CDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t id = 0,
    uint8_t task_type = 0,
    uint16_t task_num = 0,
    TaskDispatchResult task_dispatch_result = TaskDispatchResult_Unknown,
    const char *task_target_imei = nullptr,
    const char *task_file_md5 = nullptr,
    const char *targetDevName = nullptr,
    uint16_t siteId = 0,
    const char *task_file_name = nullptr) {
  auto task_target_imei__ = task_target_imei ? _fbb.CreateString(task_target_imei) : 0;
  auto task_file_md5__ = task_file_md5 ? _fbb.CreateString(task_file_md5) : 0;
  auto targetDevName__ = targetDevName ? _fbb.CreateString(targetDevName) : 0;
  auto task_file_name__ = task_file_name ? _fbb.CreateString(task_file_name) : 0;
  return CreateMsg8F0C(
      _fbb,
      id,
      task_type,
      task_num,
      task_dispatch_result,
      task_target_imei__,
      task_file_md5__,
      targetDevName__,
      siteId,
      task_file_name__);
}

flatbuffers::Offset<Msg8F0C> CreateMsg8F0C(flatbuffers::FlatBufferBuilder &_fbb, const Msg8F0CT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Msg8F0DT : public flatbuffers::NativeTable {
  typedef Msg8F0D TableType;
  uint16_t id;
  uint8_t task_modify_type;
  Msg8F0DT()
      : id(0),
        task_modify_type(0) {
  }
};

inline bool operator==(const Msg8F0DT &lhs, const Msg8F0DT &rhs) {
  return
      (lhs.id == rhs.id) &&
      (lhs.task_modify_type == rhs.task_modify_type);
}

inline bool operator!=(const Msg8F0DT &lhs, const Msg8F0DT &rhs) {
    return !(lhs == rhs);
}


struct Msg8F0D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Msg8F0DT NativeTableType;
  typedef Msg8F0DBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Msg8F0DTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TASK_MODIFY_TYPE = 6
  };
  uint16_t id() const {
    return GetField<uint16_t>(VT_ID, 0);
  }
  bool mutate_id(uint16_t _id) {
    return SetField<uint16_t>(VT_ID, _id, 0);
  }
  uint8_t task_modify_type() const {
    return GetField<uint8_t>(VT_TASK_MODIFY_TYPE, 0);
  }
  bool mutate_task_modify_type(uint8_t _task_modify_type) {
    return SetField<uint8_t>(VT_TASK_MODIFY_TYPE, _task_modify_type, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ID) &&
           VerifyField<uint8_t>(verifier, VT_TASK_MODIFY_TYPE) &&
           verifier.EndTable();
  }
  Msg8F0DT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Msg8F0DT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Msg8F0D> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg8F0DT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Msg8F0DBuilder {
  typedef Msg8F0D Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint16_t id) {
    fbb_.AddElement<uint16_t>(Msg8F0D::VT_ID, id, 0);
  }
  void add_task_modify_type(uint8_t task_modify_type) {
    fbb_.AddElement<uint8_t>(Msg8F0D::VT_TASK_MODIFY_TYPE, task_modify_type, 0);
  }
  explicit Msg8F0DBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Msg8F0D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Msg8F0D>(end);
    return o;
  }
};

inline flatbuffers::Offset<Msg8F0D> CreateMsg8F0D(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t id = 0,
    uint8_t task_modify_type = 0) {
  Msg8F0DBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_task_modify_type(task_modify_type);
  return builder_.Finish();
}

flatbuffers::Offset<Msg8F0D> CreateMsg8F0D(flatbuffers::FlatBufferBuilder &_fbb, const Msg8F0DT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Msg8403T : public flatbuffers::NativeTable {
  typedef Msg8403 TableType;
  uint16_t id;
  uint8_t load_status_from_hmi;
  Msg8403T()
      : id(0),
        load_status_from_hmi(0) {
  }
};

inline bool operator==(const Msg8403T &lhs, const Msg8403T &rhs) {
  return
      (lhs.id == rhs.id) &&
      (lhs.load_status_from_hmi == rhs.load_status_from_hmi);
}

inline bool operator!=(const Msg8403T &lhs, const Msg8403T &rhs) {
    return !(lhs == rhs);
}


struct Msg8403 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Msg8403T NativeTableType;
  typedef Msg8403Builder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Msg8403TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_LOAD_STATUS_FROM_HMI = 6
  };
  uint16_t id() const {
    return GetField<uint16_t>(VT_ID, 0);
  }
  bool mutate_id(uint16_t _id) {
    return SetField<uint16_t>(VT_ID, _id, 0);
  }
  uint8_t load_status_from_hmi() const {
    return GetField<uint8_t>(VT_LOAD_STATUS_FROM_HMI, 0);
  }
  bool mutate_load_status_from_hmi(uint8_t _load_status_from_hmi) {
    return SetField<uint8_t>(VT_LOAD_STATUS_FROM_HMI, _load_status_from_hmi, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ID) &&
           VerifyField<uint8_t>(verifier, VT_LOAD_STATUS_FROM_HMI) &&
           verifier.EndTable();
  }
  Msg8403T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Msg8403T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Msg8403> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg8403T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Msg8403Builder {
  typedef Msg8403 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint16_t id) {
    fbb_.AddElement<uint16_t>(Msg8403::VT_ID, id, 0);
  }
  void add_load_status_from_hmi(uint8_t load_status_from_hmi) {
    fbb_.AddElement<uint8_t>(Msg8403::VT_LOAD_STATUS_FROM_HMI, load_status_from_hmi, 0);
  }
  explicit Msg8403Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Msg8403> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Msg8403>(end);
    return o;
  }
};

inline flatbuffers::Offset<Msg8403> CreateMsg8403(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t id = 0,
    uint8_t load_status_from_hmi = 0) {
  Msg8403Builder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_load_status_from_hmi(load_status_from_hmi);
  return builder_.Finish();
}

flatbuffers::Offset<Msg8403> CreateMsg8403(flatbuffers::FlatBufferBuilder &_fbb, const Msg8403T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MovementAuthorityT : public flatbuffers::NativeTable {
  typedef MovementAuthority TableType;
  uint16_t road_id;
  double iLatitude;
  double iLongitude;
  std::string task_file_name;
  std::string task_file_path;
  uint32_t terminal;
  TaskFileDownloadResult task_file_download_result;
  std::string task_file_md5;
  MovementAuthorityT()
      : road_id(0),
        iLatitude(0.0),
        iLongitude(0.0),
        terminal(0),
        task_file_download_result(TaskFileDownloadResult_Unknown) {
  }
};

inline bool operator==(const MovementAuthorityT &lhs, const MovementAuthorityT &rhs) {
  return
      (lhs.road_id == rhs.road_id) &&
      (lhs.iLatitude == rhs.iLatitude) &&
      (lhs.iLongitude == rhs.iLongitude) &&
      (lhs.task_file_name == rhs.task_file_name) &&
      (lhs.task_file_path == rhs.task_file_path) &&
      (lhs.terminal == rhs.terminal) &&
      (lhs.task_file_download_result == rhs.task_file_download_result) &&
      (lhs.task_file_md5 == rhs.task_file_md5);
}

inline bool operator!=(const MovementAuthorityT &lhs, const MovementAuthorityT &rhs) {
    return !(lhs == rhs);
}


struct MovementAuthority FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MovementAuthorityT NativeTableType;
  typedef MovementAuthorityBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MovementAuthorityTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ROAD_ID = 4,
    VT_ILATITUDE = 6,
    VT_ILONGITUDE = 8,
    VT_TASK_FILE_NAME = 10,
    VT_TASK_FILE_PATH = 12,
    VT_TERMINAL = 14,
    VT_TASK_FILE_DOWNLOAD_RESULT = 16,
    VT_TASK_FILE_MD5 = 18
  };
  uint16_t road_id() const {
    return GetField<uint16_t>(VT_ROAD_ID, 0);
  }
  bool mutate_road_id(uint16_t _road_id) {
    return SetField<uint16_t>(VT_ROAD_ID, _road_id, 0);
  }
  double iLatitude() const {
    return GetField<double>(VT_ILATITUDE, 0.0);
  }
  bool mutate_iLatitude(double _iLatitude) {
    return SetField<double>(VT_ILATITUDE, _iLatitude, 0.0);
  }
  double iLongitude() const {
    return GetField<double>(VT_ILONGITUDE, 0.0);
  }
  bool mutate_iLongitude(double _iLongitude) {
    return SetField<double>(VT_ILONGITUDE, _iLongitude, 0.0);
  }
  const flatbuffers::String *task_file_name() const {
    return GetPointer<const flatbuffers::String *>(VT_TASK_FILE_NAME);
  }
  flatbuffers::String *mutable_task_file_name() {
    return GetPointer<flatbuffers::String *>(VT_TASK_FILE_NAME);
  }
  const flatbuffers::String *task_file_path() const {
    return GetPointer<const flatbuffers::String *>(VT_TASK_FILE_PATH);
  }
  flatbuffers::String *mutable_task_file_path() {
    return GetPointer<flatbuffers::String *>(VT_TASK_FILE_PATH);
  }
  uint32_t terminal() const {
    return GetField<uint32_t>(VT_TERMINAL, 0);
  }
  bool mutate_terminal(uint32_t _terminal) {
    return SetField<uint32_t>(VT_TERMINAL, _terminal, 0);
  }
  TaskFileDownloadResult task_file_download_result() const {
    return static_cast<TaskFileDownloadResult>(GetField<uint8_t>(VT_TASK_FILE_DOWNLOAD_RESULT, 0));
  }
  bool mutate_task_file_download_result(TaskFileDownloadResult _task_file_download_result) {
    return SetField<uint8_t>(VT_TASK_FILE_DOWNLOAD_RESULT, static_cast<uint8_t>(_task_file_download_result), 0);
  }
  const flatbuffers::String *task_file_md5() const {
    return GetPointer<const flatbuffers::String *>(VT_TASK_FILE_MD5);
  }
  flatbuffers::String *mutable_task_file_md5() {
    return GetPointer<flatbuffers::String *>(VT_TASK_FILE_MD5);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ROAD_ID) &&
           VerifyField<double>(verifier, VT_ILATITUDE) &&
           VerifyField<double>(verifier, VT_ILONGITUDE) &&
           VerifyOffset(verifier, VT_TASK_FILE_NAME) &&
           verifier.VerifyString(task_file_name()) &&
           VerifyOffset(verifier, VT_TASK_FILE_PATH) &&
           verifier.VerifyString(task_file_path()) &&
           VerifyField<uint32_t>(verifier, VT_TERMINAL) &&
           VerifyField<uint8_t>(verifier, VT_TASK_FILE_DOWNLOAD_RESULT) &&
           VerifyOffset(verifier, VT_TASK_FILE_MD5) &&
           verifier.VerifyString(task_file_md5()) &&
           verifier.EndTable();
  }
  MovementAuthorityT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MovementAuthorityT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MovementAuthority> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MovementAuthorityT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MovementAuthorityBuilder {
  typedef MovementAuthority Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_road_id(uint16_t road_id) {
    fbb_.AddElement<uint16_t>(MovementAuthority::VT_ROAD_ID, road_id, 0);
  }
  void add_iLatitude(double iLatitude) {
    fbb_.AddElement<double>(MovementAuthority::VT_ILATITUDE, iLatitude, 0.0);
  }
  void add_iLongitude(double iLongitude) {
    fbb_.AddElement<double>(MovementAuthority::VT_ILONGITUDE, iLongitude, 0.0);
  }
  void add_task_file_name(flatbuffers::Offset<flatbuffers::String> task_file_name) {
    fbb_.AddOffset(MovementAuthority::VT_TASK_FILE_NAME, task_file_name);
  }
  void add_task_file_path(flatbuffers::Offset<flatbuffers::String> task_file_path) {
    fbb_.AddOffset(MovementAuthority::VT_TASK_FILE_PATH, task_file_path);
  }
  void add_terminal(uint32_t terminal) {
    fbb_.AddElement<uint32_t>(MovementAuthority::VT_TERMINAL, terminal, 0);
  }
  void add_task_file_download_result(TaskFileDownloadResult task_file_download_result) {
    fbb_.AddElement<uint8_t>(MovementAuthority::VT_TASK_FILE_DOWNLOAD_RESULT, static_cast<uint8_t>(task_file_download_result), 0);
  }
  void add_task_file_md5(flatbuffers::Offset<flatbuffers::String> task_file_md5) {
    fbb_.AddOffset(MovementAuthority::VT_TASK_FILE_MD5, task_file_md5);
  }
  explicit MovementAuthorityBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MovementAuthority> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MovementAuthority>(end);
    return o;
  }
};

inline flatbuffers::Offset<MovementAuthority> CreateMovementAuthority(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t road_id = 0,
    double iLatitude = 0.0,
    double iLongitude = 0.0,
    flatbuffers::Offset<flatbuffers::String> task_file_name = 0,
    flatbuffers::Offset<flatbuffers::String> task_file_path = 0,
    uint32_t terminal = 0,
    TaskFileDownloadResult task_file_download_result = TaskFileDownloadResult_Unknown,
    flatbuffers::Offset<flatbuffers::String> task_file_md5 = 0) {
  MovementAuthorityBuilder builder_(_fbb);
  builder_.add_iLongitude(iLongitude);
  builder_.add_iLatitude(iLatitude);
  builder_.add_task_file_md5(task_file_md5);
  builder_.add_terminal(terminal);
  builder_.add_task_file_path(task_file_path);
  builder_.add_task_file_name(task_file_name);
  builder_.add_road_id(road_id);
  builder_.add_task_file_download_result(task_file_download_result);
  return builder_.Finish();
}

inline flatbuffers::Offset<MovementAuthority> CreateMovementAuthorityDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t road_id = 0,
    double iLatitude = 0.0,
    double iLongitude = 0.0,
    const char *task_file_name = nullptr,
    const char *task_file_path = nullptr,
    uint32_t terminal = 0,
    TaskFileDownloadResult task_file_download_result = TaskFileDownloadResult_Unknown,
    const char *task_file_md5 = nullptr) {
  auto task_file_name__ = task_file_name ? _fbb.CreateString(task_file_name) : 0;
  auto task_file_path__ = task_file_path ? _fbb.CreateString(task_file_path) : 0;
  auto task_file_md5__ = task_file_md5 ? _fbb.CreateString(task_file_md5) : 0;
  return CreateMovementAuthority(
      _fbb,
      road_id,
      iLatitude,
      iLongitude,
      task_file_name__,
      task_file_path__,
      terminal,
      task_file_download_result,
      task_file_md5__);
}

flatbuffers::Offset<MovementAuthority> CreateMovementAuthority(flatbuffers::FlatBufferBuilder &_fbb, const MovementAuthorityT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Msg8F0FT : public flatbuffers::NativeTable {
  typedef Msg8F0F TableType;
  uint16_t id;
  uint8_t length;
  std::vector<std::unique_ptr<MovementAuthorityT>> move_authority;
  Msg8F0FT()
      : id(0),
        length(0) {
  }
};

inline bool operator==(const Msg8F0FT &lhs, const Msg8F0FT &rhs) {
  return
      (lhs.id == rhs.id) &&
      (lhs.length == rhs.length) &&
      (lhs.move_authority == rhs.move_authority);
}

inline bool operator!=(const Msg8F0FT &lhs, const Msg8F0FT &rhs) {
    return !(lhs == rhs);
}


struct Msg8F0F FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Msg8F0FT NativeTableType;
  typedef Msg8F0FBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Msg8F0FTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_LENGTH = 6,
    VT_MOVE_AUTHORITY = 8
  };
  uint16_t id() const {
    return GetField<uint16_t>(VT_ID, 0);
  }
  bool mutate_id(uint16_t _id) {
    return SetField<uint16_t>(VT_ID, _id, 0);
  }
  uint8_t length() const {
    return GetField<uint8_t>(VT_LENGTH, 0);
  }
  bool mutate_length(uint8_t _length) {
    return SetField<uint8_t>(VT_LENGTH, _length, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<MovementAuthority>> *move_authority() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<MovementAuthority>> *>(VT_MOVE_AUTHORITY);
  }
  flatbuffers::Vector<flatbuffers::Offset<MovementAuthority>> *mutable_move_authority() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<MovementAuthority>> *>(VT_MOVE_AUTHORITY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ID) &&
           VerifyField<uint8_t>(verifier, VT_LENGTH) &&
           VerifyOffset(verifier, VT_MOVE_AUTHORITY) &&
           verifier.VerifyVector(move_authority()) &&
           verifier.VerifyVectorOfTables(move_authority()) &&
           verifier.EndTable();
  }
  Msg8F0FT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Msg8F0FT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Msg8F0F> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg8F0FT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Msg8F0FBuilder {
  typedef Msg8F0F Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint16_t id) {
    fbb_.AddElement<uint16_t>(Msg8F0F::VT_ID, id, 0);
  }
  void add_length(uint8_t length) {
    fbb_.AddElement<uint8_t>(Msg8F0F::VT_LENGTH, length, 0);
  }
  void add_move_authority(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MovementAuthority>>> move_authority) {
    fbb_.AddOffset(Msg8F0F::VT_MOVE_AUTHORITY, move_authority);
  }
  explicit Msg8F0FBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Msg8F0F> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Msg8F0F>(end);
    return o;
  }
};

inline flatbuffers::Offset<Msg8F0F> CreateMsg8F0F(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t id = 0,
    uint8_t length = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MovementAuthority>>> move_authority = 0) {
  Msg8F0FBuilder builder_(_fbb);
  builder_.add_move_authority(move_authority);
  builder_.add_id(id);
  builder_.add_length(length);
  return builder_.Finish();
}

inline flatbuffers::Offset<Msg8F0F> CreateMsg8F0FDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t id = 0,
    uint8_t length = 0,
    const std::vector<flatbuffers::Offset<MovementAuthority>> *move_authority = nullptr) {
  auto move_authority__ = move_authority ? _fbb.CreateVector<flatbuffers::Offset<MovementAuthority>>(*move_authority) : 0;
  return CreateMsg8F0F(
      _fbb,
      id,
      length,
      move_authority__);
}

flatbuffers::Offset<Msg8F0F> CreateMsg8F0F(flatbuffers::FlatBufferBuilder &_fbb, const Msg8F0FT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Msg8F10T : public flatbuffers::NativeTable {
  typedef Msg8F10 TableType;
  uint16_t id;
  uint16_t task_num;
  std::string boundary_file_md5;
  std::string boundary_file_name;
  Msg8F10T()
      : id(0),
        task_num(0) {
  }
};

inline bool operator==(const Msg8F10T &lhs, const Msg8F10T &rhs) {
  return
      (lhs.id == rhs.id) &&
      (lhs.task_num == rhs.task_num) &&
      (lhs.boundary_file_md5 == rhs.boundary_file_md5) &&
      (lhs.boundary_file_name == rhs.boundary_file_name);
}

inline bool operator!=(const Msg8F10T &lhs, const Msg8F10T &rhs) {
    return !(lhs == rhs);
}


struct Msg8F10 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Msg8F10T NativeTableType;
  typedef Msg8F10Builder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Msg8F10TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TASK_NUM = 6,
    VT_BOUNDARY_FILE_MD5 = 8,
    VT_BOUNDARY_FILE_NAME = 10
  };
  uint16_t id() const {
    return GetField<uint16_t>(VT_ID, 0);
  }
  bool mutate_id(uint16_t _id) {
    return SetField<uint16_t>(VT_ID, _id, 0);
  }
  uint16_t task_num() const {
    return GetField<uint16_t>(VT_TASK_NUM, 0);
  }
  bool mutate_task_num(uint16_t _task_num) {
    return SetField<uint16_t>(VT_TASK_NUM, _task_num, 0);
  }
  const flatbuffers::String *boundary_file_md5() const {
    return GetPointer<const flatbuffers::String *>(VT_BOUNDARY_FILE_MD5);
  }
  flatbuffers::String *mutable_boundary_file_md5() {
    return GetPointer<flatbuffers::String *>(VT_BOUNDARY_FILE_MD5);
  }
  const flatbuffers::String *boundary_file_name() const {
    return GetPointer<const flatbuffers::String *>(VT_BOUNDARY_FILE_NAME);
  }
  flatbuffers::String *mutable_boundary_file_name() {
    return GetPointer<flatbuffers::String *>(VT_BOUNDARY_FILE_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ID) &&
           VerifyField<uint16_t>(verifier, VT_TASK_NUM) &&
           VerifyOffset(verifier, VT_BOUNDARY_FILE_MD5) &&
           verifier.VerifyString(boundary_file_md5()) &&
           VerifyOffset(verifier, VT_BOUNDARY_FILE_NAME) &&
           verifier.VerifyString(boundary_file_name()) &&
           verifier.EndTable();
  }
  Msg8F10T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Msg8F10T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Msg8F10> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg8F10T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Msg8F10Builder {
  typedef Msg8F10 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint16_t id) {
    fbb_.AddElement<uint16_t>(Msg8F10::VT_ID, id, 0);
  }
  void add_task_num(uint16_t task_num) {
    fbb_.AddElement<uint16_t>(Msg8F10::VT_TASK_NUM, task_num, 0);
  }
  void add_boundary_file_md5(flatbuffers::Offset<flatbuffers::String> boundary_file_md5) {
    fbb_.AddOffset(Msg8F10::VT_BOUNDARY_FILE_MD5, boundary_file_md5);
  }
  void add_boundary_file_name(flatbuffers::Offset<flatbuffers::String> boundary_file_name) {
    fbb_.AddOffset(Msg8F10::VT_BOUNDARY_FILE_NAME, boundary_file_name);
  }
  explicit Msg8F10Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Msg8F10> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Msg8F10>(end);
    return o;
  }
};

inline flatbuffers::Offset<Msg8F10> CreateMsg8F10(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t id = 0,
    uint16_t task_num = 0,
    flatbuffers::Offset<flatbuffers::String> boundary_file_md5 = 0,
    flatbuffers::Offset<flatbuffers::String> boundary_file_name = 0) {
  Msg8F10Builder builder_(_fbb);
  builder_.add_boundary_file_name(boundary_file_name);
  builder_.add_boundary_file_md5(boundary_file_md5);
  builder_.add_task_num(task_num);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Msg8F10> CreateMsg8F10Direct(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t id = 0,
    uint16_t task_num = 0,
    const char *boundary_file_md5 = nullptr,
    const char *boundary_file_name = nullptr) {
  auto boundary_file_md5__ = boundary_file_md5 ? _fbb.CreateString(boundary_file_md5) : 0;
  auto boundary_file_name__ = boundary_file_name ? _fbb.CreateString(boundary_file_name) : 0;
  return CreateMsg8F10(
      _fbb,
      id,
      task_num,
      boundary_file_md5__,
      boundary_file_name__);
}

flatbuffers::Offset<Msg8F10> CreateMsg8F10(flatbuffers::FlatBufferBuilder &_fbb, const Msg8F10T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Msg8C01T : public flatbuffers::NativeTable {
  typedef Msg8C01 TableType;
  uint16_t serialNum;
  uint16_t cmdId;
  uint8_t result;
  Msg8C01T()
      : serialNum(0),
        cmdId(0),
        result(0) {
  }
};

inline bool operator==(const Msg8C01T &lhs, const Msg8C01T &rhs) {
  return
      (lhs.serialNum == rhs.serialNum) &&
      (lhs.cmdId == rhs.cmdId) &&
      (lhs.result == rhs.result);
}

inline bool operator!=(const Msg8C01T &lhs, const Msg8C01T &rhs) {
    return !(lhs == rhs);
}


struct Msg8C01 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Msg8C01T NativeTableType;
  typedef Msg8C01Builder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Msg8C01TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SERIALNUM = 4,
    VT_CMDID = 6,
    VT_RESULT = 8
  };
  uint16_t serialNum() const {
    return GetField<uint16_t>(VT_SERIALNUM, 0);
  }
  bool mutate_serialNum(uint16_t _serialNum) {
    return SetField<uint16_t>(VT_SERIALNUM, _serialNum, 0);
  }
  uint16_t cmdId() const {
    return GetField<uint16_t>(VT_CMDID, 0);
  }
  bool mutate_cmdId(uint16_t _cmdId) {
    return SetField<uint16_t>(VT_CMDID, _cmdId, 0);
  }
  uint8_t result() const {
    return GetField<uint8_t>(VT_RESULT, 0);
  }
  bool mutate_result(uint8_t _result) {
    return SetField<uint8_t>(VT_RESULT, _result, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_SERIALNUM) &&
           VerifyField<uint16_t>(verifier, VT_CMDID) &&
           VerifyField<uint8_t>(verifier, VT_RESULT) &&
           verifier.EndTable();
  }
  Msg8C01T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Msg8C01T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Msg8C01> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg8C01T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Msg8C01Builder {
  typedef Msg8C01 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_serialNum(uint16_t serialNum) {
    fbb_.AddElement<uint16_t>(Msg8C01::VT_SERIALNUM, serialNum, 0);
  }
  void add_cmdId(uint16_t cmdId) {
    fbb_.AddElement<uint16_t>(Msg8C01::VT_CMDID, cmdId, 0);
  }
  void add_result(uint8_t result) {
    fbb_.AddElement<uint8_t>(Msg8C01::VT_RESULT, result, 0);
  }
  explicit Msg8C01Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Msg8C01> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Msg8C01>(end);
    return o;
  }
};

inline flatbuffers::Offset<Msg8C01> CreateMsg8C01(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t serialNum = 0,
    uint16_t cmdId = 0,
    uint8_t result = 0) {
  Msg8C01Builder builder_(_fbb);
  builder_.add_cmdId(cmdId);
  builder_.add_serialNum(serialNum);
  builder_.add_result(result);
  return builder_.Finish();
}

flatbuffers::Offset<Msg8C01> CreateMsg8C01(flatbuffers::FlatBufferBuilder &_fbb, const Msg8C01T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Msg8F04T : public flatbuffers::NativeTable {
  typedef Msg8F04 TableType;
  uint16_t materCode;
  Msg8F04T()
      : materCode(0) {
  }
};

inline bool operator==(const Msg8F04T &lhs, const Msg8F04T &rhs) {
  return
      (lhs.materCode == rhs.materCode);
}

inline bool operator!=(const Msg8F04T &lhs, const Msg8F04T &rhs) {
    return !(lhs == rhs);
}


struct Msg8F04 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Msg8F04T NativeTableType;
  typedef Msg8F04Builder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Msg8F04TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MATERCODE = 4
  };
  uint16_t materCode() const {
    return GetField<uint16_t>(VT_MATERCODE, 0);
  }
  bool mutate_materCode(uint16_t _materCode) {
    return SetField<uint16_t>(VT_MATERCODE, _materCode, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_MATERCODE) &&
           verifier.EndTable();
  }
  Msg8F04T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Msg8F04T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Msg8F04> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg8F04T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Msg8F04Builder {
  typedef Msg8F04 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_materCode(uint16_t materCode) {
    fbb_.AddElement<uint16_t>(Msg8F04::VT_MATERCODE, materCode, 0);
  }
  explicit Msg8F04Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Msg8F04> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Msg8F04>(end);
    return o;
  }
};

inline flatbuffers::Offset<Msg8F04> CreateMsg8F04(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t materCode = 0) {
  Msg8F04Builder builder_(_fbb);
  builder_.add_materCode(materCode);
  return builder_.Finish();
}

flatbuffers::Offset<Msg8F04> CreateMsg8F04(flatbuffers::FlatBufferBuilder &_fbb, const Msg8F04T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Msg8F0AT : public flatbuffers::NativeTable {
  typedef Msg8F0A TableType;
  uint8_t fileType;
  uint8_t fileArea;
  uint8_t result;
  std::string targetImei;
  std::string md5;
  std::string targetDevName;
  std::string filePath;
  Msg8F0AT()
      : fileType(0),
        fileArea(0),
        result(0) {
  }
};

inline bool operator==(const Msg8F0AT &lhs, const Msg8F0AT &rhs) {
  return
      (lhs.fileType == rhs.fileType) &&
      (lhs.fileArea == rhs.fileArea) &&
      (lhs.result == rhs.result) &&
      (lhs.targetImei == rhs.targetImei) &&
      (lhs.md5 == rhs.md5) &&
      (lhs.targetDevName == rhs.targetDevName) &&
      (lhs.filePath == rhs.filePath);
}

inline bool operator!=(const Msg8F0AT &lhs, const Msg8F0AT &rhs) {
    return !(lhs == rhs);
}


struct Msg8F0A FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Msg8F0AT NativeTableType;
  typedef Msg8F0ABuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Msg8F0ATypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FILETYPE = 4,
    VT_FILEAREA = 6,
    VT_RESULT = 8,
    VT_TARGETIMEI = 10,
    VT_MD5 = 12,
    VT_TARGETDEVNAME = 14,
    VT_FILEPATH = 16
  };
  uint8_t fileType() const {
    return GetField<uint8_t>(VT_FILETYPE, 0);
  }
  bool mutate_fileType(uint8_t _fileType) {
    return SetField<uint8_t>(VT_FILETYPE, _fileType, 0);
  }
  uint8_t fileArea() const {
    return GetField<uint8_t>(VT_FILEAREA, 0);
  }
  bool mutate_fileArea(uint8_t _fileArea) {
    return SetField<uint8_t>(VT_FILEAREA, _fileArea, 0);
  }
  uint8_t result() const {
    return GetField<uint8_t>(VT_RESULT, 0);
  }
  bool mutate_result(uint8_t _result) {
    return SetField<uint8_t>(VT_RESULT, _result, 0);
  }
  const flatbuffers::String *targetImei() const {
    return GetPointer<const flatbuffers::String *>(VT_TARGETIMEI);
  }
  flatbuffers::String *mutable_targetImei() {
    return GetPointer<flatbuffers::String *>(VT_TARGETIMEI);
  }
  const flatbuffers::String *md5() const {
    return GetPointer<const flatbuffers::String *>(VT_MD5);
  }
  flatbuffers::String *mutable_md5() {
    return GetPointer<flatbuffers::String *>(VT_MD5);
  }
  const flatbuffers::String *targetDevName() const {
    return GetPointer<const flatbuffers::String *>(VT_TARGETDEVNAME);
  }
  flatbuffers::String *mutable_targetDevName() {
    return GetPointer<flatbuffers::String *>(VT_TARGETDEVNAME);
  }
  const flatbuffers::String *filePath() const {
    return GetPointer<const flatbuffers::String *>(VT_FILEPATH);
  }
  flatbuffers::String *mutable_filePath() {
    return GetPointer<flatbuffers::String *>(VT_FILEPATH);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_FILETYPE) &&
           VerifyField<uint8_t>(verifier, VT_FILEAREA) &&
           VerifyField<uint8_t>(verifier, VT_RESULT) &&
           VerifyOffset(verifier, VT_TARGETIMEI) &&
           verifier.VerifyString(targetImei()) &&
           VerifyOffset(verifier, VT_MD5) &&
           verifier.VerifyString(md5()) &&
           VerifyOffset(verifier, VT_TARGETDEVNAME) &&
           verifier.VerifyString(targetDevName()) &&
           VerifyOffset(verifier, VT_FILEPATH) &&
           verifier.VerifyString(filePath()) &&
           verifier.EndTable();
  }
  Msg8F0AT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Msg8F0AT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Msg8F0A> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg8F0AT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Msg8F0ABuilder {
  typedef Msg8F0A Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fileType(uint8_t fileType) {
    fbb_.AddElement<uint8_t>(Msg8F0A::VT_FILETYPE, fileType, 0);
  }
  void add_fileArea(uint8_t fileArea) {
    fbb_.AddElement<uint8_t>(Msg8F0A::VT_FILEAREA, fileArea, 0);
  }
  void add_result(uint8_t result) {
    fbb_.AddElement<uint8_t>(Msg8F0A::VT_RESULT, result, 0);
  }
  void add_targetImei(flatbuffers::Offset<flatbuffers::String> targetImei) {
    fbb_.AddOffset(Msg8F0A::VT_TARGETIMEI, targetImei);
  }
  void add_md5(flatbuffers::Offset<flatbuffers::String> md5) {
    fbb_.AddOffset(Msg8F0A::VT_MD5, md5);
  }
  void add_targetDevName(flatbuffers::Offset<flatbuffers::String> targetDevName) {
    fbb_.AddOffset(Msg8F0A::VT_TARGETDEVNAME, targetDevName);
  }
  void add_filePath(flatbuffers::Offset<flatbuffers::String> filePath) {
    fbb_.AddOffset(Msg8F0A::VT_FILEPATH, filePath);
  }
  explicit Msg8F0ABuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Msg8F0A> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Msg8F0A>(end);
    return o;
  }
};

inline flatbuffers::Offset<Msg8F0A> CreateMsg8F0A(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t fileType = 0,
    uint8_t fileArea = 0,
    uint8_t result = 0,
    flatbuffers::Offset<flatbuffers::String> targetImei = 0,
    flatbuffers::Offset<flatbuffers::String> md5 = 0,
    flatbuffers::Offset<flatbuffers::String> targetDevName = 0,
    flatbuffers::Offset<flatbuffers::String> filePath = 0) {
  Msg8F0ABuilder builder_(_fbb);
  builder_.add_filePath(filePath);
  builder_.add_targetDevName(targetDevName);
  builder_.add_md5(md5);
  builder_.add_targetImei(targetImei);
  builder_.add_result(result);
  builder_.add_fileArea(fileArea);
  builder_.add_fileType(fileType);
  return builder_.Finish();
}

inline flatbuffers::Offset<Msg8F0A> CreateMsg8F0ADirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t fileType = 0,
    uint8_t fileArea = 0,
    uint8_t result = 0,
    const char *targetImei = nullptr,
    const char *md5 = nullptr,
    const char *targetDevName = nullptr,
    const char *filePath = nullptr) {
  auto targetImei__ = targetImei ? _fbb.CreateString(targetImei) : 0;
  auto md5__ = md5 ? _fbb.CreateString(md5) : 0;
  auto targetDevName__ = targetDevName ? _fbb.CreateString(targetDevName) : 0;
  auto filePath__ = filePath ? _fbb.CreateString(filePath) : 0;
  return CreateMsg8F0A(
      _fbb,
      fileType,
      fileArea,
      result,
      targetImei__,
      md5__,
      targetDevName__,
      filePath__);
}

flatbuffers::Offset<Msg8F0A> CreateMsg8F0A(flatbuffers::FlatBufferBuilder &_fbb, const Msg8F0AT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Msg8F09T : public flatbuffers::NativeTable {
  typedef Msg8F09 TableType;
  uint8_t remoteid;
  Msg8F09T()
      : remoteid(0) {
  }
};

inline bool operator==(const Msg8F09T &lhs, const Msg8F09T &rhs) {
  return
      (lhs.remoteid == rhs.remoteid);
}

inline bool operator!=(const Msg8F09T &lhs, const Msg8F09T &rhs) {
    return !(lhs == rhs);
}


struct Msg8F09 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Msg8F09T NativeTableType;
  typedef Msg8F09Builder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Msg8F09TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REMOTEID = 4
  };
  uint8_t remoteid() const {
    return GetField<uint8_t>(VT_REMOTEID, 0);
  }
  bool mutate_remoteid(uint8_t _remoteid) {
    return SetField<uint8_t>(VT_REMOTEID, _remoteid, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_REMOTEID) &&
           verifier.EndTable();
  }
  Msg8F09T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Msg8F09T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Msg8F09> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg8F09T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Msg8F09Builder {
  typedef Msg8F09 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_remoteid(uint8_t remoteid) {
    fbb_.AddElement<uint8_t>(Msg8F09::VT_REMOTEID, remoteid, 0);
  }
  explicit Msg8F09Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Msg8F09> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Msg8F09>(end);
    return o;
  }
};

inline flatbuffers::Offset<Msg8F09> CreateMsg8F09(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t remoteid = 0) {
  Msg8F09Builder builder_(_fbb);
  builder_.add_remoteid(remoteid);
  return builder_.Finish();
}

flatbuffers::Offset<Msg8F09> CreateMsg8F09(flatbuffers::FlatBufferBuilder &_fbb, const Msg8F09T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GroupStatusListT : public flatbuffers::NativeTable {
  typedef GroupStatusList TableType;
  uint8_t type;
  uint16_t groupNumber;
  uint16_t stopNumber;
  uint8_t stop_group_status;
  uint8_t isOccupied;
  uint8_t task_status;
  uint8_t drivingMode;
  std::string deviceImei;
  std::string deviceName;
  GroupStatusListT()
      : type(0),
        groupNumber(0),
        stopNumber(0),
        stop_group_status(0),
        isOccupied(0),
        task_status(0),
        drivingMode(0) {
  }
};

inline bool operator==(const GroupStatusListT &lhs, const GroupStatusListT &rhs) {
  return
      (lhs.type == rhs.type) &&
      (lhs.groupNumber == rhs.groupNumber) &&
      (lhs.stopNumber == rhs.stopNumber) &&
      (lhs.stop_group_status == rhs.stop_group_status) &&
      (lhs.isOccupied == rhs.isOccupied) &&
      (lhs.task_status == rhs.task_status) &&
      (lhs.drivingMode == rhs.drivingMode) &&
      (lhs.deviceImei == rhs.deviceImei) &&
      (lhs.deviceName == rhs.deviceName);
}

inline bool operator!=(const GroupStatusListT &lhs, const GroupStatusListT &rhs) {
    return !(lhs == rhs);
}


struct GroupStatusList FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GroupStatusListT NativeTableType;
  typedef GroupStatusListBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return GroupStatusListTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_GROUPNUMBER = 6,
    VT_STOPNUMBER = 8,
    VT_STOP_GROUP_STATUS = 10,
    VT_ISOCCUPIED = 12,
    VT_TASK_STATUS = 14,
    VT_DRIVINGMODE = 16,
    VT_DEVICEIMEI = 18,
    VT_DEVICENAME = 20
  };
  uint8_t type() const {
    return GetField<uint8_t>(VT_TYPE, 0);
  }
  bool mutate_type(uint8_t _type) {
    return SetField<uint8_t>(VT_TYPE, _type, 0);
  }
  uint16_t groupNumber() const {
    return GetField<uint16_t>(VT_GROUPNUMBER, 0);
  }
  bool mutate_groupNumber(uint16_t _groupNumber) {
    return SetField<uint16_t>(VT_GROUPNUMBER, _groupNumber, 0);
  }
  uint16_t stopNumber() const {
    return GetField<uint16_t>(VT_STOPNUMBER, 0);
  }
  bool mutate_stopNumber(uint16_t _stopNumber) {
    return SetField<uint16_t>(VT_STOPNUMBER, _stopNumber, 0);
  }
  uint8_t stop_group_status() const {
    return GetField<uint8_t>(VT_STOP_GROUP_STATUS, 0);
  }
  bool mutate_stop_group_status(uint8_t _stop_group_status) {
    return SetField<uint8_t>(VT_STOP_GROUP_STATUS, _stop_group_status, 0);
  }
  uint8_t isOccupied() const {
    return GetField<uint8_t>(VT_ISOCCUPIED, 0);
  }
  bool mutate_isOccupied(uint8_t _isOccupied) {
    return SetField<uint8_t>(VT_ISOCCUPIED, _isOccupied, 0);
  }
  uint8_t task_status() const {
    return GetField<uint8_t>(VT_TASK_STATUS, 0);
  }
  bool mutate_task_status(uint8_t _task_status) {
    return SetField<uint8_t>(VT_TASK_STATUS, _task_status, 0);
  }
  uint8_t drivingMode() const {
    return GetField<uint8_t>(VT_DRIVINGMODE, 0);
  }
  bool mutate_drivingMode(uint8_t _drivingMode) {
    return SetField<uint8_t>(VT_DRIVINGMODE, _drivingMode, 0);
  }
  const flatbuffers::String *deviceImei() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEIMEI);
  }
  flatbuffers::String *mutable_deviceImei() {
    return GetPointer<flatbuffers::String *>(VT_DEVICEIMEI);
  }
  const flatbuffers::String *deviceName() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICENAME);
  }
  flatbuffers::String *mutable_deviceName() {
    return GetPointer<flatbuffers::String *>(VT_DEVICENAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TYPE) &&
           VerifyField<uint16_t>(verifier, VT_GROUPNUMBER) &&
           VerifyField<uint16_t>(verifier, VT_STOPNUMBER) &&
           VerifyField<uint8_t>(verifier, VT_STOP_GROUP_STATUS) &&
           VerifyField<uint8_t>(verifier, VT_ISOCCUPIED) &&
           VerifyField<uint8_t>(verifier, VT_TASK_STATUS) &&
           VerifyField<uint8_t>(verifier, VT_DRIVINGMODE) &&
           VerifyOffset(verifier, VT_DEVICEIMEI) &&
           verifier.VerifyString(deviceImei()) &&
           VerifyOffset(verifier, VT_DEVICENAME) &&
           verifier.VerifyString(deviceName()) &&
           verifier.EndTable();
  }
  GroupStatusListT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GroupStatusListT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GroupStatusList> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GroupStatusListT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GroupStatusListBuilder {
  typedef GroupStatusList Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(uint8_t type) {
    fbb_.AddElement<uint8_t>(GroupStatusList::VT_TYPE, type, 0);
  }
  void add_groupNumber(uint16_t groupNumber) {
    fbb_.AddElement<uint16_t>(GroupStatusList::VT_GROUPNUMBER, groupNumber, 0);
  }
  void add_stopNumber(uint16_t stopNumber) {
    fbb_.AddElement<uint16_t>(GroupStatusList::VT_STOPNUMBER, stopNumber, 0);
  }
  void add_stop_group_status(uint8_t stop_group_status) {
    fbb_.AddElement<uint8_t>(GroupStatusList::VT_STOP_GROUP_STATUS, stop_group_status, 0);
  }
  void add_isOccupied(uint8_t isOccupied) {
    fbb_.AddElement<uint8_t>(GroupStatusList::VT_ISOCCUPIED, isOccupied, 0);
  }
  void add_task_status(uint8_t task_status) {
    fbb_.AddElement<uint8_t>(GroupStatusList::VT_TASK_STATUS, task_status, 0);
  }
  void add_drivingMode(uint8_t drivingMode) {
    fbb_.AddElement<uint8_t>(GroupStatusList::VT_DRIVINGMODE, drivingMode, 0);
  }
  void add_deviceImei(flatbuffers::Offset<flatbuffers::String> deviceImei) {
    fbb_.AddOffset(GroupStatusList::VT_DEVICEIMEI, deviceImei);
  }
  void add_deviceName(flatbuffers::Offset<flatbuffers::String> deviceName) {
    fbb_.AddOffset(GroupStatusList::VT_DEVICENAME, deviceName);
  }
  explicit GroupStatusListBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GroupStatusList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GroupStatusList>(end);
    return o;
  }
};

inline flatbuffers::Offset<GroupStatusList> CreateGroupStatusList(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t type = 0,
    uint16_t groupNumber = 0,
    uint16_t stopNumber = 0,
    uint8_t stop_group_status = 0,
    uint8_t isOccupied = 0,
    uint8_t task_status = 0,
    uint8_t drivingMode = 0,
    flatbuffers::Offset<flatbuffers::String> deviceImei = 0,
    flatbuffers::Offset<flatbuffers::String> deviceName = 0) {
  GroupStatusListBuilder builder_(_fbb);
  builder_.add_deviceName(deviceName);
  builder_.add_deviceImei(deviceImei);
  builder_.add_stopNumber(stopNumber);
  builder_.add_groupNumber(groupNumber);
  builder_.add_drivingMode(drivingMode);
  builder_.add_task_status(task_status);
  builder_.add_isOccupied(isOccupied);
  builder_.add_stop_group_status(stop_group_status);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<GroupStatusList> CreateGroupStatusListDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t type = 0,
    uint16_t groupNumber = 0,
    uint16_t stopNumber = 0,
    uint8_t stop_group_status = 0,
    uint8_t isOccupied = 0,
    uint8_t task_status = 0,
    uint8_t drivingMode = 0,
    const char *deviceImei = nullptr,
    const char *deviceName = nullptr) {
  auto deviceImei__ = deviceImei ? _fbb.CreateString(deviceImei) : 0;
  auto deviceName__ = deviceName ? _fbb.CreateString(deviceName) : 0;
  return CreateGroupStatusList(
      _fbb,
      type,
      groupNumber,
      stopNumber,
      stop_group_status,
      isOccupied,
      task_status,
      drivingMode,
      deviceImei__,
      deviceName__);
}

flatbuffers::Offset<GroupStatusList> CreateGroupStatusList(flatbuffers::FlatBufferBuilder &_fbb, const GroupStatusListT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Msg8B01T : public flatbuffers::NativeTable {
  typedef Msg8B01 TableType;
  std::string fileName;
  std::string md5;
  uint16_t listNum;
  std::vector<std::unique_ptr<GroupStatusListT>> List;
  Msg8B01T()
      : listNum(0) {
  }
};

inline bool operator==(const Msg8B01T &lhs, const Msg8B01T &rhs) {
  return
      (lhs.fileName == rhs.fileName) &&
      (lhs.md5 == rhs.md5) &&
      (lhs.listNum == rhs.listNum) &&
      (lhs.List == rhs.List);
}

inline bool operator!=(const Msg8B01T &lhs, const Msg8B01T &rhs) {
    return !(lhs == rhs);
}


struct Msg8B01 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Msg8B01T NativeTableType;
  typedef Msg8B01Builder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Msg8B01TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FILENAME = 4,
    VT_MD5 = 6,
    VT_LISTNUM = 8,
    VT_LIST = 10
  };
  const flatbuffers::String *fileName() const {
    return GetPointer<const flatbuffers::String *>(VT_FILENAME);
  }
  flatbuffers::String *mutable_fileName() {
    return GetPointer<flatbuffers::String *>(VT_FILENAME);
  }
  const flatbuffers::String *md5() const {
    return GetPointer<const flatbuffers::String *>(VT_MD5);
  }
  flatbuffers::String *mutable_md5() {
    return GetPointer<flatbuffers::String *>(VT_MD5);
  }
  uint16_t listNum() const {
    return GetField<uint16_t>(VT_LISTNUM, 0);
  }
  bool mutate_listNum(uint16_t _listNum) {
    return SetField<uint16_t>(VT_LISTNUM, _listNum, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<GroupStatusList>> *List() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<GroupStatusList>> *>(VT_LIST);
  }
  flatbuffers::Vector<flatbuffers::Offset<GroupStatusList>> *mutable_List() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<GroupStatusList>> *>(VT_LIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FILENAME) &&
           verifier.VerifyString(fileName()) &&
           VerifyOffset(verifier, VT_MD5) &&
           verifier.VerifyString(md5()) &&
           VerifyField<uint16_t>(verifier, VT_LISTNUM) &&
           VerifyOffset(verifier, VT_LIST) &&
           verifier.VerifyVector(List()) &&
           verifier.VerifyVectorOfTables(List()) &&
           verifier.EndTable();
  }
  Msg8B01T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Msg8B01T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Msg8B01> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg8B01T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Msg8B01Builder {
  typedef Msg8B01 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fileName(flatbuffers::Offset<flatbuffers::String> fileName) {
    fbb_.AddOffset(Msg8B01::VT_FILENAME, fileName);
  }
  void add_md5(flatbuffers::Offset<flatbuffers::String> md5) {
    fbb_.AddOffset(Msg8B01::VT_MD5, md5);
  }
  void add_listNum(uint16_t listNum) {
    fbb_.AddElement<uint16_t>(Msg8B01::VT_LISTNUM, listNum, 0);
  }
  void add_List(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GroupStatusList>>> List) {
    fbb_.AddOffset(Msg8B01::VT_LIST, List);
  }
  explicit Msg8B01Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Msg8B01> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Msg8B01>(end);
    return o;
  }
};

inline flatbuffers::Offset<Msg8B01> CreateMsg8B01(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> fileName = 0,
    flatbuffers::Offset<flatbuffers::String> md5 = 0,
    uint16_t listNum = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GroupStatusList>>> List = 0) {
  Msg8B01Builder builder_(_fbb);
  builder_.add_List(List);
  builder_.add_md5(md5);
  builder_.add_fileName(fileName);
  builder_.add_listNum(listNum);
  return builder_.Finish();
}

inline flatbuffers::Offset<Msg8B01> CreateMsg8B01Direct(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *fileName = nullptr,
    const char *md5 = nullptr,
    uint16_t listNum = 0,
    const std::vector<flatbuffers::Offset<GroupStatusList>> *List = nullptr) {
  auto fileName__ = fileName ? _fbb.CreateString(fileName) : 0;
  auto md5__ = md5 ? _fbb.CreateString(md5) : 0;
  auto List__ = List ? _fbb.CreateVector<flatbuffers::Offset<GroupStatusList>>(*List) : 0;
  return CreateMsg8B01(
      _fbb,
      fileName__,
      md5__,
      listNum,
      List__);
}

flatbuffers::Offset<Msg8B01> CreateMsg8B01(flatbuffers::FlatBufferBuilder &_fbb, const Msg8B01T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GroupStatusList_WaitInLineT : public flatbuffers::NativeTable {
  typedef GroupStatusList_WaitInLine TableType;
  uint8_t taskStat;
  uint8_t drivingMode;
  std::string deviceImei;
  std::string deviceName;
  GroupStatusList_WaitInLineT()
      : taskStat(0),
        drivingMode(0) {
  }
};

inline bool operator==(const GroupStatusList_WaitInLineT &lhs, const GroupStatusList_WaitInLineT &rhs) {
  return
      (lhs.taskStat == rhs.taskStat) &&
      (lhs.drivingMode == rhs.drivingMode) &&
      (lhs.deviceImei == rhs.deviceImei) &&
      (lhs.deviceName == rhs.deviceName);
}

inline bool operator!=(const GroupStatusList_WaitInLineT &lhs, const GroupStatusList_WaitInLineT &rhs) {
    return !(lhs == rhs);
}


struct GroupStatusList_WaitInLine FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GroupStatusList_WaitInLineT NativeTableType;
  typedef GroupStatusList_WaitInLineBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return GroupStatusList_WaitInLineTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TASKSTAT = 4,
    VT_DRIVINGMODE = 6,
    VT_DEVICEIMEI = 8,
    VT_DEVICENAME = 10
  };
  uint8_t taskStat() const {
    return GetField<uint8_t>(VT_TASKSTAT, 0);
  }
  bool mutate_taskStat(uint8_t _taskStat) {
    return SetField<uint8_t>(VT_TASKSTAT, _taskStat, 0);
  }
  uint8_t drivingMode() const {
    return GetField<uint8_t>(VT_DRIVINGMODE, 0);
  }
  bool mutate_drivingMode(uint8_t _drivingMode) {
    return SetField<uint8_t>(VT_DRIVINGMODE, _drivingMode, 0);
  }
  const flatbuffers::String *deviceImei() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEIMEI);
  }
  flatbuffers::String *mutable_deviceImei() {
    return GetPointer<flatbuffers::String *>(VT_DEVICEIMEI);
  }
  const flatbuffers::String *deviceName() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICENAME);
  }
  flatbuffers::String *mutable_deviceName() {
    return GetPointer<flatbuffers::String *>(VT_DEVICENAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TASKSTAT) &&
           VerifyField<uint8_t>(verifier, VT_DRIVINGMODE) &&
           VerifyOffset(verifier, VT_DEVICEIMEI) &&
           verifier.VerifyString(deviceImei()) &&
           VerifyOffset(verifier, VT_DEVICENAME) &&
           verifier.VerifyString(deviceName()) &&
           verifier.EndTable();
  }
  GroupStatusList_WaitInLineT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GroupStatusList_WaitInLineT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GroupStatusList_WaitInLine> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GroupStatusList_WaitInLineT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GroupStatusList_WaitInLineBuilder {
  typedef GroupStatusList_WaitInLine Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_taskStat(uint8_t taskStat) {
    fbb_.AddElement<uint8_t>(GroupStatusList_WaitInLine::VT_TASKSTAT, taskStat, 0);
  }
  void add_drivingMode(uint8_t drivingMode) {
    fbb_.AddElement<uint8_t>(GroupStatusList_WaitInLine::VT_DRIVINGMODE, drivingMode, 0);
  }
  void add_deviceImei(flatbuffers::Offset<flatbuffers::String> deviceImei) {
    fbb_.AddOffset(GroupStatusList_WaitInLine::VT_DEVICEIMEI, deviceImei);
  }
  void add_deviceName(flatbuffers::Offset<flatbuffers::String> deviceName) {
    fbb_.AddOffset(GroupStatusList_WaitInLine::VT_DEVICENAME, deviceName);
  }
  explicit GroupStatusList_WaitInLineBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GroupStatusList_WaitInLine> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GroupStatusList_WaitInLine>(end);
    return o;
  }
};

inline flatbuffers::Offset<GroupStatusList_WaitInLine> CreateGroupStatusList_WaitInLine(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t taskStat = 0,
    uint8_t drivingMode = 0,
    flatbuffers::Offset<flatbuffers::String> deviceImei = 0,
    flatbuffers::Offset<flatbuffers::String> deviceName = 0) {
  GroupStatusList_WaitInLineBuilder builder_(_fbb);
  builder_.add_deviceName(deviceName);
  builder_.add_deviceImei(deviceImei);
  builder_.add_drivingMode(drivingMode);
  builder_.add_taskStat(taskStat);
  return builder_.Finish();
}

inline flatbuffers::Offset<GroupStatusList_WaitInLine> CreateGroupStatusList_WaitInLineDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t taskStat = 0,
    uint8_t drivingMode = 0,
    const char *deviceImei = nullptr,
    const char *deviceName = nullptr) {
  auto deviceImei__ = deviceImei ? _fbb.CreateString(deviceImei) : 0;
  auto deviceName__ = deviceName ? _fbb.CreateString(deviceName) : 0;
  return CreateGroupStatusList_WaitInLine(
      _fbb,
      taskStat,
      drivingMode,
      deviceImei__,
      deviceName__);
}

flatbuffers::Offset<GroupStatusList_WaitInLine> CreateGroupStatusList_WaitInLine(flatbuffers::FlatBufferBuilder &_fbb, const GroupStatusList_WaitInLineT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Msg8B03T : public flatbuffers::NativeTable {
  typedef Msg8B03 TableType;
  uint16_t listNum;
  std::vector<std::unique_ptr<GroupStatusList_WaitInLineT>> List;
  Msg8B03T()
      : listNum(0) {
  }
};

inline bool operator==(const Msg8B03T &lhs, const Msg8B03T &rhs) {
  return
      (lhs.listNum == rhs.listNum) &&
      (lhs.List == rhs.List);
}

inline bool operator!=(const Msg8B03T &lhs, const Msg8B03T &rhs) {
    return !(lhs == rhs);
}


struct Msg8B03 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Msg8B03T NativeTableType;
  typedef Msg8B03Builder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Msg8B03TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LISTNUM = 4,
    VT_LIST = 6
  };
  uint16_t listNum() const {
    return GetField<uint16_t>(VT_LISTNUM, 0);
  }
  bool mutate_listNum(uint16_t _listNum) {
    return SetField<uint16_t>(VT_LISTNUM, _listNum, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<GroupStatusList_WaitInLine>> *List() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<GroupStatusList_WaitInLine>> *>(VT_LIST);
  }
  flatbuffers::Vector<flatbuffers::Offset<GroupStatusList_WaitInLine>> *mutable_List() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<GroupStatusList_WaitInLine>> *>(VT_LIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_LISTNUM) &&
           VerifyOffset(verifier, VT_LIST) &&
           verifier.VerifyVector(List()) &&
           verifier.VerifyVectorOfTables(List()) &&
           verifier.EndTable();
  }
  Msg8B03T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Msg8B03T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Msg8B03> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg8B03T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Msg8B03Builder {
  typedef Msg8B03 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_listNum(uint16_t listNum) {
    fbb_.AddElement<uint16_t>(Msg8B03::VT_LISTNUM, listNum, 0);
  }
  void add_List(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GroupStatusList_WaitInLine>>> List) {
    fbb_.AddOffset(Msg8B03::VT_LIST, List);
  }
  explicit Msg8B03Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Msg8B03> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Msg8B03>(end);
    return o;
  }
};

inline flatbuffers::Offset<Msg8B03> CreateMsg8B03(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t listNum = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GroupStatusList_WaitInLine>>> List = 0) {
  Msg8B03Builder builder_(_fbb);
  builder_.add_List(List);
  builder_.add_listNum(listNum);
  return builder_.Finish();
}

inline flatbuffers::Offset<Msg8B03> CreateMsg8B03Direct(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t listNum = 0,
    const std::vector<flatbuffers::Offset<GroupStatusList_WaitInLine>> *List = nullptr) {
  auto List__ = List ? _fbb.CreateVector<flatbuffers::Offset<GroupStatusList_WaitInLine>>(*List) : 0;
  return CreateMsg8B03(
      _fbb,
      listNum,
      List__);
}

flatbuffers::Offset<Msg8B03> CreateMsg8B03(flatbuffers::FlatBufferBuilder &_fbb, const Msg8B03T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Msg8307T : public flatbuffers::NativeTable {
  typedef Msg8307 TableType;
  std::string src_devID;
  std::string src_devNA;
  uint8_t work_type;
  uint8_t oper_type;
  uint8_t load_status;
  uint16_t mate_type;
  uint16_t stop_pos_num;
  uint64_t time;
  Msg8307T()
      : work_type(0),
        oper_type(0),
        load_status(0),
        mate_type(0),
        stop_pos_num(0),
        time(0) {
  }
};

inline bool operator==(const Msg8307T &lhs, const Msg8307T &rhs) {
  return
      (lhs.src_devID == rhs.src_devID) &&
      (lhs.src_devNA == rhs.src_devNA) &&
      (lhs.work_type == rhs.work_type) &&
      (lhs.oper_type == rhs.oper_type) &&
      (lhs.load_status == rhs.load_status) &&
      (lhs.mate_type == rhs.mate_type) &&
      (lhs.stop_pos_num == rhs.stop_pos_num) &&
      (lhs.time == rhs.time);
}

inline bool operator!=(const Msg8307T &lhs, const Msg8307T &rhs) {
    return !(lhs == rhs);
}


struct Msg8307 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Msg8307T NativeTableType;
  typedef Msg8307Builder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Msg8307TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SRC_DEVID = 4,
    VT_SRC_DEVNA = 6,
    VT_WORK_TYPE = 8,
    VT_OPER_TYPE = 10,
    VT_LOAD_STATUS = 12,
    VT_MATE_TYPE = 14,
    VT_STOP_POS_NUM = 16,
    VT_TIME = 18
  };
  const flatbuffers::String *src_devID() const {
    return GetPointer<const flatbuffers::String *>(VT_SRC_DEVID);
  }
  flatbuffers::String *mutable_src_devID() {
    return GetPointer<flatbuffers::String *>(VT_SRC_DEVID);
  }
  const flatbuffers::String *src_devNA() const {
    return GetPointer<const flatbuffers::String *>(VT_SRC_DEVNA);
  }
  flatbuffers::String *mutable_src_devNA() {
    return GetPointer<flatbuffers::String *>(VT_SRC_DEVNA);
  }
  uint8_t work_type() const {
    return GetField<uint8_t>(VT_WORK_TYPE, 0);
  }
  bool mutate_work_type(uint8_t _work_type) {
    return SetField<uint8_t>(VT_WORK_TYPE, _work_type, 0);
  }
  uint8_t oper_type() const {
    return GetField<uint8_t>(VT_OPER_TYPE, 0);
  }
  bool mutate_oper_type(uint8_t _oper_type) {
    return SetField<uint8_t>(VT_OPER_TYPE, _oper_type, 0);
  }
  uint8_t load_status() const {
    return GetField<uint8_t>(VT_LOAD_STATUS, 0);
  }
  bool mutate_load_status(uint8_t _load_status) {
    return SetField<uint8_t>(VT_LOAD_STATUS, _load_status, 0);
  }
  uint16_t mate_type() const {
    return GetField<uint16_t>(VT_MATE_TYPE, 0);
  }
  bool mutate_mate_type(uint16_t _mate_type) {
    return SetField<uint16_t>(VT_MATE_TYPE, _mate_type, 0);
  }
  uint16_t stop_pos_num() const {
    return GetField<uint16_t>(VT_STOP_POS_NUM, 0);
  }
  bool mutate_stop_pos_num(uint16_t _stop_pos_num) {
    return SetField<uint16_t>(VT_STOP_POS_NUM, _stop_pos_num, 0);
  }
  uint64_t time() const {
    return GetField<uint64_t>(VT_TIME, 0);
  }
  bool mutate_time(uint64_t _time) {
    return SetField<uint64_t>(VT_TIME, _time, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SRC_DEVID) &&
           verifier.VerifyString(src_devID()) &&
           VerifyOffset(verifier, VT_SRC_DEVNA) &&
           verifier.VerifyString(src_devNA()) &&
           VerifyField<uint8_t>(verifier, VT_WORK_TYPE) &&
           VerifyField<uint8_t>(verifier, VT_OPER_TYPE) &&
           VerifyField<uint8_t>(verifier, VT_LOAD_STATUS) &&
           VerifyField<uint16_t>(verifier, VT_MATE_TYPE) &&
           VerifyField<uint16_t>(verifier, VT_STOP_POS_NUM) &&
           VerifyField<uint64_t>(verifier, VT_TIME) &&
           verifier.EndTable();
  }
  Msg8307T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Msg8307T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Msg8307> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg8307T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Msg8307Builder {
  typedef Msg8307 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_src_devID(flatbuffers::Offset<flatbuffers::String> src_devID) {
    fbb_.AddOffset(Msg8307::VT_SRC_DEVID, src_devID);
  }
  void add_src_devNA(flatbuffers::Offset<flatbuffers::String> src_devNA) {
    fbb_.AddOffset(Msg8307::VT_SRC_DEVNA, src_devNA);
  }
  void add_work_type(uint8_t work_type) {
    fbb_.AddElement<uint8_t>(Msg8307::VT_WORK_TYPE, work_type, 0);
  }
  void add_oper_type(uint8_t oper_type) {
    fbb_.AddElement<uint8_t>(Msg8307::VT_OPER_TYPE, oper_type, 0);
  }
  void add_load_status(uint8_t load_status) {
    fbb_.AddElement<uint8_t>(Msg8307::VT_LOAD_STATUS, load_status, 0);
  }
  void add_mate_type(uint16_t mate_type) {
    fbb_.AddElement<uint16_t>(Msg8307::VT_MATE_TYPE, mate_type, 0);
  }
  void add_stop_pos_num(uint16_t stop_pos_num) {
    fbb_.AddElement<uint16_t>(Msg8307::VT_STOP_POS_NUM, stop_pos_num, 0);
  }
  void add_time(uint64_t time) {
    fbb_.AddElement<uint64_t>(Msg8307::VT_TIME, time, 0);
  }
  explicit Msg8307Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Msg8307> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Msg8307>(end);
    return o;
  }
};

inline flatbuffers::Offset<Msg8307> CreateMsg8307(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> src_devID = 0,
    flatbuffers::Offset<flatbuffers::String> src_devNA = 0,
    uint8_t work_type = 0,
    uint8_t oper_type = 0,
    uint8_t load_status = 0,
    uint16_t mate_type = 0,
    uint16_t stop_pos_num = 0,
    uint64_t time = 0) {
  Msg8307Builder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_src_devNA(src_devNA);
  builder_.add_src_devID(src_devID);
  builder_.add_stop_pos_num(stop_pos_num);
  builder_.add_mate_type(mate_type);
  builder_.add_load_status(load_status);
  builder_.add_oper_type(oper_type);
  builder_.add_work_type(work_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Msg8307> CreateMsg8307Direct(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *src_devID = nullptr,
    const char *src_devNA = nullptr,
    uint8_t work_type = 0,
    uint8_t oper_type = 0,
    uint8_t load_status = 0,
    uint16_t mate_type = 0,
    uint16_t stop_pos_num = 0,
    uint64_t time = 0) {
  auto src_devID__ = src_devID ? _fbb.CreateString(src_devID) : 0;
  auto src_devNA__ = src_devNA ? _fbb.CreateString(src_devNA) : 0;
  return CreateMsg8307(
      _fbb,
      src_devID__,
      src_devNA__,
      work_type,
      oper_type,
      load_status,
      mate_type,
      stop_pos_num,
      time);
}

flatbuffers::Offset<Msg8307> CreateMsg8307(flatbuffers::FlatBufferBuilder &_fbb, const Msg8307T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Msg8308T : public flatbuffers::NativeTable {
  typedef Msg8308 TableType;
  std::string src_devID;
  std::string src_devNA;
  uint8_t work_type;
  uint8_t oper_type;
  uint64_t time;
  Msg8308T()
      : work_type(0),
        oper_type(0),
        time(0) {
  }
};

inline bool operator==(const Msg8308T &lhs, const Msg8308T &rhs) {
  return
      (lhs.src_devID == rhs.src_devID) &&
      (lhs.src_devNA == rhs.src_devNA) &&
      (lhs.work_type == rhs.work_type) &&
      (lhs.oper_type == rhs.oper_type) &&
      (lhs.time == rhs.time);
}

inline bool operator!=(const Msg8308T &lhs, const Msg8308T &rhs) {
    return !(lhs == rhs);
}


struct Msg8308 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Msg8308T NativeTableType;
  typedef Msg8308Builder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Msg8308TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SRC_DEVID = 4,
    VT_SRC_DEVNA = 6,
    VT_WORK_TYPE = 8,
    VT_OPER_TYPE = 10,
    VT_TIME = 12
  };
  const flatbuffers::String *src_devID() const {
    return GetPointer<const flatbuffers::String *>(VT_SRC_DEVID);
  }
  flatbuffers::String *mutable_src_devID() {
    return GetPointer<flatbuffers::String *>(VT_SRC_DEVID);
  }
  const flatbuffers::String *src_devNA() const {
    return GetPointer<const flatbuffers::String *>(VT_SRC_DEVNA);
  }
  flatbuffers::String *mutable_src_devNA() {
    return GetPointer<flatbuffers::String *>(VT_SRC_DEVNA);
  }
  uint8_t work_type() const {
    return GetField<uint8_t>(VT_WORK_TYPE, 0);
  }
  bool mutate_work_type(uint8_t _work_type) {
    return SetField<uint8_t>(VT_WORK_TYPE, _work_type, 0);
  }
  uint8_t oper_type() const {
    return GetField<uint8_t>(VT_OPER_TYPE, 0);
  }
  bool mutate_oper_type(uint8_t _oper_type) {
    return SetField<uint8_t>(VT_OPER_TYPE, _oper_type, 0);
  }
  uint64_t time() const {
    return GetField<uint64_t>(VT_TIME, 0);
  }
  bool mutate_time(uint64_t _time) {
    return SetField<uint64_t>(VT_TIME, _time, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SRC_DEVID) &&
           verifier.VerifyString(src_devID()) &&
           VerifyOffset(verifier, VT_SRC_DEVNA) &&
           verifier.VerifyString(src_devNA()) &&
           VerifyField<uint8_t>(verifier, VT_WORK_TYPE) &&
           VerifyField<uint8_t>(verifier, VT_OPER_TYPE) &&
           VerifyField<uint64_t>(verifier, VT_TIME) &&
           verifier.EndTable();
  }
  Msg8308T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Msg8308T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Msg8308> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg8308T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Msg8308Builder {
  typedef Msg8308 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_src_devID(flatbuffers::Offset<flatbuffers::String> src_devID) {
    fbb_.AddOffset(Msg8308::VT_SRC_DEVID, src_devID);
  }
  void add_src_devNA(flatbuffers::Offset<flatbuffers::String> src_devNA) {
    fbb_.AddOffset(Msg8308::VT_SRC_DEVNA, src_devNA);
  }
  void add_work_type(uint8_t work_type) {
    fbb_.AddElement<uint8_t>(Msg8308::VT_WORK_TYPE, work_type, 0);
  }
  void add_oper_type(uint8_t oper_type) {
    fbb_.AddElement<uint8_t>(Msg8308::VT_OPER_TYPE, oper_type, 0);
  }
  void add_time(uint64_t time) {
    fbb_.AddElement<uint64_t>(Msg8308::VT_TIME, time, 0);
  }
  explicit Msg8308Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Msg8308> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Msg8308>(end);
    return o;
  }
};

inline flatbuffers::Offset<Msg8308> CreateMsg8308(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> src_devID = 0,
    flatbuffers::Offset<flatbuffers::String> src_devNA = 0,
    uint8_t work_type = 0,
    uint8_t oper_type = 0,
    uint64_t time = 0) {
  Msg8308Builder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_src_devNA(src_devNA);
  builder_.add_src_devID(src_devID);
  builder_.add_oper_type(oper_type);
  builder_.add_work_type(work_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Msg8308> CreateMsg8308Direct(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *src_devID = nullptr,
    const char *src_devNA = nullptr,
    uint8_t work_type = 0,
    uint8_t oper_type = 0,
    uint64_t time = 0) {
  auto src_devID__ = src_devID ? _fbb.CreateString(src_devID) : 0;
  auto src_devNA__ = src_devNA ? _fbb.CreateString(src_devNA) : 0;
  return CreateMsg8308(
      _fbb,
      src_devID__,
      src_devNA__,
      work_type,
      oper_type,
      time);
}

flatbuffers::Offset<Msg8308> CreateMsg8308(flatbuffers::FlatBufferBuilder &_fbb, const Msg8308T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Msg0F21T : public flatbuffers::NativeTable {
  typedef Msg0F21 TableType;
  uint8_t work_type;
  uint8_t oper_type;
  uint64_t time;
  Msg0F21T()
      : work_type(0),
        oper_type(0),
        time(0) {
  }
};

inline bool operator==(const Msg0F21T &lhs, const Msg0F21T &rhs) {
  return
      (lhs.work_type == rhs.work_type) &&
      (lhs.oper_type == rhs.oper_type) &&
      (lhs.time == rhs.time);
}

inline bool operator!=(const Msg0F21T &lhs, const Msg0F21T &rhs) {
    return !(lhs == rhs);
}


struct Msg0F21 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Msg0F21T NativeTableType;
  typedef Msg0F21Builder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Msg0F21TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WORK_TYPE = 4,
    VT_OPER_TYPE = 6,
    VT_TIME = 8
  };
  uint8_t work_type() const {
    return GetField<uint8_t>(VT_WORK_TYPE, 0);
  }
  bool mutate_work_type(uint8_t _work_type) {
    return SetField<uint8_t>(VT_WORK_TYPE, _work_type, 0);
  }
  uint8_t oper_type() const {
    return GetField<uint8_t>(VT_OPER_TYPE, 0);
  }
  bool mutate_oper_type(uint8_t _oper_type) {
    return SetField<uint8_t>(VT_OPER_TYPE, _oper_type, 0);
  }
  uint64_t time() const {
    return GetField<uint64_t>(VT_TIME, 0);
  }
  bool mutate_time(uint64_t _time) {
    return SetField<uint64_t>(VT_TIME, _time, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_WORK_TYPE) &&
           VerifyField<uint8_t>(verifier, VT_OPER_TYPE) &&
           VerifyField<uint64_t>(verifier, VT_TIME) &&
           verifier.EndTable();
  }
  Msg0F21T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Msg0F21T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Msg0F21> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg0F21T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Msg0F21Builder {
  typedef Msg0F21 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_work_type(uint8_t work_type) {
    fbb_.AddElement<uint8_t>(Msg0F21::VT_WORK_TYPE, work_type, 0);
  }
  void add_oper_type(uint8_t oper_type) {
    fbb_.AddElement<uint8_t>(Msg0F21::VT_OPER_TYPE, oper_type, 0);
  }
  void add_time(uint64_t time) {
    fbb_.AddElement<uint64_t>(Msg0F21::VT_TIME, time, 0);
  }
  explicit Msg0F21Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Msg0F21> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Msg0F21>(end);
    return o;
  }
};

inline flatbuffers::Offset<Msg0F21> CreateMsg0F21(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t work_type = 0,
    uint8_t oper_type = 0,
    uint64_t time = 0) {
  Msg0F21Builder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_oper_type(oper_type);
  builder_.add_work_type(work_type);
  return builder_.Finish();
}

flatbuffers::Offset<Msg0F21> CreateMsg0F21(flatbuffers::FlatBufferBuilder &_fbb, const Msg0F21T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Msg0503T : public flatbuffers::NativeTable {
  typedef Msg0503 TableType;
  uint8_t module_type;
  uint8_t state;
  uint64_t time;
  Msg0503T()
      : module_type(0),
        state(0),
        time(0) {
  }
};

inline bool operator==(const Msg0503T &lhs, const Msg0503T &rhs) {
  return
      (lhs.module_type == rhs.module_type) &&
      (lhs.state == rhs.state) &&
      (lhs.time == rhs.time);
}

inline bool operator!=(const Msg0503T &lhs, const Msg0503T &rhs) {
    return !(lhs == rhs);
}


struct Msg0503 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Msg0503T NativeTableType;
  typedef Msg0503Builder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Msg0503TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MODULE_TYPE = 4,
    VT_STATE = 6,
    VT_TIME = 8
  };
  uint8_t module_type() const {
    return GetField<uint8_t>(VT_MODULE_TYPE, 0);
  }
  bool mutate_module_type(uint8_t _module_type) {
    return SetField<uint8_t>(VT_MODULE_TYPE, _module_type, 0);
  }
  uint8_t state() const {
    return GetField<uint8_t>(VT_STATE, 0);
  }
  bool mutate_state(uint8_t _state) {
    return SetField<uint8_t>(VT_STATE, _state, 0);
  }
  uint64_t time() const {
    return GetField<uint64_t>(VT_TIME, 0);
  }
  bool mutate_time(uint64_t _time) {
    return SetField<uint64_t>(VT_TIME, _time, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MODULE_TYPE) &&
           VerifyField<uint8_t>(verifier, VT_STATE) &&
           VerifyField<uint64_t>(verifier, VT_TIME) &&
           verifier.EndTable();
  }
  Msg0503T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Msg0503T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Msg0503> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg0503T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Msg0503Builder {
  typedef Msg0503 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_module_type(uint8_t module_type) {
    fbb_.AddElement<uint8_t>(Msg0503::VT_MODULE_TYPE, module_type, 0);
  }
  void add_state(uint8_t state) {
    fbb_.AddElement<uint8_t>(Msg0503::VT_STATE, state, 0);
  }
  void add_time(uint64_t time) {
    fbb_.AddElement<uint64_t>(Msg0503::VT_TIME, time, 0);
  }
  explicit Msg0503Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Msg0503> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Msg0503>(end);
    return o;
  }
};

inline flatbuffers::Offset<Msg0503> CreateMsg0503(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t module_type = 0,
    uint8_t state = 0,
    uint64_t time = 0) {
  Msg0503Builder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_state(state);
  builder_.add_module_type(module_type);
  return builder_.Finish();
}

flatbuffers::Offset<Msg0503> CreateMsg0503(flatbuffers::FlatBufferBuilder &_fbb, const Msg0503T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Msg8105T : public flatbuffers::NativeTable {
  typedef Msg8105 TableType;
  uint8_t result;
  Msg8105T()
      : result(0) {
  }
};

inline bool operator==(const Msg8105T &lhs, const Msg8105T &rhs) {
  return
      (lhs.result == rhs.result);
}

inline bool operator!=(const Msg8105T &lhs, const Msg8105T &rhs) {
    return !(lhs == rhs);
}


struct Msg8105 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Msg8105T NativeTableType;
  typedef Msg8105Builder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Msg8105TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4
  };
  uint8_t result() const {
    return GetField<uint8_t>(VT_RESULT, 0);
  }
  bool mutate_result(uint8_t _result) {
    return SetField<uint8_t>(VT_RESULT, _result, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_RESULT) &&
           verifier.EndTable();
  }
  Msg8105T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Msg8105T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Msg8105> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg8105T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Msg8105Builder {
  typedef Msg8105 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_result(uint8_t result) {
    fbb_.AddElement<uint8_t>(Msg8105::VT_RESULT, result, 0);
  }
  explicit Msg8105Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Msg8105> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Msg8105>(end);
    return o;
  }
};

inline flatbuffers::Offset<Msg8105> CreateMsg8105(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t result = 0) {
  Msg8105Builder builder_(_fbb);
  builder_.add_result(result);
  return builder_.Finish();
}

flatbuffers::Offset<Msg8105> CreateMsg8105(flatbuffers::FlatBufferBuilder &_fbb, const Msg8105T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Msg8B10T : public flatbuffers::NativeTable {
  typedef Msg8B10 TableType;
  uint8_t result;
  std::string name;
  Msg8B10T()
      : result(0) {
  }
};

inline bool operator==(const Msg8B10T &lhs, const Msg8B10T &rhs) {
  return
      (lhs.result == rhs.result) &&
      (lhs.name == rhs.name);
}

inline bool operator!=(const Msg8B10T &lhs, const Msg8B10T &rhs) {
    return !(lhs == rhs);
}


struct Msg8B10 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Msg8B10T NativeTableType;
  typedef Msg8B10Builder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Msg8B10TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4,
    VT_NAME = 6
  };
  uint8_t result() const {
    return GetField<uint8_t>(VT_RESULT, 0);
  }
  bool mutate_result(uint8_t _result) {
    return SetField<uint8_t>(VT_RESULT, _result, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_RESULT) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
  Msg8B10T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Msg8B10T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Msg8B10> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg8B10T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Msg8B10Builder {
  typedef Msg8B10 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_result(uint8_t result) {
    fbb_.AddElement<uint8_t>(Msg8B10::VT_RESULT, result, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Msg8B10::VT_NAME, name);
  }
  explicit Msg8B10Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Msg8B10> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Msg8B10>(end);
    return o;
  }
};

inline flatbuffers::Offset<Msg8B10> CreateMsg8B10(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t result = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  Msg8B10Builder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_result(result);
  return builder_.Finish();
}

inline flatbuffers::Offset<Msg8B10> CreateMsg8B10Direct(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t result = 0,
    const char *name = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return CreateMsg8B10(
      _fbb,
      result,
      name__);
}

flatbuffers::Offset<Msg8B10> CreateMsg8B10(flatbuffers::FlatBufferBuilder &_fbb, const Msg8B10T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Msg8B11T : public flatbuffers::NativeTable {
  typedef Msg8B11 TableType;
  uint8_t result;
  Msg8B11T()
      : result(0) {
  }
};

inline bool operator==(const Msg8B11T &lhs, const Msg8B11T &rhs) {
  return
      (lhs.result == rhs.result);
}

inline bool operator!=(const Msg8B11T &lhs, const Msg8B11T &rhs) {
    return !(lhs == rhs);
}


struct Msg8B11 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Msg8B11T NativeTableType;
  typedef Msg8B11Builder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Msg8B11TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4
  };
  uint8_t result() const {
    return GetField<uint8_t>(VT_RESULT, 0);
  }
  bool mutate_result(uint8_t _result) {
    return SetField<uint8_t>(VT_RESULT, _result, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_RESULT) &&
           verifier.EndTable();
  }
  Msg8B11T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Msg8B11T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Msg8B11> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg8B11T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Msg8B11Builder {
  typedef Msg8B11 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_result(uint8_t result) {
    fbb_.AddElement<uint8_t>(Msg8B11::VT_RESULT, result, 0);
  }
  explicit Msg8B11Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Msg8B11> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Msg8B11>(end);
    return o;
  }
};

inline flatbuffers::Offset<Msg8B11> CreateMsg8B11(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t result = 0) {
  Msg8B11Builder builder_(_fbb);
  builder_.add_result(result);
  return builder_.Finish();
}

flatbuffers::Offset<Msg8B11> CreateMsg8B11(flatbuffers::FlatBufferBuilder &_fbb, const Msg8B11T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Msg0F0BT : public flatbuffers::NativeTable {
  typedef Msg0F0B TableType;
  uint8_t result;
  Msg0F0BT()
      : result(0) {
  }
};

inline bool operator==(const Msg0F0BT &lhs, const Msg0F0BT &rhs) {
  return
      (lhs.result == rhs.result);
}

inline bool operator!=(const Msg0F0BT &lhs, const Msg0F0BT &rhs) {
    return !(lhs == rhs);
}


struct Msg0F0B FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Msg0F0BT NativeTableType;
  typedef Msg0F0BBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Msg0F0BTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4
  };
  uint8_t result() const {
    return GetField<uint8_t>(VT_RESULT, 0);
  }
  bool mutate_result(uint8_t _result) {
    return SetField<uint8_t>(VT_RESULT, _result, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_RESULT) &&
           verifier.EndTable();
  }
  Msg0F0BT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Msg0F0BT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Msg0F0B> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg0F0BT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Msg0F0BBuilder {
  typedef Msg0F0B Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_result(uint8_t result) {
    fbb_.AddElement<uint8_t>(Msg0F0B::VT_RESULT, result, 0);
  }
  explicit Msg0F0BBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Msg0F0B> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Msg0F0B>(end);
    return o;
  }
};

inline flatbuffers::Offset<Msg0F0B> CreateMsg0F0B(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t result = 0) {
  Msg0F0BBuilder builder_(_fbb);
  builder_.add_result(result);
  return builder_.Finish();
}

flatbuffers::Offset<Msg0F0B> CreateMsg0F0B(flatbuffers::FlatBufferBuilder &_fbb, const Msg0F0BT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MsgVectorT : public flatbuffers::NativeTable {
  typedef MsgVector TableType;
  std::vector<uint8_t> vectormsg;
  MsgVectorT() {
  }
};

inline bool operator==(const MsgVectorT &lhs, const MsgVectorT &rhs) {
  return
      (lhs.vectormsg == rhs.vectormsg);
}

inline bool operator!=(const MsgVectorT &lhs, const MsgVectorT &rhs) {
    return !(lhs == rhs);
}


struct MsgVector FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MsgVectorT NativeTableType;
  typedef MsgVectorBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MsgVectorTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VECTORMSG = 4
  };
  const flatbuffers::Vector<uint8_t> *vectormsg() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_VECTORMSG);
  }
  flatbuffers::Vector<uint8_t> *mutable_vectormsg() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_VECTORMSG);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VECTORMSG) &&
           verifier.VerifyVector(vectormsg()) &&
           verifier.EndTable();
  }
  MsgVectorT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MsgVectorT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MsgVector> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MsgVectorT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MsgVectorBuilder {
  typedef MsgVector Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_vectormsg(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> vectormsg) {
    fbb_.AddOffset(MsgVector::VT_VECTORMSG, vectormsg);
  }
  explicit MsgVectorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MsgVector> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MsgVector>(end);
    return o;
  }
};

inline flatbuffers::Offset<MsgVector> CreateMsgVector(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> vectormsg = 0) {
  MsgVectorBuilder builder_(_fbb);
  builder_.add_vectormsg(vectormsg);
  return builder_.Finish();
}

inline flatbuffers::Offset<MsgVector> CreateMsgVectorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *vectormsg = nullptr) {
  auto vectormsg__ = vectormsg ? _fbb.CreateVector<uint8_t>(*vectormsg) : 0;
  return CreateMsgVector(
      _fbb,
      vectormsg__);
}

flatbuffers::Offset<MsgVector> CreateMsgVector(flatbuffers::FlatBufferBuilder &_fbb, const MsgVectorT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MsgVoiceNameT : public flatbuffers::NativeTable {
  typedef MsgVoiceName TableType;
  std::string voiceName;
  MsgVoiceNameT() {
  }
};

inline bool operator==(const MsgVoiceNameT &lhs, const MsgVoiceNameT &rhs) {
  return
      (lhs.voiceName == rhs.voiceName);
}

inline bool operator!=(const MsgVoiceNameT &lhs, const MsgVoiceNameT &rhs) {
    return !(lhs == rhs);
}


struct MsgVoiceName FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MsgVoiceNameT NativeTableType;
  typedef MsgVoiceNameBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MsgVoiceNameTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VOICENAME = 4
  };
  const flatbuffers::String *voiceName() const {
    return GetPointer<const flatbuffers::String *>(VT_VOICENAME);
  }
  flatbuffers::String *mutable_voiceName() {
    return GetPointer<flatbuffers::String *>(VT_VOICENAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VOICENAME) &&
           verifier.VerifyString(voiceName()) &&
           verifier.EndTable();
  }
  MsgVoiceNameT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MsgVoiceNameT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MsgVoiceName> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MsgVoiceNameT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MsgVoiceNameBuilder {
  typedef MsgVoiceName Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_voiceName(flatbuffers::Offset<flatbuffers::String> voiceName) {
    fbb_.AddOffset(MsgVoiceName::VT_VOICENAME, voiceName);
  }
  explicit MsgVoiceNameBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MsgVoiceName> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MsgVoiceName>(end);
    return o;
  }
};

inline flatbuffers::Offset<MsgVoiceName> CreateMsgVoiceName(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> voiceName = 0) {
  MsgVoiceNameBuilder builder_(_fbb);
  builder_.add_voiceName(voiceName);
  return builder_.Finish();
}

inline flatbuffers::Offset<MsgVoiceName> CreateMsgVoiceNameDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *voiceName = nullptr) {
  auto voiceName__ = voiceName ? _fbb.CreateString(voiceName) : 0;
  return CreateMsgVoiceName(
      _fbb,
      voiceName__);
}

flatbuffers::Offset<MsgVoiceName> CreateMsgVoiceName(flatbuffers::FlatBufferBuilder &_fbb, const MsgVoiceNameT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Msg1040T : public flatbuffers::NativeTable {
  typedef Msg1040 TableType;
  std::string imei;
  std::string objName;
  std::string uploadAddr;
  Msg1040T() {
  }
};

inline bool operator==(const Msg1040T &lhs, const Msg1040T &rhs) {
  return
      (lhs.imei == rhs.imei) &&
      (lhs.objName == rhs.objName) &&
      (lhs.uploadAddr == rhs.uploadAddr);
}

inline bool operator!=(const Msg1040T &lhs, const Msg1040T &rhs) {
    return !(lhs == rhs);
}


struct Msg1040 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Msg1040T NativeTableType;
  typedef Msg1040Builder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Msg1040TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IMEI = 4,
    VT_OBJNAME = 6,
    VT_UPLOADADDR = 8
  };
  const flatbuffers::String *imei() const {
    return GetPointer<const flatbuffers::String *>(VT_IMEI);
  }
  flatbuffers::String *mutable_imei() {
    return GetPointer<flatbuffers::String *>(VT_IMEI);
  }
  const flatbuffers::String *objName() const {
    return GetPointer<const flatbuffers::String *>(VT_OBJNAME);
  }
  flatbuffers::String *mutable_objName() {
    return GetPointer<flatbuffers::String *>(VT_OBJNAME);
  }
  const flatbuffers::String *uploadAddr() const {
    return GetPointer<const flatbuffers::String *>(VT_UPLOADADDR);
  }
  flatbuffers::String *mutable_uploadAddr() {
    return GetPointer<flatbuffers::String *>(VT_UPLOADADDR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_IMEI) &&
           verifier.VerifyString(imei()) &&
           VerifyOffset(verifier, VT_OBJNAME) &&
           verifier.VerifyString(objName()) &&
           VerifyOffset(verifier, VT_UPLOADADDR) &&
           verifier.VerifyString(uploadAddr()) &&
           verifier.EndTable();
  }
  Msg1040T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Msg1040T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Msg1040> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg1040T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Msg1040Builder {
  typedef Msg1040 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_imei(flatbuffers::Offset<flatbuffers::String> imei) {
    fbb_.AddOffset(Msg1040::VT_IMEI, imei);
  }
  void add_objName(flatbuffers::Offset<flatbuffers::String> objName) {
    fbb_.AddOffset(Msg1040::VT_OBJNAME, objName);
  }
  void add_uploadAddr(flatbuffers::Offset<flatbuffers::String> uploadAddr) {
    fbb_.AddOffset(Msg1040::VT_UPLOADADDR, uploadAddr);
  }
  explicit Msg1040Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Msg1040> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Msg1040>(end);
    return o;
  }
};

inline flatbuffers::Offset<Msg1040> CreateMsg1040(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> imei = 0,
    flatbuffers::Offset<flatbuffers::String> objName = 0,
    flatbuffers::Offset<flatbuffers::String> uploadAddr = 0) {
  Msg1040Builder builder_(_fbb);
  builder_.add_uploadAddr(uploadAddr);
  builder_.add_objName(objName);
  builder_.add_imei(imei);
  return builder_.Finish();
}

inline flatbuffers::Offset<Msg1040> CreateMsg1040Direct(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *imei = nullptr,
    const char *objName = nullptr,
    const char *uploadAddr = nullptr) {
  auto imei__ = imei ? _fbb.CreateString(imei) : 0;
  auto objName__ = objName ? _fbb.CreateString(objName) : 0;
  auto uploadAddr__ = uploadAddr ? _fbb.CreateString(uploadAddr) : 0;
  return CreateMsg1040(
      _fbb,
      imei__,
      objName__,
      uploadAddr__);
}

flatbuffers::Offset<Msg1040> CreateMsg1040(flatbuffers::FlatBufferBuilder &_fbb, const Msg1040T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Msg0305T : public flatbuffers::NativeTable {
  typedef Msg0305 TableType;
  std::vector<uint8_t> truckImei;
  std::vector<uint8_t> auxImei;
  std::vector<uint8_t> truckName;
  std::vector<uint8_t> auxName;
  uint8_t workType;
  uint8_t optType;
  uint64_t utcTime;
  Msg0305T()
      : workType(0),
        optType(0),
        utcTime(0) {
  }
};

inline bool operator==(const Msg0305T &lhs, const Msg0305T &rhs) {
  return
      (lhs.truckImei == rhs.truckImei) &&
      (lhs.auxImei == rhs.auxImei) &&
      (lhs.truckName == rhs.truckName) &&
      (lhs.auxName == rhs.auxName) &&
      (lhs.workType == rhs.workType) &&
      (lhs.optType == rhs.optType) &&
      (lhs.utcTime == rhs.utcTime);
}

inline bool operator!=(const Msg0305T &lhs, const Msg0305T &rhs) {
    return !(lhs == rhs);
}


struct Msg0305 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Msg0305T NativeTableType;
  typedef Msg0305Builder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Msg0305TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TRUCKIMEI = 4,
    VT_AUXIMEI = 6,
    VT_TRUCKNAME = 8,
    VT_AUXNAME = 10,
    VT_WORKTYPE = 12,
    VT_OPTTYPE = 14,
    VT_UTCTIME = 16
  };
  const flatbuffers::Vector<uint8_t> *truckImei() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_TRUCKIMEI);
  }
  flatbuffers::Vector<uint8_t> *mutable_truckImei() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_TRUCKIMEI);
  }
  const flatbuffers::Vector<uint8_t> *auxImei() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_AUXIMEI);
  }
  flatbuffers::Vector<uint8_t> *mutable_auxImei() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_AUXIMEI);
  }
  const flatbuffers::Vector<uint8_t> *truckName() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_TRUCKNAME);
  }
  flatbuffers::Vector<uint8_t> *mutable_truckName() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_TRUCKNAME);
  }
  const flatbuffers::Vector<uint8_t> *auxName() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_AUXNAME);
  }
  flatbuffers::Vector<uint8_t> *mutable_auxName() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_AUXNAME);
  }
  uint8_t workType() const {
    return GetField<uint8_t>(VT_WORKTYPE, 0);
  }
  bool mutate_workType(uint8_t _workType) {
    return SetField<uint8_t>(VT_WORKTYPE, _workType, 0);
  }
  uint8_t optType() const {
    return GetField<uint8_t>(VT_OPTTYPE, 0);
  }
  bool mutate_optType(uint8_t _optType) {
    return SetField<uint8_t>(VT_OPTTYPE, _optType, 0);
  }
  uint64_t utcTime() const {
    return GetField<uint64_t>(VT_UTCTIME, 0);
  }
  bool mutate_utcTime(uint64_t _utcTime) {
    return SetField<uint64_t>(VT_UTCTIME, _utcTime, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TRUCKIMEI) &&
           verifier.VerifyVector(truckImei()) &&
           VerifyOffset(verifier, VT_AUXIMEI) &&
           verifier.VerifyVector(auxImei()) &&
           VerifyOffset(verifier, VT_TRUCKNAME) &&
           verifier.VerifyVector(truckName()) &&
           VerifyOffset(verifier, VT_AUXNAME) &&
           verifier.VerifyVector(auxName()) &&
           VerifyField<uint8_t>(verifier, VT_WORKTYPE) &&
           VerifyField<uint8_t>(verifier, VT_OPTTYPE) &&
           VerifyField<uint64_t>(verifier, VT_UTCTIME) &&
           verifier.EndTable();
  }
  Msg0305T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Msg0305T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Msg0305> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg0305T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Msg0305Builder {
  typedef Msg0305 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_truckImei(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> truckImei) {
    fbb_.AddOffset(Msg0305::VT_TRUCKIMEI, truckImei);
  }
  void add_auxImei(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> auxImei) {
    fbb_.AddOffset(Msg0305::VT_AUXIMEI, auxImei);
  }
  void add_truckName(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> truckName) {
    fbb_.AddOffset(Msg0305::VT_TRUCKNAME, truckName);
  }
  void add_auxName(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> auxName) {
    fbb_.AddOffset(Msg0305::VT_AUXNAME, auxName);
  }
  void add_workType(uint8_t workType) {
    fbb_.AddElement<uint8_t>(Msg0305::VT_WORKTYPE, workType, 0);
  }
  void add_optType(uint8_t optType) {
    fbb_.AddElement<uint8_t>(Msg0305::VT_OPTTYPE, optType, 0);
  }
  void add_utcTime(uint64_t utcTime) {
    fbb_.AddElement<uint64_t>(Msg0305::VT_UTCTIME, utcTime, 0);
  }
  explicit Msg0305Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Msg0305> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Msg0305>(end);
    return o;
  }
};

inline flatbuffers::Offset<Msg0305> CreateMsg0305(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> truckImei = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> auxImei = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> truckName = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> auxName = 0,
    uint8_t workType = 0,
    uint8_t optType = 0,
    uint64_t utcTime = 0) {
  Msg0305Builder builder_(_fbb);
  builder_.add_utcTime(utcTime);
  builder_.add_auxName(auxName);
  builder_.add_truckName(truckName);
  builder_.add_auxImei(auxImei);
  builder_.add_truckImei(truckImei);
  builder_.add_optType(optType);
  builder_.add_workType(workType);
  return builder_.Finish();
}

inline flatbuffers::Offset<Msg0305> CreateMsg0305Direct(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *truckImei = nullptr,
    const std::vector<uint8_t> *auxImei = nullptr,
    const std::vector<uint8_t> *truckName = nullptr,
    const std::vector<uint8_t> *auxName = nullptr,
    uint8_t workType = 0,
    uint8_t optType = 0,
    uint64_t utcTime = 0) {
  auto truckImei__ = truckImei ? _fbb.CreateVector<uint8_t>(*truckImei) : 0;
  auto auxImei__ = auxImei ? _fbb.CreateVector<uint8_t>(*auxImei) : 0;
  auto truckName__ = truckName ? _fbb.CreateVector<uint8_t>(*truckName) : 0;
  auto auxName__ = auxName ? _fbb.CreateVector<uint8_t>(*auxName) : 0;
  return CreateMsg0305(
      _fbb,
      truckImei__,
      auxImei__,
      truckName__,
      auxName__,
      workType,
      optType,
      utcTime);
}

flatbuffers::Offset<Msg0305> CreateMsg0305(flatbuffers::FlatBufferBuilder &_fbb, const Msg0305T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Msg8305_V2XT : public flatbuffers::NativeTable {
  typedef Msg8305_V2X TableType;
  std::vector<uint8_t> auxImei;
  std::vector<uint8_t> auxName;
  std::vector<uint8_t> truckImei;
  std::vector<uint8_t> truckName;
  uint8_t workType;
  uint8_t optType;
  uint8_t loadState;
  uint16_t materNum;
  uint16_t stopPosNum;
  uint64_t utcTime;
  Msg8305_V2XT()
      : workType(0),
        optType(0),
        loadState(0),
        materNum(0),
        stopPosNum(0),
        utcTime(0) {
  }
};

inline bool operator==(const Msg8305_V2XT &lhs, const Msg8305_V2XT &rhs) {
  return
      (lhs.auxImei == rhs.auxImei) &&
      (lhs.auxName == rhs.auxName) &&
      (lhs.truckImei == rhs.truckImei) &&
      (lhs.truckName == rhs.truckName) &&
      (lhs.workType == rhs.workType) &&
      (lhs.optType == rhs.optType) &&
      (lhs.loadState == rhs.loadState) &&
      (lhs.materNum == rhs.materNum) &&
      (lhs.stopPosNum == rhs.stopPosNum) &&
      (lhs.utcTime == rhs.utcTime);
}

inline bool operator!=(const Msg8305_V2XT &lhs, const Msg8305_V2XT &rhs) {
    return !(lhs == rhs);
}


struct Msg8305_V2X FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Msg8305_V2XT NativeTableType;
  typedef Msg8305_V2XBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Msg8305_V2XTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AUXIMEI = 4,
    VT_AUXNAME = 6,
    VT_TRUCKIMEI = 8,
    VT_TRUCKNAME = 10,
    VT_WORKTYPE = 12,
    VT_OPTTYPE = 14,
    VT_LOADSTATE = 16,
    VT_MATERNUM = 18,
    VT_STOPPOSNUM = 20,
    VT_UTCTIME = 22
  };
  const flatbuffers::Vector<uint8_t> *auxImei() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_AUXIMEI);
  }
  flatbuffers::Vector<uint8_t> *mutable_auxImei() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_AUXIMEI);
  }
  const flatbuffers::Vector<uint8_t> *auxName() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_AUXNAME);
  }
  flatbuffers::Vector<uint8_t> *mutable_auxName() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_AUXNAME);
  }
  const flatbuffers::Vector<uint8_t> *truckImei() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_TRUCKIMEI);
  }
  flatbuffers::Vector<uint8_t> *mutable_truckImei() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_TRUCKIMEI);
  }
  const flatbuffers::Vector<uint8_t> *truckName() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_TRUCKNAME);
  }
  flatbuffers::Vector<uint8_t> *mutable_truckName() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_TRUCKNAME);
  }
  uint8_t workType() const {
    return GetField<uint8_t>(VT_WORKTYPE, 0);
  }
  bool mutate_workType(uint8_t _workType) {
    return SetField<uint8_t>(VT_WORKTYPE, _workType, 0);
  }
  uint8_t optType() const {
    return GetField<uint8_t>(VT_OPTTYPE, 0);
  }
  bool mutate_optType(uint8_t _optType) {
    return SetField<uint8_t>(VT_OPTTYPE, _optType, 0);
  }
  uint8_t loadState() const {
    return GetField<uint8_t>(VT_LOADSTATE, 0);
  }
  bool mutate_loadState(uint8_t _loadState) {
    return SetField<uint8_t>(VT_LOADSTATE, _loadState, 0);
  }
  uint16_t materNum() const {
    return GetField<uint16_t>(VT_MATERNUM, 0);
  }
  bool mutate_materNum(uint16_t _materNum) {
    return SetField<uint16_t>(VT_MATERNUM, _materNum, 0);
  }
  uint16_t stopPosNum() const {
    return GetField<uint16_t>(VT_STOPPOSNUM, 0);
  }
  bool mutate_stopPosNum(uint16_t _stopPosNum) {
    return SetField<uint16_t>(VT_STOPPOSNUM, _stopPosNum, 0);
  }
  uint64_t utcTime() const {
    return GetField<uint64_t>(VT_UTCTIME, 0);
  }
  bool mutate_utcTime(uint64_t _utcTime) {
    return SetField<uint64_t>(VT_UTCTIME, _utcTime, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_AUXIMEI) &&
           verifier.VerifyVector(auxImei()) &&
           VerifyOffset(verifier, VT_AUXNAME) &&
           verifier.VerifyVector(auxName()) &&
           VerifyOffset(verifier, VT_TRUCKIMEI) &&
           verifier.VerifyVector(truckImei()) &&
           VerifyOffset(verifier, VT_TRUCKNAME) &&
           verifier.VerifyVector(truckName()) &&
           VerifyField<uint8_t>(verifier, VT_WORKTYPE) &&
           VerifyField<uint8_t>(verifier, VT_OPTTYPE) &&
           VerifyField<uint8_t>(verifier, VT_LOADSTATE) &&
           VerifyField<uint16_t>(verifier, VT_MATERNUM) &&
           VerifyField<uint16_t>(verifier, VT_STOPPOSNUM) &&
           VerifyField<uint64_t>(verifier, VT_UTCTIME) &&
           verifier.EndTable();
  }
  Msg8305_V2XT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Msg8305_V2XT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Msg8305_V2X> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg8305_V2XT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Msg8305_V2XBuilder {
  typedef Msg8305_V2X Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_auxImei(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> auxImei) {
    fbb_.AddOffset(Msg8305_V2X::VT_AUXIMEI, auxImei);
  }
  void add_auxName(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> auxName) {
    fbb_.AddOffset(Msg8305_V2X::VT_AUXNAME, auxName);
  }
  void add_truckImei(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> truckImei) {
    fbb_.AddOffset(Msg8305_V2X::VT_TRUCKIMEI, truckImei);
  }
  void add_truckName(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> truckName) {
    fbb_.AddOffset(Msg8305_V2X::VT_TRUCKNAME, truckName);
  }
  void add_workType(uint8_t workType) {
    fbb_.AddElement<uint8_t>(Msg8305_V2X::VT_WORKTYPE, workType, 0);
  }
  void add_optType(uint8_t optType) {
    fbb_.AddElement<uint8_t>(Msg8305_V2X::VT_OPTTYPE, optType, 0);
  }
  void add_loadState(uint8_t loadState) {
    fbb_.AddElement<uint8_t>(Msg8305_V2X::VT_LOADSTATE, loadState, 0);
  }
  void add_materNum(uint16_t materNum) {
    fbb_.AddElement<uint16_t>(Msg8305_V2X::VT_MATERNUM, materNum, 0);
  }
  void add_stopPosNum(uint16_t stopPosNum) {
    fbb_.AddElement<uint16_t>(Msg8305_V2X::VT_STOPPOSNUM, stopPosNum, 0);
  }
  void add_utcTime(uint64_t utcTime) {
    fbb_.AddElement<uint64_t>(Msg8305_V2X::VT_UTCTIME, utcTime, 0);
  }
  explicit Msg8305_V2XBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Msg8305_V2X> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Msg8305_V2X>(end);
    return o;
  }
};

inline flatbuffers::Offset<Msg8305_V2X> CreateMsg8305_V2X(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> auxImei = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> auxName = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> truckImei = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> truckName = 0,
    uint8_t workType = 0,
    uint8_t optType = 0,
    uint8_t loadState = 0,
    uint16_t materNum = 0,
    uint16_t stopPosNum = 0,
    uint64_t utcTime = 0) {
  Msg8305_V2XBuilder builder_(_fbb);
  builder_.add_utcTime(utcTime);
  builder_.add_truckName(truckName);
  builder_.add_truckImei(truckImei);
  builder_.add_auxName(auxName);
  builder_.add_auxImei(auxImei);
  builder_.add_stopPosNum(stopPosNum);
  builder_.add_materNum(materNum);
  builder_.add_loadState(loadState);
  builder_.add_optType(optType);
  builder_.add_workType(workType);
  return builder_.Finish();
}

inline flatbuffers::Offset<Msg8305_V2X> CreateMsg8305_V2XDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *auxImei = nullptr,
    const std::vector<uint8_t> *auxName = nullptr,
    const std::vector<uint8_t> *truckImei = nullptr,
    const std::vector<uint8_t> *truckName = nullptr,
    uint8_t workType = 0,
    uint8_t optType = 0,
    uint8_t loadState = 0,
    uint16_t materNum = 0,
    uint16_t stopPosNum = 0,
    uint64_t utcTime = 0) {
  auto auxImei__ = auxImei ? _fbb.CreateVector<uint8_t>(*auxImei) : 0;
  auto auxName__ = auxName ? _fbb.CreateVector<uint8_t>(*auxName) : 0;
  auto truckImei__ = truckImei ? _fbb.CreateVector<uint8_t>(*truckImei) : 0;
  auto truckName__ = truckName ? _fbb.CreateVector<uint8_t>(*truckName) : 0;
  return CreateMsg8305_V2X(
      _fbb,
      auxImei__,
      auxName__,
      truckImei__,
      truckName__,
      workType,
      optType,
      loadState,
      materNum,
      stopPosNum,
      utcTime);
}

flatbuffers::Offset<Msg8305_V2X> CreateMsg8305_V2X(flatbuffers::FlatBufferBuilder &_fbb, const Msg8305_V2XT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Msg8F0BT : public flatbuffers::NativeTable {
  typedef Msg8F0B TableType;
  uint16_t id;
  uint8_t file_type;
  uint8_t file_area;
  uint8_t file_result;
  std::string file_MD5;
  std::string file_name;
  Msg8F0BT()
      : id(0),
        file_type(0),
        file_area(0),
        file_result(0) {
  }
};

inline bool operator==(const Msg8F0BT &lhs, const Msg8F0BT &rhs) {
  return
      (lhs.id == rhs.id) &&
      (lhs.file_type == rhs.file_type) &&
      (lhs.file_area == rhs.file_area) &&
      (lhs.file_result == rhs.file_result) &&
      (lhs.file_MD5 == rhs.file_MD5) &&
      (lhs.file_name == rhs.file_name);
}

inline bool operator!=(const Msg8F0BT &lhs, const Msg8F0BT &rhs) {
    return !(lhs == rhs);
}


struct Msg8F0B FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Msg8F0BT NativeTableType;
  typedef Msg8F0BBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Msg8F0BTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_FILE_TYPE = 6,
    VT_FILE_AREA = 8,
    VT_FILE_RESULT = 10,
    VT_FILE_MD5 = 12,
    VT_FILE_NAME = 14
  };
  uint16_t id() const {
    return GetField<uint16_t>(VT_ID, 0);
  }
  bool mutate_id(uint16_t _id) {
    return SetField<uint16_t>(VT_ID, _id, 0);
  }
  uint8_t file_type() const {
    return GetField<uint8_t>(VT_FILE_TYPE, 0);
  }
  bool mutate_file_type(uint8_t _file_type) {
    return SetField<uint8_t>(VT_FILE_TYPE, _file_type, 0);
  }
  uint8_t file_area() const {
    return GetField<uint8_t>(VT_FILE_AREA, 0);
  }
  bool mutate_file_area(uint8_t _file_area) {
    return SetField<uint8_t>(VT_FILE_AREA, _file_area, 0);
  }
  uint8_t file_result() const {
    return GetField<uint8_t>(VT_FILE_RESULT, 0);
  }
  bool mutate_file_result(uint8_t _file_result) {
    return SetField<uint8_t>(VT_FILE_RESULT, _file_result, 0);
  }
  const flatbuffers::String *file_MD5() const {
    return GetPointer<const flatbuffers::String *>(VT_FILE_MD5);
  }
  flatbuffers::String *mutable_file_MD5() {
    return GetPointer<flatbuffers::String *>(VT_FILE_MD5);
  }
  const flatbuffers::String *file_name() const {
    return GetPointer<const flatbuffers::String *>(VT_FILE_NAME);
  }
  flatbuffers::String *mutable_file_name() {
    return GetPointer<flatbuffers::String *>(VT_FILE_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ID) &&
           VerifyField<uint8_t>(verifier, VT_FILE_TYPE) &&
           VerifyField<uint8_t>(verifier, VT_FILE_AREA) &&
           VerifyField<uint8_t>(verifier, VT_FILE_RESULT) &&
           VerifyOffset(verifier, VT_FILE_MD5) &&
           verifier.VerifyString(file_MD5()) &&
           VerifyOffset(verifier, VT_FILE_NAME) &&
           verifier.VerifyString(file_name()) &&
           verifier.EndTable();
  }
  Msg8F0BT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Msg8F0BT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Msg8F0B> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg8F0BT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Msg8F0BBuilder {
  typedef Msg8F0B Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint16_t id) {
    fbb_.AddElement<uint16_t>(Msg8F0B::VT_ID, id, 0);
  }
  void add_file_type(uint8_t file_type) {
    fbb_.AddElement<uint8_t>(Msg8F0B::VT_FILE_TYPE, file_type, 0);
  }
  void add_file_area(uint8_t file_area) {
    fbb_.AddElement<uint8_t>(Msg8F0B::VT_FILE_AREA, file_area, 0);
  }
  void add_file_result(uint8_t file_result) {
    fbb_.AddElement<uint8_t>(Msg8F0B::VT_FILE_RESULT, file_result, 0);
  }
  void add_file_MD5(flatbuffers::Offset<flatbuffers::String> file_MD5) {
    fbb_.AddOffset(Msg8F0B::VT_FILE_MD5, file_MD5);
  }
  void add_file_name(flatbuffers::Offset<flatbuffers::String> file_name) {
    fbb_.AddOffset(Msg8F0B::VT_FILE_NAME, file_name);
  }
  explicit Msg8F0BBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Msg8F0B> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Msg8F0B>(end);
    return o;
  }
};

inline flatbuffers::Offset<Msg8F0B> CreateMsg8F0B(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t id = 0,
    uint8_t file_type = 0,
    uint8_t file_area = 0,
    uint8_t file_result = 0,
    flatbuffers::Offset<flatbuffers::String> file_MD5 = 0,
    flatbuffers::Offset<flatbuffers::String> file_name = 0) {
  Msg8F0BBuilder builder_(_fbb);
  builder_.add_file_name(file_name);
  builder_.add_file_MD5(file_MD5);
  builder_.add_id(id);
  builder_.add_file_result(file_result);
  builder_.add_file_area(file_area);
  builder_.add_file_type(file_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Msg8F0B> CreateMsg8F0BDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t id = 0,
    uint8_t file_type = 0,
    uint8_t file_area = 0,
    uint8_t file_result = 0,
    const char *file_MD5 = nullptr,
    const char *file_name = nullptr) {
  auto file_MD5__ = file_MD5 ? _fbb.CreateString(file_MD5) : 0;
  auto file_name__ = file_name ? _fbb.CreateString(file_name) : 0;
  return CreateMsg8F0B(
      _fbb,
      id,
      file_type,
      file_area,
      file_result,
      file_MD5__,
      file_name__);
}

flatbuffers::Offset<Msg8F0B> CreateMsg8F0B(flatbuffers::FlatBufferBuilder &_fbb, const Msg8F0BT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Msg0502T : public flatbuffers::NativeTable {
  typedef Msg0502 TableType;
  uint16_t id;
  uint8_t trigger_type;
  Msg0502T()
      : id(0),
        trigger_type(0) {
  }
};

inline bool operator==(const Msg0502T &lhs, const Msg0502T &rhs) {
  return
      (lhs.id == rhs.id) &&
      (lhs.trigger_type == rhs.trigger_type);
}

inline bool operator!=(const Msg0502T &lhs, const Msg0502T &rhs) {
    return !(lhs == rhs);
}


struct Msg0502 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Msg0502T NativeTableType;
  typedef Msg0502Builder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Msg0502TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TRIGGER_TYPE = 6
  };
  uint16_t id() const {
    return GetField<uint16_t>(VT_ID, 0);
  }
  bool mutate_id(uint16_t _id) {
    return SetField<uint16_t>(VT_ID, _id, 0);
  }
  uint8_t trigger_type() const {
    return GetField<uint8_t>(VT_TRIGGER_TYPE, 0);
  }
  bool mutate_trigger_type(uint8_t _trigger_type) {
    return SetField<uint8_t>(VT_TRIGGER_TYPE, _trigger_type, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ID) &&
           VerifyField<uint8_t>(verifier, VT_TRIGGER_TYPE) &&
           verifier.EndTable();
  }
  Msg0502T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Msg0502T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Msg0502> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg0502T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Msg0502Builder {
  typedef Msg0502 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint16_t id) {
    fbb_.AddElement<uint16_t>(Msg0502::VT_ID, id, 0);
  }
  void add_trigger_type(uint8_t trigger_type) {
    fbb_.AddElement<uint8_t>(Msg0502::VT_TRIGGER_TYPE, trigger_type, 0);
  }
  explicit Msg0502Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Msg0502> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Msg0502>(end);
    return o;
  }
};

inline flatbuffers::Offset<Msg0502> CreateMsg0502(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t id = 0,
    uint8_t trigger_type = 0) {
  Msg0502Builder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_trigger_type(trigger_type);
  return builder_.Finish();
}

flatbuffers::Offset<Msg0502> CreateMsg0502(flatbuffers::FlatBufferBuilder &_fbb, const Msg0502T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Msg0F01T : public flatbuffers::NativeTable {
  typedef Msg0F01 TableType;
  uint16_t id;
  uint8_t work_type;
  uint16_t delayed_fault_reason;
  uint16_t delayed_time;
  Msg0F01T()
      : id(0),
        work_type(0),
        delayed_fault_reason(0),
        delayed_time(0) {
  }
};

inline bool operator==(const Msg0F01T &lhs, const Msg0F01T &rhs) {
  return
      (lhs.id == rhs.id) &&
      (lhs.work_type == rhs.work_type) &&
      (lhs.delayed_fault_reason == rhs.delayed_fault_reason) &&
      (lhs.delayed_time == rhs.delayed_time);
}

inline bool operator!=(const Msg0F01T &lhs, const Msg0F01T &rhs) {
    return !(lhs == rhs);
}


struct Msg0F01 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Msg0F01T NativeTableType;
  typedef Msg0F01Builder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Msg0F01TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_WORK_TYPE = 6,
    VT_DELAYED_FAULT_REASON = 8,
    VT_DELAYED_TIME = 10
  };
  uint16_t id() const {
    return GetField<uint16_t>(VT_ID, 0);
  }
  bool mutate_id(uint16_t _id) {
    return SetField<uint16_t>(VT_ID, _id, 0);
  }
  uint8_t work_type() const {
    return GetField<uint8_t>(VT_WORK_TYPE, 0);
  }
  bool mutate_work_type(uint8_t _work_type) {
    return SetField<uint8_t>(VT_WORK_TYPE, _work_type, 0);
  }
  uint16_t delayed_fault_reason() const {
    return GetField<uint16_t>(VT_DELAYED_FAULT_REASON, 0);
  }
  bool mutate_delayed_fault_reason(uint16_t _delayed_fault_reason) {
    return SetField<uint16_t>(VT_DELAYED_FAULT_REASON, _delayed_fault_reason, 0);
  }
  uint16_t delayed_time() const {
    return GetField<uint16_t>(VT_DELAYED_TIME, 0);
  }
  bool mutate_delayed_time(uint16_t _delayed_time) {
    return SetField<uint16_t>(VT_DELAYED_TIME, _delayed_time, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ID) &&
           VerifyField<uint8_t>(verifier, VT_WORK_TYPE) &&
           VerifyField<uint16_t>(verifier, VT_DELAYED_FAULT_REASON) &&
           VerifyField<uint16_t>(verifier, VT_DELAYED_TIME) &&
           verifier.EndTable();
  }
  Msg0F01T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Msg0F01T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Msg0F01> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg0F01T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Msg0F01Builder {
  typedef Msg0F01 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint16_t id) {
    fbb_.AddElement<uint16_t>(Msg0F01::VT_ID, id, 0);
  }
  void add_work_type(uint8_t work_type) {
    fbb_.AddElement<uint8_t>(Msg0F01::VT_WORK_TYPE, work_type, 0);
  }
  void add_delayed_fault_reason(uint16_t delayed_fault_reason) {
    fbb_.AddElement<uint16_t>(Msg0F01::VT_DELAYED_FAULT_REASON, delayed_fault_reason, 0);
  }
  void add_delayed_time(uint16_t delayed_time) {
    fbb_.AddElement<uint16_t>(Msg0F01::VT_DELAYED_TIME, delayed_time, 0);
  }
  explicit Msg0F01Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Msg0F01> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Msg0F01>(end);
    return o;
  }
};

inline flatbuffers::Offset<Msg0F01> CreateMsg0F01(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t id = 0,
    uint8_t work_type = 0,
    uint16_t delayed_fault_reason = 0,
    uint16_t delayed_time = 0) {
  Msg0F01Builder builder_(_fbb);
  builder_.add_delayed_time(delayed_time);
  builder_.add_delayed_fault_reason(delayed_fault_reason);
  builder_.add_id(id);
  builder_.add_work_type(work_type);
  return builder_.Finish();
}

flatbuffers::Offset<Msg0F01> CreateMsg0F01(flatbuffers::FlatBufferBuilder &_fbb, const Msg0F01T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Msg0F0ET : public flatbuffers::NativeTable {
  typedef Msg0F0E TableType;
  uint16_t id;
  std::vector<uint8_t> apply_number;
  uint8_t clear_fault;
  std::vector<uint8_t> warning;
  uint8_t sourceflag;
  Msg0F0ET()
      : id(0),
        clear_fault(0),
        sourceflag(0) {
  }
};

inline bool operator==(const Msg0F0ET &lhs, const Msg0F0ET &rhs) {
  return
      (lhs.id == rhs.id) &&
      (lhs.apply_number == rhs.apply_number) &&
      (lhs.clear_fault == rhs.clear_fault) &&
      (lhs.warning == rhs.warning) &&
      (lhs.sourceflag == rhs.sourceflag);
}

inline bool operator!=(const Msg0F0ET &lhs, const Msg0F0ET &rhs) {
    return !(lhs == rhs);
}


struct Msg0F0E FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Msg0F0ET NativeTableType;
  typedef Msg0F0EBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Msg0F0ETypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_APPLY_NUMBER = 6,
    VT_CLEAR_FAULT = 8,
    VT_WARNING = 10,
    VT_SOURCEFLAG = 12
  };
  uint16_t id() const {
    return GetField<uint16_t>(VT_ID, 0);
  }
  bool mutate_id(uint16_t _id) {
    return SetField<uint16_t>(VT_ID, _id, 0);
  }
  const flatbuffers::Vector<uint8_t> *apply_number() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_APPLY_NUMBER);
  }
  flatbuffers::Vector<uint8_t> *mutable_apply_number() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_APPLY_NUMBER);
  }
  uint8_t clear_fault() const {
    return GetField<uint8_t>(VT_CLEAR_FAULT, 0);
  }
  bool mutate_clear_fault(uint8_t _clear_fault) {
    return SetField<uint8_t>(VT_CLEAR_FAULT, _clear_fault, 0);
  }
  const flatbuffers::Vector<uint8_t> *warning() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_WARNING);
  }
  flatbuffers::Vector<uint8_t> *mutable_warning() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_WARNING);
  }
  uint8_t sourceflag() const {
    return GetField<uint8_t>(VT_SOURCEFLAG, 0);
  }
  bool mutate_sourceflag(uint8_t _sourceflag) {
    return SetField<uint8_t>(VT_SOURCEFLAG, _sourceflag, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ID) &&
           VerifyOffset(verifier, VT_APPLY_NUMBER) &&
           verifier.VerifyVector(apply_number()) &&
           VerifyField<uint8_t>(verifier, VT_CLEAR_FAULT) &&
           VerifyOffset(verifier, VT_WARNING) &&
           verifier.VerifyVector(warning()) &&
           VerifyField<uint8_t>(verifier, VT_SOURCEFLAG) &&
           verifier.EndTable();
  }
  Msg0F0ET *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Msg0F0ET *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Msg0F0E> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg0F0ET* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Msg0F0EBuilder {
  typedef Msg0F0E Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint16_t id) {
    fbb_.AddElement<uint16_t>(Msg0F0E::VT_ID, id, 0);
  }
  void add_apply_number(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> apply_number) {
    fbb_.AddOffset(Msg0F0E::VT_APPLY_NUMBER, apply_number);
  }
  void add_clear_fault(uint8_t clear_fault) {
    fbb_.AddElement<uint8_t>(Msg0F0E::VT_CLEAR_FAULT, clear_fault, 0);
  }
  void add_warning(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> warning) {
    fbb_.AddOffset(Msg0F0E::VT_WARNING, warning);
  }
  void add_sourceflag(uint8_t sourceflag) {
    fbb_.AddElement<uint8_t>(Msg0F0E::VT_SOURCEFLAG, sourceflag, 0);
  }
  explicit Msg0F0EBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Msg0F0E> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Msg0F0E>(end);
    return o;
  }
};

inline flatbuffers::Offset<Msg0F0E> CreateMsg0F0E(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t id = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> apply_number = 0,
    uint8_t clear_fault = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> warning = 0,
    uint8_t sourceflag = 0) {
  Msg0F0EBuilder builder_(_fbb);
  builder_.add_warning(warning);
  builder_.add_apply_number(apply_number);
  builder_.add_id(id);
  builder_.add_sourceflag(sourceflag);
  builder_.add_clear_fault(clear_fault);
  return builder_.Finish();
}

inline flatbuffers::Offset<Msg0F0E> CreateMsg0F0EDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t id = 0,
    const std::vector<uint8_t> *apply_number = nullptr,
    uint8_t clear_fault = 0,
    const std::vector<uint8_t> *warning = nullptr,
    uint8_t sourceflag = 0) {
  auto apply_number__ = apply_number ? _fbb.CreateVector<uint8_t>(*apply_number) : 0;
  auto warning__ = warning ? _fbb.CreateVector<uint8_t>(*warning) : 0;
  return CreateMsg0F0E(
      _fbb,
      id,
      apply_number__,
      clear_fault,
      warning__,
      sourceflag);
}

flatbuffers::Offset<Msg0F0E> CreateMsg0F0E(flatbuffers::FlatBufferBuilder &_fbb, const Msg0F0ET *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Msg0F1CT : public flatbuffers::NativeTable {
  typedef Msg0F1C TableType;
  uint16_t id;
  uint8_t test_type;
  Msg0F1CT()
      : id(0),
        test_type(0) {
  }
};

inline bool operator==(const Msg0F1CT &lhs, const Msg0F1CT &rhs) {
  return
      (lhs.id == rhs.id) &&
      (lhs.test_type == rhs.test_type);
}

inline bool operator!=(const Msg0F1CT &lhs, const Msg0F1CT &rhs) {
    return !(lhs == rhs);
}


struct Msg0F1C FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Msg0F1CT NativeTableType;
  typedef Msg0F1CBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Msg0F1CTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TEST_TYPE = 6
  };
  uint16_t id() const {
    return GetField<uint16_t>(VT_ID, 0);
  }
  bool mutate_id(uint16_t _id) {
    return SetField<uint16_t>(VT_ID, _id, 0);
  }
  uint8_t test_type() const {
    return GetField<uint8_t>(VT_TEST_TYPE, 0);
  }
  bool mutate_test_type(uint8_t _test_type) {
    return SetField<uint8_t>(VT_TEST_TYPE, _test_type, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ID) &&
           VerifyField<uint8_t>(verifier, VT_TEST_TYPE) &&
           verifier.EndTable();
  }
  Msg0F1CT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Msg0F1CT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Msg0F1C> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg0F1CT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Msg0F1CBuilder {
  typedef Msg0F1C Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint16_t id) {
    fbb_.AddElement<uint16_t>(Msg0F1C::VT_ID, id, 0);
  }
  void add_test_type(uint8_t test_type) {
    fbb_.AddElement<uint8_t>(Msg0F1C::VT_TEST_TYPE, test_type, 0);
  }
  explicit Msg0F1CBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Msg0F1C> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Msg0F1C>(end);
    return o;
  }
};

inline flatbuffers::Offset<Msg0F1C> CreateMsg0F1C(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t id = 0,
    uint8_t test_type = 0) {
  Msg0F1CBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_test_type(test_type);
  return builder_.Finish();
}

flatbuffers::Offset<Msg0F1C> CreateMsg0F1C(flatbuffers::FlatBufferBuilder &_fbb, const Msg0F1CT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Msg0F10T : public flatbuffers::NativeTable {
  typedef Msg0F10 TableType;
  uint16_t id;
  uint16_t number;
  std::vector<uint8_t> password;
  Msg0F10T()
      : id(0),
        number(0) {
  }
};

inline bool operator==(const Msg0F10T &lhs, const Msg0F10T &rhs) {
  return
      (lhs.id == rhs.id) &&
      (lhs.number == rhs.number) &&
      (lhs.password == rhs.password);
}

inline bool operator!=(const Msg0F10T &lhs, const Msg0F10T &rhs) {
    return !(lhs == rhs);
}


struct Msg0F10 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Msg0F10T NativeTableType;
  typedef Msg0F10Builder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Msg0F10TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NUMBER = 6,
    VT_PASSWORD = 8
  };
  uint16_t id() const {
    return GetField<uint16_t>(VT_ID, 0);
  }
  bool mutate_id(uint16_t _id) {
    return SetField<uint16_t>(VT_ID, _id, 0);
  }
  uint16_t number() const {
    return GetField<uint16_t>(VT_NUMBER, 0);
  }
  bool mutate_number(uint16_t _number) {
    return SetField<uint16_t>(VT_NUMBER, _number, 0);
  }
  const flatbuffers::Vector<uint8_t> *password() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_PASSWORD);
  }
  flatbuffers::Vector<uint8_t> *mutable_password() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_PASSWORD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ID) &&
           VerifyField<uint16_t>(verifier, VT_NUMBER) &&
           VerifyOffset(verifier, VT_PASSWORD) &&
           verifier.VerifyVector(password()) &&
           verifier.EndTable();
  }
  Msg0F10T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Msg0F10T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Msg0F10> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg0F10T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Msg0F10Builder {
  typedef Msg0F10 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint16_t id) {
    fbb_.AddElement<uint16_t>(Msg0F10::VT_ID, id, 0);
  }
  void add_number(uint16_t number) {
    fbb_.AddElement<uint16_t>(Msg0F10::VT_NUMBER, number, 0);
  }
  void add_password(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> password) {
    fbb_.AddOffset(Msg0F10::VT_PASSWORD, password);
  }
  explicit Msg0F10Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Msg0F10> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Msg0F10>(end);
    return o;
  }
};

inline flatbuffers::Offset<Msg0F10> CreateMsg0F10(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t id = 0,
    uint16_t number = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> password = 0) {
  Msg0F10Builder builder_(_fbb);
  builder_.add_password(password);
  builder_.add_number(number);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Msg0F10> CreateMsg0F10Direct(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t id = 0,
    uint16_t number = 0,
    const std::vector<uint8_t> *password = nullptr) {
  auto password__ = password ? _fbb.CreateVector<uint8_t>(*password) : 0;
  return CreateMsg0F10(
      _fbb,
      id,
      number,
      password__);
}

flatbuffers::Offset<Msg0F10> CreateMsg0F10(flatbuffers::FlatBufferBuilder &_fbb, const Msg0F10T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Msg0F11T : public flatbuffers::NativeTable {
  typedef Msg0F11 TableType;
  uint16_t id;
  Msg0F11T()
      : id(0) {
  }
};

inline bool operator==(const Msg0F11T &lhs, const Msg0F11T &rhs) {
  return
      (lhs.id == rhs.id);
}

inline bool operator!=(const Msg0F11T &lhs, const Msg0F11T &rhs) {
    return !(lhs == rhs);
}


struct Msg0F11 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Msg0F11T NativeTableType;
  typedef Msg0F11Builder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Msg0F11TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  uint16_t id() const {
    return GetField<uint16_t>(VT_ID, 0);
  }
  bool mutate_id(uint16_t _id) {
    return SetField<uint16_t>(VT_ID, _id, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ID) &&
           verifier.EndTable();
  }
  Msg0F11T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Msg0F11T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Msg0F11> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg0F11T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Msg0F11Builder {
  typedef Msg0F11 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint16_t id) {
    fbb_.AddElement<uint16_t>(Msg0F11::VT_ID, id, 0);
  }
  explicit Msg0F11Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Msg0F11> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Msg0F11>(end);
    return o;
  }
};

inline flatbuffers::Offset<Msg0F11> CreateMsg0F11(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t id = 0) {
  Msg0F11Builder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

flatbuffers::Offset<Msg0F11> CreateMsg0F11(flatbuffers::FlatBufferBuilder &_fbb, const Msg0F11T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MsgTx_0104T : public flatbuffers::NativeTable {
  typedef MsgTx_0104 TableType;
  MsgTx_0104T() {
  }
};

inline bool operator==(const MsgTx_0104T &, const MsgTx_0104T &) {
  return true;
}

inline bool operator!=(const MsgTx_0104T &lhs, const MsgTx_0104T &rhs) {
    return !(lhs == rhs);
}


struct MsgTx_0104 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MsgTx_0104T NativeTableType;
  typedef MsgTx_0104Builder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MsgTx_0104TypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  MsgTx_0104T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MsgTx_0104T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MsgTx_0104> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MsgTx_0104T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MsgTx_0104Builder {
  typedef MsgTx_0104 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit MsgTx_0104Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MsgTx_0104> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MsgTx_0104>(end);
    return o;
  }
};

inline flatbuffers::Offset<MsgTx_0104> CreateMsgTx_0104(
    flatbuffers::FlatBufferBuilder &_fbb) {
  MsgTx_0104Builder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<MsgTx_0104> CreateMsgTx_0104(flatbuffers::FlatBufferBuilder &_fbb, const MsgTx_0104T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MsgTx_0F03T : public flatbuffers::NativeTable {
  typedef MsgTx_0F03 TableType;
  uint16_t material;
  MsgTx_0F03T()
      : material(0) {
  }
};

inline bool operator==(const MsgTx_0F03T &lhs, const MsgTx_0F03T &rhs) {
  return
      (lhs.material == rhs.material);
}

inline bool operator!=(const MsgTx_0F03T &lhs, const MsgTx_0F03T &rhs) {
    return !(lhs == rhs);
}


struct MsgTx_0F03 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MsgTx_0F03T NativeTableType;
  typedef MsgTx_0F03Builder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MsgTx_0F03TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MATERIAL = 4
  };
  uint16_t material() const {
    return GetField<uint16_t>(VT_MATERIAL, 0);
  }
  bool mutate_material(uint16_t _material) {
    return SetField<uint16_t>(VT_MATERIAL, _material, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_MATERIAL) &&
           verifier.EndTable();
  }
  MsgTx_0F03T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MsgTx_0F03T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MsgTx_0F03> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MsgTx_0F03T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MsgTx_0F03Builder {
  typedef MsgTx_0F03 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_material(uint16_t material) {
    fbb_.AddElement<uint16_t>(MsgTx_0F03::VT_MATERIAL, material, 0);
  }
  explicit MsgTx_0F03Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MsgTx_0F03> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MsgTx_0F03>(end);
    return o;
  }
};

inline flatbuffers::Offset<MsgTx_0F03> CreateMsgTx_0F03(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t material = 0) {
  MsgTx_0F03Builder builder_(_fbb);
  builder_.add_material(material);
  return builder_.Finish();
}

flatbuffers::Offset<MsgTx_0F03> CreateMsgTx_0F03(flatbuffers::FlatBufferBuilder &_fbb, const MsgTx_0F03T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MsgTx_0F09T : public flatbuffers::NativeTable {
  typedef MsgTx_0F09 TableType;
  uint8_t warn_type;
  uint16_t lane_num;
  MsgTx_0F09T()
      : warn_type(0),
        lane_num(0) {
  }
};

inline bool operator==(const MsgTx_0F09T &lhs, const MsgTx_0F09T &rhs) {
  return
      (lhs.warn_type == rhs.warn_type) &&
      (lhs.lane_num == rhs.lane_num);
}

inline bool operator!=(const MsgTx_0F09T &lhs, const MsgTx_0F09T &rhs) {
    return !(lhs == rhs);
}


struct MsgTx_0F09 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MsgTx_0F09T NativeTableType;
  typedef MsgTx_0F09Builder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MsgTx_0F09TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WARN_TYPE = 4,
    VT_LANE_NUM = 6
  };
  uint8_t warn_type() const {
    return GetField<uint8_t>(VT_WARN_TYPE, 0);
  }
  bool mutate_warn_type(uint8_t _warn_type) {
    return SetField<uint8_t>(VT_WARN_TYPE, _warn_type, 0);
  }
  uint16_t lane_num() const {
    return GetField<uint16_t>(VT_LANE_NUM, 0);
  }
  bool mutate_lane_num(uint16_t _lane_num) {
    return SetField<uint16_t>(VT_LANE_NUM, _lane_num, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_WARN_TYPE) &&
           VerifyField<uint16_t>(verifier, VT_LANE_NUM) &&
           verifier.EndTable();
  }
  MsgTx_0F09T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MsgTx_0F09T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MsgTx_0F09> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MsgTx_0F09T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MsgTx_0F09Builder {
  typedef MsgTx_0F09 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_warn_type(uint8_t warn_type) {
    fbb_.AddElement<uint8_t>(MsgTx_0F09::VT_WARN_TYPE, warn_type, 0);
  }
  void add_lane_num(uint16_t lane_num) {
    fbb_.AddElement<uint16_t>(MsgTx_0F09::VT_LANE_NUM, lane_num, 0);
  }
  explicit MsgTx_0F09Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MsgTx_0F09> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MsgTx_0F09>(end);
    return o;
  }
};

inline flatbuffers::Offset<MsgTx_0F09> CreateMsgTx_0F09(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t warn_type = 0,
    uint16_t lane_num = 0) {
  MsgTx_0F09Builder builder_(_fbb);
  builder_.add_lane_num(lane_num);
  builder_.add_warn_type(warn_type);
  return builder_.Finish();
}

flatbuffers::Offset<MsgTx_0F09> CreateMsgTx_0F09(flatbuffers::FlatBufferBuilder &_fbb, const MsgTx_0F09T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MsgTx_8305T : public flatbuffers::NativeTable {
  typedef MsgTx_8305 TableType;
  std::string remote_imei;
  std::string remote_name;
  uint8_t task_type;
  uint8_t cmd_type;
  uint8_t load_status;
  uint16_t material_type;
  uint16_t stop_num;
  uint64_t utcTime;
  MsgTx_8305T()
      : task_type(0),
        cmd_type(0),
        load_status(0),
        material_type(0),
        stop_num(0),
        utcTime(0) {
  }
};

inline bool operator==(const MsgTx_8305T &lhs, const MsgTx_8305T &rhs) {
  return
      (lhs.remote_imei == rhs.remote_imei) &&
      (lhs.remote_name == rhs.remote_name) &&
      (lhs.task_type == rhs.task_type) &&
      (lhs.cmd_type == rhs.cmd_type) &&
      (lhs.load_status == rhs.load_status) &&
      (lhs.material_type == rhs.material_type) &&
      (lhs.stop_num == rhs.stop_num) &&
      (lhs.utcTime == rhs.utcTime);
}

inline bool operator!=(const MsgTx_8305T &lhs, const MsgTx_8305T &rhs) {
    return !(lhs == rhs);
}


struct MsgTx_8305 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MsgTx_8305T NativeTableType;
  typedef MsgTx_8305Builder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MsgTx_8305TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REMOTE_IMEI = 4,
    VT_REMOTE_NAME = 6,
    VT_TASK_TYPE = 8,
    VT_CMD_TYPE = 10,
    VT_LOAD_STATUS = 12,
    VT_MATERIAL_TYPE = 14,
    VT_STOP_NUM = 16,
    VT_UTCTIME = 18
  };
  const flatbuffers::String *remote_imei() const {
    return GetPointer<const flatbuffers::String *>(VT_REMOTE_IMEI);
  }
  flatbuffers::String *mutable_remote_imei() {
    return GetPointer<flatbuffers::String *>(VT_REMOTE_IMEI);
  }
  const flatbuffers::String *remote_name() const {
    return GetPointer<const flatbuffers::String *>(VT_REMOTE_NAME);
  }
  flatbuffers::String *mutable_remote_name() {
    return GetPointer<flatbuffers::String *>(VT_REMOTE_NAME);
  }
  uint8_t task_type() const {
    return GetField<uint8_t>(VT_TASK_TYPE, 0);
  }
  bool mutate_task_type(uint8_t _task_type) {
    return SetField<uint8_t>(VT_TASK_TYPE, _task_type, 0);
  }
  uint8_t cmd_type() const {
    return GetField<uint8_t>(VT_CMD_TYPE, 0);
  }
  bool mutate_cmd_type(uint8_t _cmd_type) {
    return SetField<uint8_t>(VT_CMD_TYPE, _cmd_type, 0);
  }
  uint8_t load_status() const {
    return GetField<uint8_t>(VT_LOAD_STATUS, 0);
  }
  bool mutate_load_status(uint8_t _load_status) {
    return SetField<uint8_t>(VT_LOAD_STATUS, _load_status, 0);
  }
  uint16_t material_type() const {
    return GetField<uint16_t>(VT_MATERIAL_TYPE, 0);
  }
  bool mutate_material_type(uint16_t _material_type) {
    return SetField<uint16_t>(VT_MATERIAL_TYPE, _material_type, 0);
  }
  uint16_t stop_num() const {
    return GetField<uint16_t>(VT_STOP_NUM, 0);
  }
  bool mutate_stop_num(uint16_t _stop_num) {
    return SetField<uint16_t>(VT_STOP_NUM, _stop_num, 0);
  }
  uint64_t utcTime() const {
    return GetField<uint64_t>(VT_UTCTIME, 0);
  }
  bool mutate_utcTime(uint64_t _utcTime) {
    return SetField<uint64_t>(VT_UTCTIME, _utcTime, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_REMOTE_IMEI) &&
           verifier.VerifyString(remote_imei()) &&
           VerifyOffset(verifier, VT_REMOTE_NAME) &&
           verifier.VerifyString(remote_name()) &&
           VerifyField<uint8_t>(verifier, VT_TASK_TYPE) &&
           VerifyField<uint8_t>(verifier, VT_CMD_TYPE) &&
           VerifyField<uint8_t>(verifier, VT_LOAD_STATUS) &&
           VerifyField<uint16_t>(verifier, VT_MATERIAL_TYPE) &&
           VerifyField<uint16_t>(verifier, VT_STOP_NUM) &&
           VerifyField<uint64_t>(verifier, VT_UTCTIME) &&
           verifier.EndTable();
  }
  MsgTx_8305T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MsgTx_8305T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MsgTx_8305> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MsgTx_8305T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MsgTx_8305Builder {
  typedef MsgTx_8305 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_remote_imei(flatbuffers::Offset<flatbuffers::String> remote_imei) {
    fbb_.AddOffset(MsgTx_8305::VT_REMOTE_IMEI, remote_imei);
  }
  void add_remote_name(flatbuffers::Offset<flatbuffers::String> remote_name) {
    fbb_.AddOffset(MsgTx_8305::VT_REMOTE_NAME, remote_name);
  }
  void add_task_type(uint8_t task_type) {
    fbb_.AddElement<uint8_t>(MsgTx_8305::VT_TASK_TYPE, task_type, 0);
  }
  void add_cmd_type(uint8_t cmd_type) {
    fbb_.AddElement<uint8_t>(MsgTx_8305::VT_CMD_TYPE, cmd_type, 0);
  }
  void add_load_status(uint8_t load_status) {
    fbb_.AddElement<uint8_t>(MsgTx_8305::VT_LOAD_STATUS, load_status, 0);
  }
  void add_material_type(uint16_t material_type) {
    fbb_.AddElement<uint16_t>(MsgTx_8305::VT_MATERIAL_TYPE, material_type, 0);
  }
  void add_stop_num(uint16_t stop_num) {
    fbb_.AddElement<uint16_t>(MsgTx_8305::VT_STOP_NUM, stop_num, 0);
  }
  void add_utcTime(uint64_t utcTime) {
    fbb_.AddElement<uint64_t>(MsgTx_8305::VT_UTCTIME, utcTime, 0);
  }
  explicit MsgTx_8305Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MsgTx_8305> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MsgTx_8305>(end);
    return o;
  }
};

inline flatbuffers::Offset<MsgTx_8305> CreateMsgTx_8305(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> remote_imei = 0,
    flatbuffers::Offset<flatbuffers::String> remote_name = 0,
    uint8_t task_type = 0,
    uint8_t cmd_type = 0,
    uint8_t load_status = 0,
    uint16_t material_type = 0,
    uint16_t stop_num = 0,
    uint64_t utcTime = 0) {
  MsgTx_8305Builder builder_(_fbb);
  builder_.add_utcTime(utcTime);
  builder_.add_remote_name(remote_name);
  builder_.add_remote_imei(remote_imei);
  builder_.add_stop_num(stop_num);
  builder_.add_material_type(material_type);
  builder_.add_load_status(load_status);
  builder_.add_cmd_type(cmd_type);
  builder_.add_task_type(task_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<MsgTx_8305> CreateMsgTx_8305Direct(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *remote_imei = nullptr,
    const char *remote_name = nullptr,
    uint8_t task_type = 0,
    uint8_t cmd_type = 0,
    uint8_t load_status = 0,
    uint16_t material_type = 0,
    uint16_t stop_num = 0,
    uint64_t utcTime = 0) {
  auto remote_imei__ = remote_imei ? _fbb.CreateString(remote_imei) : 0;
  auto remote_name__ = remote_name ? _fbb.CreateString(remote_name) : 0;
  return CreateMsgTx_8305(
      _fbb,
      remote_imei__,
      remote_name__,
      task_type,
      cmd_type,
      load_status,
      material_type,
      stop_num,
      utcTime);
}

flatbuffers::Offset<MsgTx_8305> CreateMsgTx_8305(flatbuffers::FlatBufferBuilder &_fbb, const MsgTx_8305T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MsgTx_8B02T : public flatbuffers::NativeTable {
  typedef MsgTx_8B02 TableType;
  double latitude;
  double longitude;
  MsgTx_8B02T()
      : latitude(0.0),
        longitude(0.0) {
  }
};

inline bool operator==(const MsgTx_8B02T &lhs, const MsgTx_8B02T &rhs) {
  return
      (lhs.latitude == rhs.latitude) &&
      (lhs.longitude == rhs.longitude);
}

inline bool operator!=(const MsgTx_8B02T &lhs, const MsgTx_8B02T &rhs) {
    return !(lhs == rhs);
}


struct MsgTx_8B02 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MsgTx_8B02T NativeTableType;
  typedef MsgTx_8B02Builder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MsgTx_8B02TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LATITUDE = 4,
    VT_LONGITUDE = 6
  };
  double latitude() const {
    return GetField<double>(VT_LATITUDE, 0.0);
  }
  bool mutate_latitude(double _latitude) {
    return SetField<double>(VT_LATITUDE, _latitude, 0.0);
  }
  double longitude() const {
    return GetField<double>(VT_LONGITUDE, 0.0);
  }
  bool mutate_longitude(double _longitude) {
    return SetField<double>(VT_LONGITUDE, _longitude, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_LATITUDE) &&
           VerifyField<double>(verifier, VT_LONGITUDE) &&
           verifier.EndTable();
  }
  MsgTx_8B02T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MsgTx_8B02T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MsgTx_8B02> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MsgTx_8B02T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MsgTx_8B02Builder {
  typedef MsgTx_8B02 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_latitude(double latitude) {
    fbb_.AddElement<double>(MsgTx_8B02::VT_LATITUDE, latitude, 0.0);
  }
  void add_longitude(double longitude) {
    fbb_.AddElement<double>(MsgTx_8B02::VT_LONGITUDE, longitude, 0.0);
  }
  explicit MsgTx_8B02Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MsgTx_8B02> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MsgTx_8B02>(end);
    return o;
  }
};

inline flatbuffers::Offset<MsgTx_8B02> CreateMsgTx_8B02(
    flatbuffers::FlatBufferBuilder &_fbb,
    double latitude = 0.0,
    double longitude = 0.0) {
  MsgTx_8B02Builder builder_(_fbb);
  builder_.add_longitude(longitude);
  builder_.add_latitude(latitude);
  return builder_.Finish();
}

flatbuffers::Offset<MsgTx_8B02> CreateMsgTx_8B02(flatbuffers::FlatBufferBuilder &_fbb, const MsgTx_8B02T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MsgTx_8B07_listT : public flatbuffers::NativeTable {
  typedef MsgTx_8B07_list TableType;
  uint16_t num;
  double latitude;
  double longitude;
  float heading;
  MsgTx_8B07_listT()
      : num(0),
        latitude(0.0),
        longitude(0.0),
        heading(0.0f) {
  }
};

inline bool operator==(const MsgTx_8B07_listT &lhs, const MsgTx_8B07_listT &rhs) {
  return
      (lhs.num == rhs.num) &&
      (lhs.latitude == rhs.latitude) &&
      (lhs.longitude == rhs.longitude) &&
      (lhs.heading == rhs.heading);
}

inline bool operator!=(const MsgTx_8B07_listT &lhs, const MsgTx_8B07_listT &rhs) {
    return !(lhs == rhs);
}


struct MsgTx_8B07_list FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MsgTx_8B07_listT NativeTableType;
  typedef MsgTx_8B07_listBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MsgTx_8B07_listTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUM = 4,
    VT_LATITUDE = 6,
    VT_LONGITUDE = 8,
    VT_HEADING = 10
  };
  uint16_t num() const {
    return GetField<uint16_t>(VT_NUM, 0);
  }
  bool mutate_num(uint16_t _num) {
    return SetField<uint16_t>(VT_NUM, _num, 0);
  }
  double latitude() const {
    return GetField<double>(VT_LATITUDE, 0.0);
  }
  bool mutate_latitude(double _latitude) {
    return SetField<double>(VT_LATITUDE, _latitude, 0.0);
  }
  double longitude() const {
    return GetField<double>(VT_LONGITUDE, 0.0);
  }
  bool mutate_longitude(double _longitude) {
    return SetField<double>(VT_LONGITUDE, _longitude, 0.0);
  }
  float heading() const {
    return GetField<float>(VT_HEADING, 0.0f);
  }
  bool mutate_heading(float _heading) {
    return SetField<float>(VT_HEADING, _heading, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_NUM) &&
           VerifyField<double>(verifier, VT_LATITUDE) &&
           VerifyField<double>(verifier, VT_LONGITUDE) &&
           VerifyField<float>(verifier, VT_HEADING) &&
           verifier.EndTable();
  }
  MsgTx_8B07_listT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MsgTx_8B07_listT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MsgTx_8B07_list> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MsgTx_8B07_listT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MsgTx_8B07_listBuilder {
  typedef MsgTx_8B07_list Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_num(uint16_t num) {
    fbb_.AddElement<uint16_t>(MsgTx_8B07_list::VT_NUM, num, 0);
  }
  void add_latitude(double latitude) {
    fbb_.AddElement<double>(MsgTx_8B07_list::VT_LATITUDE, latitude, 0.0);
  }
  void add_longitude(double longitude) {
    fbb_.AddElement<double>(MsgTx_8B07_list::VT_LONGITUDE, longitude, 0.0);
  }
  void add_heading(float heading) {
    fbb_.AddElement<float>(MsgTx_8B07_list::VT_HEADING, heading, 0.0f);
  }
  explicit MsgTx_8B07_listBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MsgTx_8B07_list> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MsgTx_8B07_list>(end);
    return o;
  }
};

inline flatbuffers::Offset<MsgTx_8B07_list> CreateMsgTx_8B07_list(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t num = 0,
    double latitude = 0.0,
    double longitude = 0.0,
    float heading = 0.0f) {
  MsgTx_8B07_listBuilder builder_(_fbb);
  builder_.add_longitude(longitude);
  builder_.add_latitude(latitude);
  builder_.add_heading(heading);
  builder_.add_num(num);
  return builder_.Finish();
}

flatbuffers::Offset<MsgTx_8B07_list> CreateMsgTx_8B07_list(flatbuffers::FlatBufferBuilder &_fbb, const MsgTx_8B07_listT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MsgTx_8B07T : public flatbuffers::NativeTable {
  typedef MsgTx_8B07 TableType;
  uint16_t list_num;
  std::vector<std::unique_ptr<MsgTx_8B07_listT>> List;
  MsgTx_8B07T()
      : list_num(0) {
  }
};

inline bool operator==(const MsgTx_8B07T &lhs, const MsgTx_8B07T &rhs) {
  return
      (lhs.list_num == rhs.list_num) &&
      (lhs.List == rhs.List);
}

inline bool operator!=(const MsgTx_8B07T &lhs, const MsgTx_8B07T &rhs) {
    return !(lhs == rhs);
}


struct MsgTx_8B07 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MsgTx_8B07T NativeTableType;
  typedef MsgTx_8B07Builder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MsgTx_8B07TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LIST_NUM = 4,
    VT_LIST = 6
  };
  uint16_t list_num() const {
    return GetField<uint16_t>(VT_LIST_NUM, 0);
  }
  bool mutate_list_num(uint16_t _list_num) {
    return SetField<uint16_t>(VT_LIST_NUM, _list_num, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<MsgTx_8B07_list>> *List() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<MsgTx_8B07_list>> *>(VT_LIST);
  }
  flatbuffers::Vector<flatbuffers::Offset<MsgTx_8B07_list>> *mutable_List() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<MsgTx_8B07_list>> *>(VT_LIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_LIST_NUM) &&
           VerifyOffset(verifier, VT_LIST) &&
           verifier.VerifyVector(List()) &&
           verifier.VerifyVectorOfTables(List()) &&
           verifier.EndTable();
  }
  MsgTx_8B07T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MsgTx_8B07T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MsgTx_8B07> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MsgTx_8B07T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MsgTx_8B07Builder {
  typedef MsgTx_8B07 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_list_num(uint16_t list_num) {
    fbb_.AddElement<uint16_t>(MsgTx_8B07::VT_LIST_NUM, list_num, 0);
  }
  void add_List(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MsgTx_8B07_list>>> List) {
    fbb_.AddOffset(MsgTx_8B07::VT_LIST, List);
  }
  explicit MsgTx_8B07Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MsgTx_8B07> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MsgTx_8B07>(end);
    return o;
  }
};

inline flatbuffers::Offset<MsgTx_8B07> CreateMsgTx_8B07(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t list_num = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MsgTx_8B07_list>>> List = 0) {
  MsgTx_8B07Builder builder_(_fbb);
  builder_.add_List(List);
  builder_.add_list_num(list_num);
  return builder_.Finish();
}

inline flatbuffers::Offset<MsgTx_8B07> CreateMsgTx_8B07Direct(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t list_num = 0,
    const std::vector<flatbuffers::Offset<MsgTx_8B07_list>> *List = nullptr) {
  auto List__ = List ? _fbb.CreateVector<flatbuffers::Offset<MsgTx_8B07_list>>(*List) : 0;
  return CreateMsgTx_8B07(
      _fbb,
      list_num,
      List__);
}

flatbuffers::Offset<MsgTx_8B07> CreateMsgTx_8B07(flatbuffers::FlatBufferBuilder &_fbb, const MsgTx_8B07T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MsgTx_8B08_listT : public flatbuffers::NativeTable {
  typedef MsgTx_8B08_list TableType;
  uint16_t num;
  uint8_t status;
  MsgTx_8B08_listT()
      : num(0),
        status(0) {
  }
};

inline bool operator==(const MsgTx_8B08_listT &lhs, const MsgTx_8B08_listT &rhs) {
  return
      (lhs.num == rhs.num) &&
      (lhs.status == rhs.status);
}

inline bool operator!=(const MsgTx_8B08_listT &lhs, const MsgTx_8B08_listT &rhs) {
    return !(lhs == rhs);
}


struct MsgTx_8B08_list FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MsgTx_8B08_listT NativeTableType;
  typedef MsgTx_8B08_listBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MsgTx_8B08_listTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUM = 4,
    VT_STATUS = 6
  };
  uint16_t num() const {
    return GetField<uint16_t>(VT_NUM, 0);
  }
  bool mutate_num(uint16_t _num) {
    return SetField<uint16_t>(VT_NUM, _num, 0);
  }
  uint8_t status() const {
    return GetField<uint8_t>(VT_STATUS, 0);
  }
  bool mutate_status(uint8_t _status) {
    return SetField<uint8_t>(VT_STATUS, _status, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_NUM) &&
           VerifyField<uint8_t>(verifier, VT_STATUS) &&
           verifier.EndTable();
  }
  MsgTx_8B08_listT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MsgTx_8B08_listT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MsgTx_8B08_list> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MsgTx_8B08_listT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MsgTx_8B08_listBuilder {
  typedef MsgTx_8B08_list Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_num(uint16_t num) {
    fbb_.AddElement<uint16_t>(MsgTx_8B08_list::VT_NUM, num, 0);
  }
  void add_status(uint8_t status) {
    fbb_.AddElement<uint8_t>(MsgTx_8B08_list::VT_STATUS, status, 0);
  }
  explicit MsgTx_8B08_listBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MsgTx_8B08_list> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MsgTx_8B08_list>(end);
    return o;
  }
};

inline flatbuffers::Offset<MsgTx_8B08_list> CreateMsgTx_8B08_list(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t num = 0,
    uint8_t status = 0) {
  MsgTx_8B08_listBuilder builder_(_fbb);
  builder_.add_num(num);
  builder_.add_status(status);
  return builder_.Finish();
}

flatbuffers::Offset<MsgTx_8B08_list> CreateMsgTx_8B08_list(flatbuffers::FlatBufferBuilder &_fbb, const MsgTx_8B08_listT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MsgTx_8B08T : public flatbuffers::NativeTable {
  typedef MsgTx_8B08 TableType;
  uint16_t list_num;
  std::vector<std::unique_ptr<MsgTx_8B08_listT>> List;
  MsgTx_8B08T()
      : list_num(0) {
  }
};

inline bool operator==(const MsgTx_8B08T &lhs, const MsgTx_8B08T &rhs) {
  return
      (lhs.list_num == rhs.list_num) &&
      (lhs.List == rhs.List);
}

inline bool operator!=(const MsgTx_8B08T &lhs, const MsgTx_8B08T &rhs) {
    return !(lhs == rhs);
}


struct MsgTx_8B08 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MsgTx_8B08T NativeTableType;
  typedef MsgTx_8B08Builder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MsgTx_8B08TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LIST_NUM = 4,
    VT_LIST = 6
  };
  uint16_t list_num() const {
    return GetField<uint16_t>(VT_LIST_NUM, 0);
  }
  bool mutate_list_num(uint16_t _list_num) {
    return SetField<uint16_t>(VT_LIST_NUM, _list_num, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<MsgTx_8B08_list>> *List() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<MsgTx_8B08_list>> *>(VT_LIST);
  }
  flatbuffers::Vector<flatbuffers::Offset<MsgTx_8B08_list>> *mutable_List() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<MsgTx_8B08_list>> *>(VT_LIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_LIST_NUM) &&
           VerifyOffset(verifier, VT_LIST) &&
           verifier.VerifyVector(List()) &&
           verifier.VerifyVectorOfTables(List()) &&
           verifier.EndTable();
  }
  MsgTx_8B08T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MsgTx_8B08T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MsgTx_8B08> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MsgTx_8B08T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MsgTx_8B08Builder {
  typedef MsgTx_8B08 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_list_num(uint16_t list_num) {
    fbb_.AddElement<uint16_t>(MsgTx_8B08::VT_LIST_NUM, list_num, 0);
  }
  void add_List(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MsgTx_8B08_list>>> List) {
    fbb_.AddOffset(MsgTx_8B08::VT_LIST, List);
  }
  explicit MsgTx_8B08Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MsgTx_8B08> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MsgTx_8B08>(end);
    return o;
  }
};

inline flatbuffers::Offset<MsgTx_8B08> CreateMsgTx_8B08(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t list_num = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MsgTx_8B08_list>>> List = 0) {
  MsgTx_8B08Builder builder_(_fbb);
  builder_.add_List(List);
  builder_.add_list_num(list_num);
  return builder_.Finish();
}

inline flatbuffers::Offset<MsgTx_8B08> CreateMsgTx_8B08Direct(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t list_num = 0,
    const std::vector<flatbuffers::Offset<MsgTx_8B08_list>> *List = nullptr) {
  auto List__ = List ? _fbb.CreateVector<flatbuffers::Offset<MsgTx_8B08_list>>(*List) : 0;
  return CreateMsgTx_8B08(
      _fbb,
      list_num,
      List__);
}

flatbuffers::Offset<MsgTx_8B08> CreateMsgTx_8B08(flatbuffers::FlatBufferBuilder &_fbb, const MsgTx_8B08T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MsgTx_0002T : public flatbuffers::NativeTable {
  typedef MsgTx_0002 TableType;
  MsgTx_0002T() {
  }
};

inline bool operator==(const MsgTx_0002T &, const MsgTx_0002T &) {
  return true;
}

inline bool operator!=(const MsgTx_0002T &lhs, const MsgTx_0002T &rhs) {
    return !(lhs == rhs);
}


struct MsgTx_0002 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MsgTx_0002T NativeTableType;
  typedef MsgTx_0002Builder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MsgTx_0002TypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  MsgTx_0002T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MsgTx_0002T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MsgTx_0002> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MsgTx_0002T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MsgTx_0002Builder {
  typedef MsgTx_0002 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit MsgTx_0002Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MsgTx_0002> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MsgTx_0002>(end);
    return o;
  }
};

inline flatbuffers::Offset<MsgTx_0002> CreateMsgTx_0002(
    flatbuffers::FlatBufferBuilder &_fbb) {
  MsgTx_0002Builder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<MsgTx_0002> CreateMsgTx_0002(flatbuffers::FlatBufferBuilder &_fbb, const MsgTx_0002T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MsgCguVersionT : public flatbuffers::NativeTable {
  typedef MsgCguVersion TableType;
  uint8_t product_type;
  uint8_t vehicle_type;
  uint8_t module_type;
  uint8_t data1;
  uint8_t data2;
  uint8_t data3;
  MsgCguVersionT()
      : product_type(0),
        vehicle_type(0),
        module_type(0),
        data1(0),
        data2(0),
        data3(0) {
  }
};

inline bool operator==(const MsgCguVersionT &lhs, const MsgCguVersionT &rhs) {
  return
      (lhs.product_type == rhs.product_type) &&
      (lhs.vehicle_type == rhs.vehicle_type) &&
      (lhs.module_type == rhs.module_type) &&
      (lhs.data1 == rhs.data1) &&
      (lhs.data2 == rhs.data2) &&
      (lhs.data3 == rhs.data3);
}

inline bool operator!=(const MsgCguVersionT &lhs, const MsgCguVersionT &rhs) {
    return !(lhs == rhs);
}


struct MsgCguVersion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MsgCguVersionT NativeTableType;
  typedef MsgCguVersionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MsgCguVersionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PRODUCT_TYPE = 4,
    VT_VEHICLE_TYPE = 6,
    VT_MODULE_TYPE = 8,
    VT_DATA1 = 10,
    VT_DATA2 = 12,
    VT_DATA3 = 14
  };
  uint8_t product_type() const {
    return GetField<uint8_t>(VT_PRODUCT_TYPE, 0);
  }
  bool mutate_product_type(uint8_t _product_type) {
    return SetField<uint8_t>(VT_PRODUCT_TYPE, _product_type, 0);
  }
  uint8_t vehicle_type() const {
    return GetField<uint8_t>(VT_VEHICLE_TYPE, 0);
  }
  bool mutate_vehicle_type(uint8_t _vehicle_type) {
    return SetField<uint8_t>(VT_VEHICLE_TYPE, _vehicle_type, 0);
  }
  uint8_t module_type() const {
    return GetField<uint8_t>(VT_MODULE_TYPE, 0);
  }
  bool mutate_module_type(uint8_t _module_type) {
    return SetField<uint8_t>(VT_MODULE_TYPE, _module_type, 0);
  }
  uint8_t data1() const {
    return GetField<uint8_t>(VT_DATA1, 0);
  }
  bool mutate_data1(uint8_t _data1) {
    return SetField<uint8_t>(VT_DATA1, _data1, 0);
  }
  uint8_t data2() const {
    return GetField<uint8_t>(VT_DATA2, 0);
  }
  bool mutate_data2(uint8_t _data2) {
    return SetField<uint8_t>(VT_DATA2, _data2, 0);
  }
  uint8_t data3() const {
    return GetField<uint8_t>(VT_DATA3, 0);
  }
  bool mutate_data3(uint8_t _data3) {
    return SetField<uint8_t>(VT_DATA3, _data3, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_PRODUCT_TYPE) &&
           VerifyField<uint8_t>(verifier, VT_VEHICLE_TYPE) &&
           VerifyField<uint8_t>(verifier, VT_MODULE_TYPE) &&
           VerifyField<uint8_t>(verifier, VT_DATA1) &&
           VerifyField<uint8_t>(verifier, VT_DATA2) &&
           VerifyField<uint8_t>(verifier, VT_DATA3) &&
           verifier.EndTable();
  }
  MsgCguVersionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MsgCguVersionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MsgCguVersion> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MsgCguVersionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MsgCguVersionBuilder {
  typedef MsgCguVersion Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_product_type(uint8_t product_type) {
    fbb_.AddElement<uint8_t>(MsgCguVersion::VT_PRODUCT_TYPE, product_type, 0);
  }
  void add_vehicle_type(uint8_t vehicle_type) {
    fbb_.AddElement<uint8_t>(MsgCguVersion::VT_VEHICLE_TYPE, vehicle_type, 0);
  }
  void add_module_type(uint8_t module_type) {
    fbb_.AddElement<uint8_t>(MsgCguVersion::VT_MODULE_TYPE, module_type, 0);
  }
  void add_data1(uint8_t data1) {
    fbb_.AddElement<uint8_t>(MsgCguVersion::VT_DATA1, data1, 0);
  }
  void add_data2(uint8_t data2) {
    fbb_.AddElement<uint8_t>(MsgCguVersion::VT_DATA2, data2, 0);
  }
  void add_data3(uint8_t data3) {
    fbb_.AddElement<uint8_t>(MsgCguVersion::VT_DATA3, data3, 0);
  }
  explicit MsgCguVersionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MsgCguVersion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MsgCguVersion>(end);
    return o;
  }
};

inline flatbuffers::Offset<MsgCguVersion> CreateMsgCguVersion(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t product_type = 0,
    uint8_t vehicle_type = 0,
    uint8_t module_type = 0,
    uint8_t data1 = 0,
    uint8_t data2 = 0,
    uint8_t data3 = 0) {
  MsgCguVersionBuilder builder_(_fbb);
  builder_.add_data3(data3);
  builder_.add_data2(data2);
  builder_.add_data1(data1);
  builder_.add_module_type(module_type);
  builder_.add_vehicle_type(vehicle_type);
  builder_.add_product_type(product_type);
  return builder_.Finish();
}

flatbuffers::Offset<MsgCguVersion> CreateMsgCguVersion(flatbuffers::FlatBufferBuilder &_fbb, const MsgCguVersionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MsgVechWarnStatT : public flatbuffers::NativeTable {
  typedef MsgVechWarnStat TableType;
  std::vector<uint8_t> Warning;
  MsgVechWarnStatT() {
  }
};

inline bool operator==(const MsgVechWarnStatT &lhs, const MsgVechWarnStatT &rhs) {
  return
      (lhs.Warning == rhs.Warning);
}

inline bool operator!=(const MsgVechWarnStatT &lhs, const MsgVechWarnStatT &rhs) {
    return !(lhs == rhs);
}


struct MsgVechWarnStat FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MsgVechWarnStatT NativeTableType;
  typedef MsgVechWarnStatBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MsgVechWarnStatTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WARNING = 4
  };
  const flatbuffers::Vector<uint8_t> *Warning() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_WARNING);
  }
  flatbuffers::Vector<uint8_t> *mutable_Warning() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_WARNING);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_WARNING) &&
           verifier.VerifyVector(Warning()) &&
           verifier.EndTable();
  }
  MsgVechWarnStatT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MsgVechWarnStatT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MsgVechWarnStat> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MsgVechWarnStatT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MsgVechWarnStatBuilder {
  typedef MsgVechWarnStat Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Warning(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> Warning) {
    fbb_.AddOffset(MsgVechWarnStat::VT_WARNING, Warning);
  }
  explicit MsgVechWarnStatBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MsgVechWarnStat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MsgVechWarnStat>(end);
    return o;
  }
};

inline flatbuffers::Offset<MsgVechWarnStat> CreateMsgVechWarnStat(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> Warning = 0) {
  MsgVechWarnStatBuilder builder_(_fbb);
  builder_.add_Warning(Warning);
  return builder_.Finish();
}

inline flatbuffers::Offset<MsgVechWarnStat> CreateMsgVechWarnStatDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *Warning = nullptr) {
  auto Warning__ = Warning ? _fbb.CreateVector<uint8_t>(*Warning) : 0;
  return CreateMsgVechWarnStat(
      _fbb,
      Warning__);
}

flatbuffers::Offset<MsgVechWarnStat> CreateMsgVechWarnStat(flatbuffers::FlatBufferBuilder &_fbb, const MsgVechWarnStatT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline Msg2050T *Msg2050::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<Msg2050T> _o = std::unique_ptr<Msg2050T>(new Msg2050T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Msg2050::UnPackTo(Msg2050T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; }
  { auto _e = turn_off_cmd(); _o->turn_off_cmd = _e; }
  { auto _e = turn_off_cmd_reverse(); _o->turn_off_cmd_reverse = _e; }
}

inline flatbuffers::Offset<Msg2050> Msg2050::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg2050T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMsg2050(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Msg2050> CreateMsg2050(flatbuffers::FlatBufferBuilder &_fbb, const Msg2050T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Msg2050T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _turn_off_cmd = _o->turn_off_cmd;
  auto _turn_off_cmd_reverse = _o->turn_off_cmd_reverse;
  return CreateMsg2050(
      _fbb,
      _id,
      _turn_off_cmd,
      _turn_off_cmd_reverse);
}

inline Msg8306T *Msg8306::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<Msg8306T> _o = std::unique_ptr<Msg8306T>(new Msg8306T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Msg8306::UnPackTo(Msg8306T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; }
  { auto _e = self_vehicle_id(); if (_e) _o->self_vehicle_id = _e->str(); }
  { auto _e = target_id(); if (_e) _o->target_id = _e->str(); }
  { auto _e = work_class(); _o->work_class = _e; }
  { auto _e = cmd_flag(); _o->cmd_flag = _e; }
  { auto _e = load_status(); _o->load_status = _e; }
  { auto _e = material_type(); _o->material_type = _e; }
  { auto _e = parking_lat(); _o->parking_lat = _e; }
  { auto _e = parking_lng(); _o->parking_lng = _e; }
  { auto _e = parking_head(); _o->parking_head = _e; }
  { auto _e = self_vehicle_name(); if (_e) _o->self_vehicle_name = _e->str(); }
  { auto _e = target_name(); if (_e) _o->target_name = _e->str(); }
}

inline flatbuffers::Offset<Msg8306> Msg8306::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg8306T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMsg8306(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Msg8306> CreateMsg8306(flatbuffers::FlatBufferBuilder &_fbb, const Msg8306T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Msg8306T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _self_vehicle_id = _o->self_vehicle_id.empty() ? 0 : _fbb.CreateString(_o->self_vehicle_id);
  auto _target_id = _o->target_id.empty() ? 0 : _fbb.CreateString(_o->target_id);
  auto _work_class = _o->work_class;
  auto _cmd_flag = _o->cmd_flag;
  auto _load_status = _o->load_status;
  auto _material_type = _o->material_type;
  auto _parking_lat = _o->parking_lat;
  auto _parking_lng = _o->parking_lng;
  auto _parking_head = _o->parking_head;
  auto _self_vehicle_name = _o->self_vehicle_name.empty() ? 0 : _fbb.CreateString(_o->self_vehicle_name);
  auto _target_name = _o->target_name.empty() ? 0 : _fbb.CreateString(_o->target_name);
  return CreateMsg8306(
      _fbb,
      _id,
      _self_vehicle_id,
      _target_id,
      _work_class,
      _cmd_flag,
      _load_status,
      _material_type,
      _parking_lat,
      _parking_lng,
      _parking_head,
      _self_vehicle_name,
      _target_name);
}

inline Msg8F02T *Msg8F02::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<Msg8F02T> _o = std::unique_ptr<Msg8F02T>(new Msg8F02T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Msg8F02::UnPackTo(Msg8F02T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; }
  { auto _e = service_state_type(); _o->service_state_type = _e; }
  { auto _e = service_delay_reason(); _o->service_delay_reason = _e; }
  { auto _e = time_delay(); _o->time_delay = _e; }
}

inline flatbuffers::Offset<Msg8F02> Msg8F02::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg8F02T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMsg8F02(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Msg8F02> CreateMsg8F02(flatbuffers::FlatBufferBuilder &_fbb, const Msg8F02T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Msg8F02T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _service_state_type = _o->service_state_type;
  auto _service_delay_reason = _o->service_delay_reason;
  auto _time_delay = _o->time_delay;
  return CreateMsg8F02(
      _fbb,
      _id,
      _service_state_type,
      _service_delay_reason,
      _time_delay);
}

inline Msg8401T *Msg8401::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<Msg8401T> _o = std::unique_ptr<Msg8401T>(new Msg8401T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Msg8401::UnPackTo(Msg8401T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; }
  { auto _e = target_id(); if (_e) _o->target_id = _e->str(); }
  { auto _e = warning_type(); _o->warning_type = _e; }
  { auto _e = distance(); _o->distance = _e; }
  { auto _e = collision_time(); _o->collision_time = _e; }
  { auto _e = vehicle_type(); _o->vehicle_type = _e; }
  { auto _e = length(); _o->length = _e; }
  { auto _e = width(); _o->width = _e; }
  { auto _e = height(); _o->height = _e; }
  { auto _e = lat(); _o->lat = _e; }
  { auto _e = lng(); _o->lng = _e; }
  { auto _e = head(); _o->head = _e; }
  { auto _e = speed(); _o->speed = _e; }
  { auto _e = east_speed(); _o->east_speed = _e; }
  { auto _e = north_speed(); _o->north_speed = _e; }
  { auto _e = front_angle(); _o->front_angle = _e; }
  { auto _e = road_id(); _o->road_id = _e; }
  { auto _e = road_direction(); _o->road_direction = _e; }
  { auto _e = gps_time(); _o->gps_time = _e; }
  { auto _e = dname(); if (_e) _o->dname = _e->str(); }
}

inline flatbuffers::Offset<Msg8401> Msg8401::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg8401T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMsg8401(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Msg8401> CreateMsg8401(flatbuffers::FlatBufferBuilder &_fbb, const Msg8401T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Msg8401T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _target_id = _o->target_id.empty() ? 0 : _fbb.CreateString(_o->target_id);
  auto _warning_type = _o->warning_type;
  auto _distance = _o->distance;
  auto _collision_time = _o->collision_time;
  auto _vehicle_type = _o->vehicle_type;
  auto _length = _o->length;
  auto _width = _o->width;
  auto _height = _o->height;
  auto _lat = _o->lat;
  auto _lng = _o->lng;
  auto _head = _o->head;
  auto _speed = _o->speed;
  auto _east_speed = _o->east_speed;
  auto _north_speed = _o->north_speed;
  auto _front_angle = _o->front_angle;
  auto _road_id = _o->road_id;
  auto _road_direction = _o->road_direction;
  auto _gps_time = _o->gps_time;
  auto _dname = _o->dname.empty() ? 0 : _fbb.CreateString(_o->dname);
  return CreateMsg8401(
      _fbb,
      _id,
      _target_id,
      _warning_type,
      _distance,
      _collision_time,
      _vehicle_type,
      _length,
      _width,
      _height,
      _lat,
      _lng,
      _head,
      _speed,
      _east_speed,
      _north_speed,
      _front_angle,
      _road_id,
      _road_direction,
      _gps_time,
      _dname);
}

inline Msg8F0CT *Msg8F0C::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<Msg8F0CT> _o = std::unique_ptr<Msg8F0CT>(new Msg8F0CT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Msg8F0C::UnPackTo(Msg8F0CT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; }
  { auto _e = task_type(); _o->task_type = _e; }
  { auto _e = task_num(); _o->task_num = _e; }
  { auto _e = task_dispatch_result(); _o->task_dispatch_result = _e; }
  { auto _e = task_target_imei(); if (_e) _o->task_target_imei = _e->str(); }
  { auto _e = task_file_md5(); if (_e) _o->task_file_md5 = _e->str(); }
  { auto _e = targetDevName(); if (_e) _o->targetDevName = _e->str(); }
  { auto _e = siteId(); _o->siteId = _e; }
  { auto _e = task_file_name(); if (_e) _o->task_file_name = _e->str(); }
}

inline flatbuffers::Offset<Msg8F0C> Msg8F0C::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg8F0CT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMsg8F0C(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Msg8F0C> CreateMsg8F0C(flatbuffers::FlatBufferBuilder &_fbb, const Msg8F0CT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Msg8F0CT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _task_type = _o->task_type;
  auto _task_num = _o->task_num;
  auto _task_dispatch_result = _o->task_dispatch_result;
  auto _task_target_imei = _o->task_target_imei.empty() ? 0 : _fbb.CreateString(_o->task_target_imei);
  auto _task_file_md5 = _o->task_file_md5.empty() ? 0 : _fbb.CreateString(_o->task_file_md5);
  auto _targetDevName = _o->targetDevName.empty() ? 0 : _fbb.CreateString(_o->targetDevName);
  auto _siteId = _o->siteId;
  auto _task_file_name = _o->task_file_name.empty() ? 0 : _fbb.CreateString(_o->task_file_name);
  return CreateMsg8F0C(
      _fbb,
      _id,
      _task_type,
      _task_num,
      _task_dispatch_result,
      _task_target_imei,
      _task_file_md5,
      _targetDevName,
      _siteId,
      _task_file_name);
}

inline Msg8F0DT *Msg8F0D::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<Msg8F0DT> _o = std::unique_ptr<Msg8F0DT>(new Msg8F0DT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Msg8F0D::UnPackTo(Msg8F0DT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; }
  { auto _e = task_modify_type(); _o->task_modify_type = _e; }
}

inline flatbuffers::Offset<Msg8F0D> Msg8F0D::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg8F0DT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMsg8F0D(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Msg8F0D> CreateMsg8F0D(flatbuffers::FlatBufferBuilder &_fbb, const Msg8F0DT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Msg8F0DT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _task_modify_type = _o->task_modify_type;
  return CreateMsg8F0D(
      _fbb,
      _id,
      _task_modify_type);
}

inline Msg8403T *Msg8403::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<Msg8403T> _o = std::unique_ptr<Msg8403T>(new Msg8403T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Msg8403::UnPackTo(Msg8403T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; }
  { auto _e = load_status_from_hmi(); _o->load_status_from_hmi = _e; }
}

inline flatbuffers::Offset<Msg8403> Msg8403::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg8403T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMsg8403(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Msg8403> CreateMsg8403(flatbuffers::FlatBufferBuilder &_fbb, const Msg8403T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Msg8403T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _load_status_from_hmi = _o->load_status_from_hmi;
  return CreateMsg8403(
      _fbb,
      _id,
      _load_status_from_hmi);
}

inline MovementAuthorityT *MovementAuthority::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<MovementAuthorityT> _o = std::unique_ptr<MovementAuthorityT>(new MovementAuthorityT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MovementAuthority::UnPackTo(MovementAuthorityT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = road_id(); _o->road_id = _e; }
  { auto _e = iLatitude(); _o->iLatitude = _e; }
  { auto _e = iLongitude(); _o->iLongitude = _e; }
  { auto _e = task_file_name(); if (_e) _o->task_file_name = _e->str(); }
  { auto _e = task_file_path(); if (_e) _o->task_file_path = _e->str(); }
  { auto _e = terminal(); _o->terminal = _e; }
  { auto _e = task_file_download_result(); _o->task_file_download_result = _e; }
  { auto _e = task_file_md5(); if (_e) _o->task_file_md5 = _e->str(); }
}

inline flatbuffers::Offset<MovementAuthority> MovementAuthority::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MovementAuthorityT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMovementAuthority(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MovementAuthority> CreateMovementAuthority(flatbuffers::FlatBufferBuilder &_fbb, const MovementAuthorityT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MovementAuthorityT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _road_id = _o->road_id;
  auto _iLatitude = _o->iLatitude;
  auto _iLongitude = _o->iLongitude;
  auto _task_file_name = _o->task_file_name.empty() ? 0 : _fbb.CreateString(_o->task_file_name);
  auto _task_file_path = _o->task_file_path.empty() ? 0 : _fbb.CreateString(_o->task_file_path);
  auto _terminal = _o->terminal;
  auto _task_file_download_result = _o->task_file_download_result;
  auto _task_file_md5 = _o->task_file_md5.empty() ? 0 : _fbb.CreateString(_o->task_file_md5);
  return CreateMovementAuthority(
      _fbb,
      _road_id,
      _iLatitude,
      _iLongitude,
      _task_file_name,
      _task_file_path,
      _terminal,
      _task_file_download_result,
      _task_file_md5);
}

inline Msg8F0FT *Msg8F0F::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<Msg8F0FT> _o = std::unique_ptr<Msg8F0FT>(new Msg8F0FT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Msg8F0F::UnPackTo(Msg8F0FT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; }
  { auto _e = length(); _o->length = _e; }
  { auto _e = move_authority(); if (_e) { _o->move_authority.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->move_authority[_i] = std::unique_ptr<MovementAuthorityT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<Msg8F0F> Msg8F0F::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg8F0FT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMsg8F0F(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Msg8F0F> CreateMsg8F0F(flatbuffers::FlatBufferBuilder &_fbb, const Msg8F0FT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Msg8F0FT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _length = _o->length;
  auto _move_authority = _o->move_authority.size() ? _fbb.CreateVector<flatbuffers::Offset<MovementAuthority>> (_o->move_authority.size(), [](size_t i, _VectorArgs *__va) { return CreateMovementAuthority(*__va->__fbb, __va->__o->move_authority[i].get(), __va->__rehasher); }, &_va ) : 0;
  return CreateMsg8F0F(
      _fbb,
      _id,
      _length,
      _move_authority);
}

inline Msg8F10T *Msg8F10::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<Msg8F10T> _o = std::unique_ptr<Msg8F10T>(new Msg8F10T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Msg8F10::UnPackTo(Msg8F10T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; }
  { auto _e = task_num(); _o->task_num = _e; }
  { auto _e = boundary_file_md5(); if (_e) _o->boundary_file_md5 = _e->str(); }
  { auto _e = boundary_file_name(); if (_e) _o->boundary_file_name = _e->str(); }
}

inline flatbuffers::Offset<Msg8F10> Msg8F10::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg8F10T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMsg8F10(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Msg8F10> CreateMsg8F10(flatbuffers::FlatBufferBuilder &_fbb, const Msg8F10T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Msg8F10T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _task_num = _o->task_num;
  auto _boundary_file_md5 = _o->boundary_file_md5.empty() ? 0 : _fbb.CreateString(_o->boundary_file_md5);
  auto _boundary_file_name = _o->boundary_file_name.empty() ? 0 : _fbb.CreateString(_o->boundary_file_name);
  return CreateMsg8F10(
      _fbb,
      _id,
      _task_num,
      _boundary_file_md5,
      _boundary_file_name);
}

inline Msg8C01T *Msg8C01::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<Msg8C01T> _o = std::unique_ptr<Msg8C01T>(new Msg8C01T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Msg8C01::UnPackTo(Msg8C01T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = serialNum(); _o->serialNum = _e; }
  { auto _e = cmdId(); _o->cmdId = _e; }
  { auto _e = result(); _o->result = _e; }
}

inline flatbuffers::Offset<Msg8C01> Msg8C01::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg8C01T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMsg8C01(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Msg8C01> CreateMsg8C01(flatbuffers::FlatBufferBuilder &_fbb, const Msg8C01T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Msg8C01T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _serialNum = _o->serialNum;
  auto _cmdId = _o->cmdId;
  auto _result = _o->result;
  return CreateMsg8C01(
      _fbb,
      _serialNum,
      _cmdId,
      _result);
}

inline Msg8F04T *Msg8F04::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<Msg8F04T> _o = std::unique_ptr<Msg8F04T>(new Msg8F04T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Msg8F04::UnPackTo(Msg8F04T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = materCode(); _o->materCode = _e; }
}

inline flatbuffers::Offset<Msg8F04> Msg8F04::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg8F04T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMsg8F04(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Msg8F04> CreateMsg8F04(flatbuffers::FlatBufferBuilder &_fbb, const Msg8F04T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Msg8F04T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _materCode = _o->materCode;
  return CreateMsg8F04(
      _fbb,
      _materCode);
}

inline Msg8F0AT *Msg8F0A::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<Msg8F0AT> _o = std::unique_ptr<Msg8F0AT>(new Msg8F0AT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Msg8F0A::UnPackTo(Msg8F0AT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = fileType(); _o->fileType = _e; }
  { auto _e = fileArea(); _o->fileArea = _e; }
  { auto _e = result(); _o->result = _e; }
  { auto _e = targetImei(); if (_e) _o->targetImei = _e->str(); }
  { auto _e = md5(); if (_e) _o->md5 = _e->str(); }
  { auto _e = targetDevName(); if (_e) _o->targetDevName = _e->str(); }
  { auto _e = filePath(); if (_e) _o->filePath = _e->str(); }
}

inline flatbuffers::Offset<Msg8F0A> Msg8F0A::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg8F0AT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMsg8F0A(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Msg8F0A> CreateMsg8F0A(flatbuffers::FlatBufferBuilder &_fbb, const Msg8F0AT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Msg8F0AT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _fileType = _o->fileType;
  auto _fileArea = _o->fileArea;
  auto _result = _o->result;
  auto _targetImei = _o->targetImei.empty() ? 0 : _fbb.CreateString(_o->targetImei);
  auto _md5 = _o->md5.empty() ? 0 : _fbb.CreateString(_o->md5);
  auto _targetDevName = _o->targetDevName.empty() ? 0 : _fbb.CreateString(_o->targetDevName);
  auto _filePath = _o->filePath.empty() ? 0 : _fbb.CreateString(_o->filePath);
  return CreateMsg8F0A(
      _fbb,
      _fileType,
      _fileArea,
      _result,
      _targetImei,
      _md5,
      _targetDevName,
      _filePath);
}

inline Msg8F09T *Msg8F09::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<Msg8F09T> _o = std::unique_ptr<Msg8F09T>(new Msg8F09T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Msg8F09::UnPackTo(Msg8F09T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = remoteid(); _o->remoteid = _e; }
}

inline flatbuffers::Offset<Msg8F09> Msg8F09::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg8F09T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMsg8F09(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Msg8F09> CreateMsg8F09(flatbuffers::FlatBufferBuilder &_fbb, const Msg8F09T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Msg8F09T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _remoteid = _o->remoteid;
  return CreateMsg8F09(
      _fbb,
      _remoteid);
}

inline GroupStatusListT *GroupStatusList::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<GroupStatusListT> _o = std::unique_ptr<GroupStatusListT>(new GroupStatusListT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GroupStatusList::UnPackTo(GroupStatusListT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; }
  { auto _e = groupNumber(); _o->groupNumber = _e; }
  { auto _e = stopNumber(); _o->stopNumber = _e; }
  { auto _e = stop_group_status(); _o->stop_group_status = _e; }
  { auto _e = isOccupied(); _o->isOccupied = _e; }
  { auto _e = task_status(); _o->task_status = _e; }
  { auto _e = drivingMode(); _o->drivingMode = _e; }
  { auto _e = deviceImei(); if (_e) _o->deviceImei = _e->str(); }
  { auto _e = deviceName(); if (_e) _o->deviceName = _e->str(); }
}

inline flatbuffers::Offset<GroupStatusList> GroupStatusList::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GroupStatusListT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGroupStatusList(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GroupStatusList> CreateGroupStatusList(flatbuffers::FlatBufferBuilder &_fbb, const GroupStatusListT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GroupStatusListT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _groupNumber = _o->groupNumber;
  auto _stopNumber = _o->stopNumber;
  auto _stop_group_status = _o->stop_group_status;
  auto _isOccupied = _o->isOccupied;
  auto _task_status = _o->task_status;
  auto _drivingMode = _o->drivingMode;
  auto _deviceImei = _o->deviceImei.empty() ? 0 : _fbb.CreateString(_o->deviceImei);
  auto _deviceName = _o->deviceName.empty() ? 0 : _fbb.CreateString(_o->deviceName);
  return CreateGroupStatusList(
      _fbb,
      _type,
      _groupNumber,
      _stopNumber,
      _stop_group_status,
      _isOccupied,
      _task_status,
      _drivingMode,
      _deviceImei,
      _deviceName);
}

inline Msg8B01T *Msg8B01::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<Msg8B01T> _o = std::unique_ptr<Msg8B01T>(new Msg8B01T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Msg8B01::UnPackTo(Msg8B01T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = fileName(); if (_e) _o->fileName = _e->str(); }
  { auto _e = md5(); if (_e) _o->md5 = _e->str(); }
  { auto _e = listNum(); _o->listNum = _e; }
  { auto _e = List(); if (_e) { _o->List.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->List[_i] = std::unique_ptr<GroupStatusListT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<Msg8B01> Msg8B01::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg8B01T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMsg8B01(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Msg8B01> CreateMsg8B01(flatbuffers::FlatBufferBuilder &_fbb, const Msg8B01T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Msg8B01T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _fileName = _o->fileName.empty() ? 0 : _fbb.CreateString(_o->fileName);
  auto _md5 = _o->md5.empty() ? 0 : _fbb.CreateString(_o->md5);
  auto _listNum = _o->listNum;
  auto _List = _o->List.size() ? _fbb.CreateVector<flatbuffers::Offset<GroupStatusList>> (_o->List.size(), [](size_t i, _VectorArgs *__va) { return CreateGroupStatusList(*__va->__fbb, __va->__o->List[i].get(), __va->__rehasher); }, &_va ) : 0;
  return CreateMsg8B01(
      _fbb,
      _fileName,
      _md5,
      _listNum,
      _List);
}

inline GroupStatusList_WaitInLineT *GroupStatusList_WaitInLine::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<GroupStatusList_WaitInLineT> _o = std::unique_ptr<GroupStatusList_WaitInLineT>(new GroupStatusList_WaitInLineT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GroupStatusList_WaitInLine::UnPackTo(GroupStatusList_WaitInLineT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = taskStat(); _o->taskStat = _e; }
  { auto _e = drivingMode(); _o->drivingMode = _e; }
  { auto _e = deviceImei(); if (_e) _o->deviceImei = _e->str(); }
  { auto _e = deviceName(); if (_e) _o->deviceName = _e->str(); }
}

inline flatbuffers::Offset<GroupStatusList_WaitInLine> GroupStatusList_WaitInLine::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GroupStatusList_WaitInLineT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGroupStatusList_WaitInLine(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GroupStatusList_WaitInLine> CreateGroupStatusList_WaitInLine(flatbuffers::FlatBufferBuilder &_fbb, const GroupStatusList_WaitInLineT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GroupStatusList_WaitInLineT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _taskStat = _o->taskStat;
  auto _drivingMode = _o->drivingMode;
  auto _deviceImei = _o->deviceImei.empty() ? 0 : _fbb.CreateString(_o->deviceImei);
  auto _deviceName = _o->deviceName.empty() ? 0 : _fbb.CreateString(_o->deviceName);
  return CreateGroupStatusList_WaitInLine(
      _fbb,
      _taskStat,
      _drivingMode,
      _deviceImei,
      _deviceName);
}

inline Msg8B03T *Msg8B03::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<Msg8B03T> _o = std::unique_ptr<Msg8B03T>(new Msg8B03T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Msg8B03::UnPackTo(Msg8B03T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = listNum(); _o->listNum = _e; }
  { auto _e = List(); if (_e) { _o->List.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->List[_i] = std::unique_ptr<GroupStatusList_WaitInLineT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<Msg8B03> Msg8B03::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg8B03T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMsg8B03(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Msg8B03> CreateMsg8B03(flatbuffers::FlatBufferBuilder &_fbb, const Msg8B03T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Msg8B03T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _listNum = _o->listNum;
  auto _List = _o->List.size() ? _fbb.CreateVector<flatbuffers::Offset<GroupStatusList_WaitInLine>> (_o->List.size(), [](size_t i, _VectorArgs *__va) { return CreateGroupStatusList_WaitInLine(*__va->__fbb, __va->__o->List[i].get(), __va->__rehasher); }, &_va ) : 0;
  return CreateMsg8B03(
      _fbb,
      _listNum,
      _List);
}

inline Msg8307T *Msg8307::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<Msg8307T> _o = std::unique_ptr<Msg8307T>(new Msg8307T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Msg8307::UnPackTo(Msg8307T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = src_devID(); if (_e) _o->src_devID = _e->str(); }
  { auto _e = src_devNA(); if (_e) _o->src_devNA = _e->str(); }
  { auto _e = work_type(); _o->work_type = _e; }
  { auto _e = oper_type(); _o->oper_type = _e; }
  { auto _e = load_status(); _o->load_status = _e; }
  { auto _e = mate_type(); _o->mate_type = _e; }
  { auto _e = stop_pos_num(); _o->stop_pos_num = _e; }
  { auto _e = time(); _o->time = _e; }
}

inline flatbuffers::Offset<Msg8307> Msg8307::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg8307T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMsg8307(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Msg8307> CreateMsg8307(flatbuffers::FlatBufferBuilder &_fbb, const Msg8307T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Msg8307T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _src_devID = _o->src_devID.empty() ? 0 : _fbb.CreateString(_o->src_devID);
  auto _src_devNA = _o->src_devNA.empty() ? 0 : _fbb.CreateString(_o->src_devNA);
  auto _work_type = _o->work_type;
  auto _oper_type = _o->oper_type;
  auto _load_status = _o->load_status;
  auto _mate_type = _o->mate_type;
  auto _stop_pos_num = _o->stop_pos_num;
  auto _time = _o->time;
  return CreateMsg8307(
      _fbb,
      _src_devID,
      _src_devNA,
      _work_type,
      _oper_type,
      _load_status,
      _mate_type,
      _stop_pos_num,
      _time);
}

inline Msg8308T *Msg8308::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<Msg8308T> _o = std::unique_ptr<Msg8308T>(new Msg8308T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Msg8308::UnPackTo(Msg8308T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = src_devID(); if (_e) _o->src_devID = _e->str(); }
  { auto _e = src_devNA(); if (_e) _o->src_devNA = _e->str(); }
  { auto _e = work_type(); _o->work_type = _e; }
  { auto _e = oper_type(); _o->oper_type = _e; }
  { auto _e = time(); _o->time = _e; }
}

inline flatbuffers::Offset<Msg8308> Msg8308::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg8308T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMsg8308(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Msg8308> CreateMsg8308(flatbuffers::FlatBufferBuilder &_fbb, const Msg8308T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Msg8308T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _src_devID = _o->src_devID.empty() ? 0 : _fbb.CreateString(_o->src_devID);
  auto _src_devNA = _o->src_devNA.empty() ? 0 : _fbb.CreateString(_o->src_devNA);
  auto _work_type = _o->work_type;
  auto _oper_type = _o->oper_type;
  auto _time = _o->time;
  return CreateMsg8308(
      _fbb,
      _src_devID,
      _src_devNA,
      _work_type,
      _oper_type,
      _time);
}

inline Msg0F21T *Msg0F21::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<Msg0F21T> _o = std::unique_ptr<Msg0F21T>(new Msg0F21T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Msg0F21::UnPackTo(Msg0F21T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = work_type(); _o->work_type = _e; }
  { auto _e = oper_type(); _o->oper_type = _e; }
  { auto _e = time(); _o->time = _e; }
}

inline flatbuffers::Offset<Msg0F21> Msg0F21::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg0F21T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMsg0F21(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Msg0F21> CreateMsg0F21(flatbuffers::FlatBufferBuilder &_fbb, const Msg0F21T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Msg0F21T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _work_type = _o->work_type;
  auto _oper_type = _o->oper_type;
  auto _time = _o->time;
  return CreateMsg0F21(
      _fbb,
      _work_type,
      _oper_type,
      _time);
}

inline Msg0503T *Msg0503::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<Msg0503T> _o = std::unique_ptr<Msg0503T>(new Msg0503T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Msg0503::UnPackTo(Msg0503T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = module_type(); _o->module_type = _e; }
  { auto _e = state(); _o->state = _e; }
  { auto _e = time(); _o->time = _e; }
}

inline flatbuffers::Offset<Msg0503> Msg0503::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg0503T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMsg0503(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Msg0503> CreateMsg0503(flatbuffers::FlatBufferBuilder &_fbb, const Msg0503T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Msg0503T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _module_type = _o->module_type;
  auto _state = _o->state;
  auto _time = _o->time;
  return CreateMsg0503(
      _fbb,
      _module_type,
      _state,
      _time);
}

inline Msg8105T *Msg8105::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<Msg8105T> _o = std::unique_ptr<Msg8105T>(new Msg8105T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Msg8105::UnPackTo(Msg8105T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = result(); _o->result = _e; }
}

inline flatbuffers::Offset<Msg8105> Msg8105::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg8105T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMsg8105(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Msg8105> CreateMsg8105(flatbuffers::FlatBufferBuilder &_fbb, const Msg8105T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Msg8105T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _result = _o->result;
  return CreateMsg8105(
      _fbb,
      _result);
}

inline Msg8B10T *Msg8B10::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<Msg8B10T> _o = std::unique_ptr<Msg8B10T>(new Msg8B10T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Msg8B10::UnPackTo(Msg8B10T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = result(); _o->result = _e; }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
}

inline flatbuffers::Offset<Msg8B10> Msg8B10::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg8B10T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMsg8B10(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Msg8B10> CreateMsg8B10(flatbuffers::FlatBufferBuilder &_fbb, const Msg8B10T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Msg8B10T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _result = _o->result;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  return CreateMsg8B10(
      _fbb,
      _result,
      _name);
}

inline Msg8B11T *Msg8B11::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<Msg8B11T> _o = std::unique_ptr<Msg8B11T>(new Msg8B11T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Msg8B11::UnPackTo(Msg8B11T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = result(); _o->result = _e; }
}

inline flatbuffers::Offset<Msg8B11> Msg8B11::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg8B11T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMsg8B11(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Msg8B11> CreateMsg8B11(flatbuffers::FlatBufferBuilder &_fbb, const Msg8B11T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Msg8B11T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _result = _o->result;
  return CreateMsg8B11(
      _fbb,
      _result);
}

inline Msg0F0BT *Msg0F0B::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<Msg0F0BT> _o = std::unique_ptr<Msg0F0BT>(new Msg0F0BT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Msg0F0B::UnPackTo(Msg0F0BT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = result(); _o->result = _e; }
}

inline flatbuffers::Offset<Msg0F0B> Msg0F0B::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg0F0BT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMsg0F0B(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Msg0F0B> CreateMsg0F0B(flatbuffers::FlatBufferBuilder &_fbb, const Msg0F0BT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Msg0F0BT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _result = _o->result;
  return CreateMsg0F0B(
      _fbb,
      _result);
}

inline MsgVectorT *MsgVector::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<MsgVectorT> _o = std::unique_ptr<MsgVectorT>(new MsgVectorT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MsgVector::UnPackTo(MsgVectorT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = vectormsg(); if (_e) { _o->vectormsg.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->vectormsg[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<MsgVector> MsgVector::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MsgVectorT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMsgVector(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MsgVector> CreateMsgVector(flatbuffers::FlatBufferBuilder &_fbb, const MsgVectorT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MsgVectorT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _vectormsg = _o->vectormsg.size() ? _fbb.CreateVector(_o->vectormsg) : 0;
  return CreateMsgVector(
      _fbb,
      _vectormsg);
}

inline MsgVoiceNameT *MsgVoiceName::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<MsgVoiceNameT> _o = std::unique_ptr<MsgVoiceNameT>(new MsgVoiceNameT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MsgVoiceName::UnPackTo(MsgVoiceNameT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = voiceName(); if (_e) _o->voiceName = _e->str(); }
}

inline flatbuffers::Offset<MsgVoiceName> MsgVoiceName::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MsgVoiceNameT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMsgVoiceName(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MsgVoiceName> CreateMsgVoiceName(flatbuffers::FlatBufferBuilder &_fbb, const MsgVoiceNameT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MsgVoiceNameT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _voiceName = _o->voiceName.empty() ? 0 : _fbb.CreateString(_o->voiceName);
  return CreateMsgVoiceName(
      _fbb,
      _voiceName);
}

inline Msg1040T *Msg1040::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<Msg1040T> _o = std::unique_ptr<Msg1040T>(new Msg1040T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Msg1040::UnPackTo(Msg1040T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = imei(); if (_e) _o->imei = _e->str(); }
  { auto _e = objName(); if (_e) _o->objName = _e->str(); }
  { auto _e = uploadAddr(); if (_e) _o->uploadAddr = _e->str(); }
}

inline flatbuffers::Offset<Msg1040> Msg1040::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg1040T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMsg1040(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Msg1040> CreateMsg1040(flatbuffers::FlatBufferBuilder &_fbb, const Msg1040T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Msg1040T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _imei = _o->imei.empty() ? 0 : _fbb.CreateString(_o->imei);
  auto _objName = _o->objName.empty() ? 0 : _fbb.CreateString(_o->objName);
  auto _uploadAddr = _o->uploadAddr.empty() ? 0 : _fbb.CreateString(_o->uploadAddr);
  return CreateMsg1040(
      _fbb,
      _imei,
      _objName,
      _uploadAddr);
}

inline Msg0305T *Msg0305::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<Msg0305T> _o = std::unique_ptr<Msg0305T>(new Msg0305T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Msg0305::UnPackTo(Msg0305T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = truckImei(); if (_e) { _o->truckImei.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->truckImei[_i] = _e->Get(_i); } } }
  { auto _e = auxImei(); if (_e) { _o->auxImei.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->auxImei[_i] = _e->Get(_i); } } }
  { auto _e = truckName(); if (_e) { _o->truckName.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->truckName[_i] = _e->Get(_i); } } }
  { auto _e = auxName(); if (_e) { _o->auxName.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->auxName[_i] = _e->Get(_i); } } }
  { auto _e = workType(); _o->workType = _e; }
  { auto _e = optType(); _o->optType = _e; }
  { auto _e = utcTime(); _o->utcTime = _e; }
}

inline flatbuffers::Offset<Msg0305> Msg0305::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg0305T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMsg0305(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Msg0305> CreateMsg0305(flatbuffers::FlatBufferBuilder &_fbb, const Msg0305T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Msg0305T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _truckImei = _o->truckImei.size() ? _fbb.CreateVector(_o->truckImei) : 0;
  auto _auxImei = _o->auxImei.size() ? _fbb.CreateVector(_o->auxImei) : 0;
  auto _truckName = _o->truckName.size() ? _fbb.CreateVector(_o->truckName) : 0;
  auto _auxName = _o->auxName.size() ? _fbb.CreateVector(_o->auxName) : 0;
  auto _workType = _o->workType;
  auto _optType = _o->optType;
  auto _utcTime = _o->utcTime;
  return CreateMsg0305(
      _fbb,
      _truckImei,
      _auxImei,
      _truckName,
      _auxName,
      _workType,
      _optType,
      _utcTime);
}

inline Msg8305_V2XT *Msg8305_V2X::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<Msg8305_V2XT> _o = std::unique_ptr<Msg8305_V2XT>(new Msg8305_V2XT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Msg8305_V2X::UnPackTo(Msg8305_V2XT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = auxImei(); if (_e) { _o->auxImei.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->auxImei[_i] = _e->Get(_i); } } }
  { auto _e = auxName(); if (_e) { _o->auxName.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->auxName[_i] = _e->Get(_i); } } }
  { auto _e = truckImei(); if (_e) { _o->truckImei.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->truckImei[_i] = _e->Get(_i); } } }
  { auto _e = truckName(); if (_e) { _o->truckName.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->truckName[_i] = _e->Get(_i); } } }
  { auto _e = workType(); _o->workType = _e; }
  { auto _e = optType(); _o->optType = _e; }
  { auto _e = loadState(); _o->loadState = _e; }
  { auto _e = materNum(); _o->materNum = _e; }
  { auto _e = stopPosNum(); _o->stopPosNum = _e; }
  { auto _e = utcTime(); _o->utcTime = _e; }
}

inline flatbuffers::Offset<Msg8305_V2X> Msg8305_V2X::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg8305_V2XT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMsg8305_V2X(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Msg8305_V2X> CreateMsg8305_V2X(flatbuffers::FlatBufferBuilder &_fbb, const Msg8305_V2XT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Msg8305_V2XT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _auxImei = _o->auxImei.size() ? _fbb.CreateVector(_o->auxImei) : 0;
  auto _auxName = _o->auxName.size() ? _fbb.CreateVector(_o->auxName) : 0;
  auto _truckImei = _o->truckImei.size() ? _fbb.CreateVector(_o->truckImei) : 0;
  auto _truckName = _o->truckName.size() ? _fbb.CreateVector(_o->truckName) : 0;
  auto _workType = _o->workType;
  auto _optType = _o->optType;
  auto _loadState = _o->loadState;
  auto _materNum = _o->materNum;
  auto _stopPosNum = _o->stopPosNum;
  auto _utcTime = _o->utcTime;
  return CreateMsg8305_V2X(
      _fbb,
      _auxImei,
      _auxName,
      _truckImei,
      _truckName,
      _workType,
      _optType,
      _loadState,
      _materNum,
      _stopPosNum,
      _utcTime);
}

inline Msg8F0BT *Msg8F0B::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<Msg8F0BT> _o = std::unique_ptr<Msg8F0BT>(new Msg8F0BT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Msg8F0B::UnPackTo(Msg8F0BT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; }
  { auto _e = file_type(); _o->file_type = _e; }
  { auto _e = file_area(); _o->file_area = _e; }
  { auto _e = file_result(); _o->file_result = _e; }
  { auto _e = file_MD5(); if (_e) _o->file_MD5 = _e->str(); }
  { auto _e = file_name(); if (_e) _o->file_name = _e->str(); }
}

inline flatbuffers::Offset<Msg8F0B> Msg8F0B::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg8F0BT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMsg8F0B(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Msg8F0B> CreateMsg8F0B(flatbuffers::FlatBufferBuilder &_fbb, const Msg8F0BT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Msg8F0BT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _file_type = _o->file_type;
  auto _file_area = _o->file_area;
  auto _file_result = _o->file_result;
  auto _file_MD5 = _o->file_MD5.empty() ? 0 : _fbb.CreateString(_o->file_MD5);
  auto _file_name = _o->file_name.empty() ? 0 : _fbb.CreateString(_o->file_name);
  return CreateMsg8F0B(
      _fbb,
      _id,
      _file_type,
      _file_area,
      _file_result,
      _file_MD5,
      _file_name);
}

inline Msg0502T *Msg0502::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<Msg0502T> _o = std::unique_ptr<Msg0502T>(new Msg0502T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Msg0502::UnPackTo(Msg0502T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; }
  { auto _e = trigger_type(); _o->trigger_type = _e; }
}

inline flatbuffers::Offset<Msg0502> Msg0502::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg0502T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMsg0502(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Msg0502> CreateMsg0502(flatbuffers::FlatBufferBuilder &_fbb, const Msg0502T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Msg0502T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _trigger_type = _o->trigger_type;
  return CreateMsg0502(
      _fbb,
      _id,
      _trigger_type);
}

inline Msg0F01T *Msg0F01::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<Msg0F01T> _o = std::unique_ptr<Msg0F01T>(new Msg0F01T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Msg0F01::UnPackTo(Msg0F01T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; }
  { auto _e = work_type(); _o->work_type = _e; }
  { auto _e = delayed_fault_reason(); _o->delayed_fault_reason = _e; }
  { auto _e = delayed_time(); _o->delayed_time = _e; }
}

inline flatbuffers::Offset<Msg0F01> Msg0F01::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg0F01T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMsg0F01(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Msg0F01> CreateMsg0F01(flatbuffers::FlatBufferBuilder &_fbb, const Msg0F01T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Msg0F01T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _work_type = _o->work_type;
  auto _delayed_fault_reason = _o->delayed_fault_reason;
  auto _delayed_time = _o->delayed_time;
  return CreateMsg0F01(
      _fbb,
      _id,
      _work_type,
      _delayed_fault_reason,
      _delayed_time);
}

inline Msg0F0ET *Msg0F0E::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<Msg0F0ET> _o = std::unique_ptr<Msg0F0ET>(new Msg0F0ET());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Msg0F0E::UnPackTo(Msg0F0ET *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; }
  { auto _e = apply_number(); if (_e) { _o->apply_number.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->apply_number[_i] = _e->Get(_i); } } }
  { auto _e = clear_fault(); _o->clear_fault = _e; }
  { auto _e = warning(); if (_e) { _o->warning.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->warning[_i] = _e->Get(_i); } } }
  { auto _e = sourceflag(); _o->sourceflag = _e; }
}

inline flatbuffers::Offset<Msg0F0E> Msg0F0E::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg0F0ET* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMsg0F0E(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Msg0F0E> CreateMsg0F0E(flatbuffers::FlatBufferBuilder &_fbb, const Msg0F0ET *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Msg0F0ET* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _apply_number = _o->apply_number.size() ? _fbb.CreateVector(_o->apply_number) : 0;
  auto _clear_fault = _o->clear_fault;
  auto _warning = _o->warning.size() ? _fbb.CreateVector(_o->warning) : 0;
  auto _sourceflag = _o->sourceflag;
  return CreateMsg0F0E(
      _fbb,
      _id,
      _apply_number,
      _clear_fault,
      _warning,
      _sourceflag);
}

inline Msg0F1CT *Msg0F1C::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<Msg0F1CT> _o = std::unique_ptr<Msg0F1CT>(new Msg0F1CT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Msg0F1C::UnPackTo(Msg0F1CT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; }
  { auto _e = test_type(); _o->test_type = _e; }
}

inline flatbuffers::Offset<Msg0F1C> Msg0F1C::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg0F1CT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMsg0F1C(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Msg0F1C> CreateMsg0F1C(flatbuffers::FlatBufferBuilder &_fbb, const Msg0F1CT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Msg0F1CT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _test_type = _o->test_type;
  return CreateMsg0F1C(
      _fbb,
      _id,
      _test_type);
}

inline Msg0F10T *Msg0F10::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<Msg0F10T> _o = std::unique_ptr<Msg0F10T>(new Msg0F10T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Msg0F10::UnPackTo(Msg0F10T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; }
  { auto _e = number(); _o->number = _e; }
  { auto _e = password(); if (_e) { _o->password.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->password[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<Msg0F10> Msg0F10::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg0F10T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMsg0F10(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Msg0F10> CreateMsg0F10(flatbuffers::FlatBufferBuilder &_fbb, const Msg0F10T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Msg0F10T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _number = _o->number;
  auto _password = _o->password.size() ? _fbb.CreateVector(_o->password) : 0;
  return CreateMsg0F10(
      _fbb,
      _id,
      _number,
      _password);
}

inline Msg0F11T *Msg0F11::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<Msg0F11T> _o = std::unique_ptr<Msg0F11T>(new Msg0F11T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Msg0F11::UnPackTo(Msg0F11T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; }
}

inline flatbuffers::Offset<Msg0F11> Msg0F11::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Msg0F11T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMsg0F11(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Msg0F11> CreateMsg0F11(flatbuffers::FlatBufferBuilder &_fbb, const Msg0F11T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Msg0F11T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  return CreateMsg0F11(
      _fbb,
      _id);
}

inline MsgTx_0104T *MsgTx_0104::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<MsgTx_0104T> _o = std::unique_ptr<MsgTx_0104T>(new MsgTx_0104T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MsgTx_0104::UnPackTo(MsgTx_0104T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<MsgTx_0104> MsgTx_0104::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MsgTx_0104T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMsgTx_0104(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MsgTx_0104> CreateMsgTx_0104(flatbuffers::FlatBufferBuilder &_fbb, const MsgTx_0104T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MsgTx_0104T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return CreateMsgTx_0104(
      _fbb);
}

inline MsgTx_0F03T *MsgTx_0F03::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<MsgTx_0F03T> _o = std::unique_ptr<MsgTx_0F03T>(new MsgTx_0F03T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MsgTx_0F03::UnPackTo(MsgTx_0F03T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = material(); _o->material = _e; }
}

inline flatbuffers::Offset<MsgTx_0F03> MsgTx_0F03::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MsgTx_0F03T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMsgTx_0F03(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MsgTx_0F03> CreateMsgTx_0F03(flatbuffers::FlatBufferBuilder &_fbb, const MsgTx_0F03T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MsgTx_0F03T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _material = _o->material;
  return CreateMsgTx_0F03(
      _fbb,
      _material);
}

inline MsgTx_0F09T *MsgTx_0F09::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<MsgTx_0F09T> _o = std::unique_ptr<MsgTx_0F09T>(new MsgTx_0F09T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MsgTx_0F09::UnPackTo(MsgTx_0F09T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = warn_type(); _o->warn_type = _e; }
  { auto _e = lane_num(); _o->lane_num = _e; }
}

inline flatbuffers::Offset<MsgTx_0F09> MsgTx_0F09::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MsgTx_0F09T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMsgTx_0F09(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MsgTx_0F09> CreateMsgTx_0F09(flatbuffers::FlatBufferBuilder &_fbb, const MsgTx_0F09T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MsgTx_0F09T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _warn_type = _o->warn_type;
  auto _lane_num = _o->lane_num;
  return CreateMsgTx_0F09(
      _fbb,
      _warn_type,
      _lane_num);
}

inline MsgTx_8305T *MsgTx_8305::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<MsgTx_8305T> _o = std::unique_ptr<MsgTx_8305T>(new MsgTx_8305T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MsgTx_8305::UnPackTo(MsgTx_8305T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = remote_imei(); if (_e) _o->remote_imei = _e->str(); }
  { auto _e = remote_name(); if (_e) _o->remote_name = _e->str(); }
  { auto _e = task_type(); _o->task_type = _e; }
  { auto _e = cmd_type(); _o->cmd_type = _e; }
  { auto _e = load_status(); _o->load_status = _e; }
  { auto _e = material_type(); _o->material_type = _e; }
  { auto _e = stop_num(); _o->stop_num = _e; }
  { auto _e = utcTime(); _o->utcTime = _e; }
}

inline flatbuffers::Offset<MsgTx_8305> MsgTx_8305::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MsgTx_8305T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMsgTx_8305(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MsgTx_8305> CreateMsgTx_8305(flatbuffers::FlatBufferBuilder &_fbb, const MsgTx_8305T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MsgTx_8305T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _remote_imei = _o->remote_imei.empty() ? 0 : _fbb.CreateString(_o->remote_imei);
  auto _remote_name = _o->remote_name.empty() ? 0 : _fbb.CreateString(_o->remote_name);
  auto _task_type = _o->task_type;
  auto _cmd_type = _o->cmd_type;
  auto _load_status = _o->load_status;
  auto _material_type = _o->material_type;
  auto _stop_num = _o->stop_num;
  auto _utcTime = _o->utcTime;
  return CreateMsgTx_8305(
      _fbb,
      _remote_imei,
      _remote_name,
      _task_type,
      _cmd_type,
      _load_status,
      _material_type,
      _stop_num,
      _utcTime);
}

inline MsgTx_8B02T *MsgTx_8B02::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<MsgTx_8B02T> _o = std::unique_ptr<MsgTx_8B02T>(new MsgTx_8B02T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MsgTx_8B02::UnPackTo(MsgTx_8B02T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = latitude(); _o->latitude = _e; }
  { auto _e = longitude(); _o->longitude = _e; }
}

inline flatbuffers::Offset<MsgTx_8B02> MsgTx_8B02::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MsgTx_8B02T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMsgTx_8B02(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MsgTx_8B02> CreateMsgTx_8B02(flatbuffers::FlatBufferBuilder &_fbb, const MsgTx_8B02T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MsgTx_8B02T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _latitude = _o->latitude;
  auto _longitude = _o->longitude;
  return CreateMsgTx_8B02(
      _fbb,
      _latitude,
      _longitude);
}

inline MsgTx_8B07_listT *MsgTx_8B07_list::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<MsgTx_8B07_listT> _o = std::unique_ptr<MsgTx_8B07_listT>(new MsgTx_8B07_listT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MsgTx_8B07_list::UnPackTo(MsgTx_8B07_listT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = num(); _o->num = _e; }
  { auto _e = latitude(); _o->latitude = _e; }
  { auto _e = longitude(); _o->longitude = _e; }
  { auto _e = heading(); _o->heading = _e; }
}

inline flatbuffers::Offset<MsgTx_8B07_list> MsgTx_8B07_list::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MsgTx_8B07_listT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMsgTx_8B07_list(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MsgTx_8B07_list> CreateMsgTx_8B07_list(flatbuffers::FlatBufferBuilder &_fbb, const MsgTx_8B07_listT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MsgTx_8B07_listT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _num = _o->num;
  auto _latitude = _o->latitude;
  auto _longitude = _o->longitude;
  auto _heading = _o->heading;
  return CreateMsgTx_8B07_list(
      _fbb,
      _num,
      _latitude,
      _longitude,
      _heading);
}

inline MsgTx_8B07T *MsgTx_8B07::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<MsgTx_8B07T> _o = std::unique_ptr<MsgTx_8B07T>(new MsgTx_8B07T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MsgTx_8B07::UnPackTo(MsgTx_8B07T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = list_num(); _o->list_num = _e; }
  { auto _e = List(); if (_e) { _o->List.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->List[_i] = std::unique_ptr<MsgTx_8B07_listT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<MsgTx_8B07> MsgTx_8B07::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MsgTx_8B07T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMsgTx_8B07(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MsgTx_8B07> CreateMsgTx_8B07(flatbuffers::FlatBufferBuilder &_fbb, const MsgTx_8B07T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MsgTx_8B07T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _list_num = _o->list_num;
  auto _List = _o->List.size() ? _fbb.CreateVector<flatbuffers::Offset<MsgTx_8B07_list>> (_o->List.size(), [](size_t i, _VectorArgs *__va) { return CreateMsgTx_8B07_list(*__va->__fbb, __va->__o->List[i].get(), __va->__rehasher); }, &_va ) : 0;
  return CreateMsgTx_8B07(
      _fbb,
      _list_num,
      _List);
}

inline MsgTx_8B08_listT *MsgTx_8B08_list::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<MsgTx_8B08_listT> _o = std::unique_ptr<MsgTx_8B08_listT>(new MsgTx_8B08_listT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MsgTx_8B08_list::UnPackTo(MsgTx_8B08_listT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = num(); _o->num = _e; }
  { auto _e = status(); _o->status = _e; }
}

inline flatbuffers::Offset<MsgTx_8B08_list> MsgTx_8B08_list::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MsgTx_8B08_listT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMsgTx_8B08_list(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MsgTx_8B08_list> CreateMsgTx_8B08_list(flatbuffers::FlatBufferBuilder &_fbb, const MsgTx_8B08_listT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MsgTx_8B08_listT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _num = _o->num;
  auto _status = _o->status;
  return CreateMsgTx_8B08_list(
      _fbb,
      _num,
      _status);
}

inline MsgTx_8B08T *MsgTx_8B08::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<MsgTx_8B08T> _o = std::unique_ptr<MsgTx_8B08T>(new MsgTx_8B08T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MsgTx_8B08::UnPackTo(MsgTx_8B08T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = list_num(); _o->list_num = _e; }
  { auto _e = List(); if (_e) { _o->List.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->List[_i] = std::unique_ptr<MsgTx_8B08_listT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<MsgTx_8B08> MsgTx_8B08::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MsgTx_8B08T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMsgTx_8B08(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MsgTx_8B08> CreateMsgTx_8B08(flatbuffers::FlatBufferBuilder &_fbb, const MsgTx_8B08T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MsgTx_8B08T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _list_num = _o->list_num;
  auto _List = _o->List.size() ? _fbb.CreateVector<flatbuffers::Offset<MsgTx_8B08_list>> (_o->List.size(), [](size_t i, _VectorArgs *__va) { return CreateMsgTx_8B08_list(*__va->__fbb, __va->__o->List[i].get(), __va->__rehasher); }, &_va ) : 0;
  return CreateMsgTx_8B08(
      _fbb,
      _list_num,
      _List);
}

inline MsgTx_0002T *MsgTx_0002::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<MsgTx_0002T> _o = std::unique_ptr<MsgTx_0002T>(new MsgTx_0002T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MsgTx_0002::UnPackTo(MsgTx_0002T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<MsgTx_0002> MsgTx_0002::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MsgTx_0002T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMsgTx_0002(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MsgTx_0002> CreateMsgTx_0002(flatbuffers::FlatBufferBuilder &_fbb, const MsgTx_0002T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MsgTx_0002T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return CreateMsgTx_0002(
      _fbb);
}

inline MsgCguVersionT *MsgCguVersion::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<MsgCguVersionT> _o = std::unique_ptr<MsgCguVersionT>(new MsgCguVersionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MsgCguVersion::UnPackTo(MsgCguVersionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = product_type(); _o->product_type = _e; }
  { auto _e = vehicle_type(); _o->vehicle_type = _e; }
  { auto _e = module_type(); _o->module_type = _e; }
  { auto _e = data1(); _o->data1 = _e; }
  { auto _e = data2(); _o->data2 = _e; }
  { auto _e = data3(); _o->data3 = _e; }
}

inline flatbuffers::Offset<MsgCguVersion> MsgCguVersion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MsgCguVersionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMsgCguVersion(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MsgCguVersion> CreateMsgCguVersion(flatbuffers::FlatBufferBuilder &_fbb, const MsgCguVersionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MsgCguVersionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _product_type = _o->product_type;
  auto _vehicle_type = _o->vehicle_type;
  auto _module_type = _o->module_type;
  auto _data1 = _o->data1;
  auto _data2 = _o->data2;
  auto _data3 = _o->data3;
  return CreateMsgCguVersion(
      _fbb,
      _product_type,
      _vehicle_type,
      _module_type,
      _data1,
      _data2,
      _data3);
}

inline MsgVechWarnStatT *MsgVechWarnStat::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<MsgVechWarnStatT> _o = std::unique_ptr<MsgVechWarnStatT>(new MsgVechWarnStatT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MsgVechWarnStat::UnPackTo(MsgVechWarnStatT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = Warning(); if (_e) { _o->Warning.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->Warning[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<MsgVechWarnStat> MsgVechWarnStat::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MsgVechWarnStatT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMsgVechWarnStat(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MsgVechWarnStat> CreateMsgVechWarnStat(flatbuffers::FlatBufferBuilder &_fbb, const MsgVechWarnStatT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MsgVechWarnStatT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _Warning = _o->Warning.size() ? _fbb.CreateVector(_o->Warning) : 0;
  return CreateMsgVechWarnStat(
      _fbb,
      _Warning);
}

inline const flatbuffers::TypeTable *TaskDispatchResultTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UCHAR, 0, 0 },
    { flatbuffers::ET_UCHAR, 0, 0 },
    { flatbuffers::ET_UCHAR, 0, 0 },
    { flatbuffers::ET_UCHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    TaskDispatchResultTypeTable
  };
  static const char * const names[] = {
    "Unknown",
    "Success",
    "TargetFailed",
    "RoadFailed"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 4, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TaskFileDownloadResultTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UCHAR, 0, 0 },
    { flatbuffers::ET_UCHAR, 0, 0 },
    { flatbuffers::ET_UCHAR, 0, 0 },
    { flatbuffers::ET_UCHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    TaskFileDownloadResultTypeTable
  };
  static const char * const names[] = {
    "Unknown",
    "Success",
    "DownloadFailed",
    "ExtractFailed"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 4, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Msg2050TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_USHORT, 0, -1 }
  };
  static const char * const names[] = {
    "id",
    "turn_off_cmd",
    "turn_off_cmd_reverse"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Msg8306TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_DOUBLE, 0, -1 },
    { flatbuffers::ET_DOUBLE, 0, -1 },
    { flatbuffers::ET_DOUBLE, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "id",
    "self_vehicle_id",
    "target_id",
    "work_class",
    "cmd_flag",
    "load_status",
    "material_type",
    "parking_lat",
    "parking_lng",
    "parking_head",
    "self_vehicle_name",
    "target_name"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 12, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Msg8F02TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_USHORT, 0, -1 }
  };
  static const char * const names[] = {
    "id",
    "service_state_type",
    "service_delay_reason",
    "time_delay"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Msg8401TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_DOUBLE, 0, -1 },
    { flatbuffers::ET_DOUBLE, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "id",
    "target_id",
    "warning_type",
    "distance",
    "collision_time",
    "vehicle_type",
    "length",
    "width",
    "height",
    "lat",
    "lng",
    "head",
    "speed",
    "east_speed",
    "north_speed",
    "front_angle",
    "road_id",
    "road_direction",
    "gps_time",
    "dname"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 20, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Msg8F0CTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, 0 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    TaskDispatchResultTypeTable
  };
  static const char * const names[] = {
    "id",
    "task_type",
    "task_num",
    "task_dispatch_result",
    "task_target_imei",
    "task_file_md5",
    "targetDevName",
    "siteId",
    "task_file_name"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 9, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Msg8F0DTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 }
  };
  static const char * const names[] = {
    "id",
    "task_modify_type"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Msg8403TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 }
  };
  static const char * const names[] = {
    "id",
    "load_status_from_hmi"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MovementAuthorityTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_DOUBLE, 0, -1 },
    { flatbuffers::ET_DOUBLE, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, 0 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    TaskFileDownloadResultTypeTable
  };
  static const char * const names[] = {
    "road_id",
    "iLatitude",
    "iLongitude",
    "task_file_name",
    "task_file_path",
    "terminal",
    "task_file_download_result",
    "task_file_md5"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 8, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Msg8F0FTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    MovementAuthorityTypeTable
  };
  static const char * const names[] = {
    "id",
    "length",
    "move_authority"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Msg8F10TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "id",
    "task_num",
    "boundary_file_md5",
    "boundary_file_name"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Msg8C01TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 }
  };
  static const char * const names[] = {
    "serialNum",
    "cmdId",
    "result"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Msg8F04TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_USHORT, 0, -1 }
  };
  static const char * const names[] = {
    "materCode"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Msg8F0ATypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "fileType",
    "fileArea",
    "result",
    "targetImei",
    "md5",
    "targetDevName",
    "filePath"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 7, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *WarningArrayTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 }
  };
  static const int64_t values[] = { 0, 16 };
  static const char * const names[] = {
    "warning"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_STRUCT, 1, type_codes, nullptr, values, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Msg8F09TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UCHAR, 0, -1 }
  };
  static const char * const names[] = {
    "remoteid"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *GroupStatusListTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "type",
    "groupNumber",
    "stopNumber",
    "stop_group_status",
    "isOccupied",
    "task_status",
    "drivingMode",
    "deviceImei",
    "deviceName"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 9, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Msg8B01TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    GroupStatusListTypeTable
  };
  static const char * const names[] = {
    "fileName",
    "md5",
    "listNum",
    "List"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *GroupStatusList_WaitInLineTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "taskStat",
    "drivingMode",
    "deviceImei",
    "deviceName"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Msg8B03TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    GroupStatusList_WaitInLineTypeTable
  };
  static const char * const names[] = {
    "listNum",
    "List"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Msg8307TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_ULONG, 0, -1 }
  };
  static const char * const names[] = {
    "src_devID",
    "src_devNA",
    "work_type",
    "oper_type",
    "load_status",
    "mate_type",
    "stop_pos_num",
    "time"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 8, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Msg8308TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_ULONG, 0, -1 }
  };
  static const char * const names[] = {
    "src_devID",
    "src_devNA",
    "work_type",
    "oper_type",
    "time"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Msg0F21TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_ULONG, 0, -1 }
  };
  static const char * const names[] = {
    "work_type",
    "oper_type",
    "time"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Msg0503TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_ULONG, 0, -1 }
  };
  static const char * const names[] = {
    "module_type",
    "state",
    "time"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Msg8105TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UCHAR, 0, -1 }
  };
  static const char * const names[] = {
    "result"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Msg8B10TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "result",
    "name"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Msg8B11TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UCHAR, 0, -1 }
  };
  static const char * const names[] = {
    "result"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Msg0F0BTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UCHAR, 0, -1 }
  };
  static const char * const names[] = {
    "result"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MsgVectorTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UCHAR, 1, -1 }
  };
  static const char * const names[] = {
    "vectormsg"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MsgVoiceNameTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "voiceName"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Msg1040TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "imei",
    "objName",
    "uploadAddr"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Msg0305TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UCHAR, 1, -1 },
    { flatbuffers::ET_UCHAR, 1, -1 },
    { flatbuffers::ET_UCHAR, 1, -1 },
    { flatbuffers::ET_UCHAR, 1, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_ULONG, 0, -1 }
  };
  static const char * const names[] = {
    "truckImei",
    "auxImei",
    "truckName",
    "auxName",
    "workType",
    "optType",
    "utcTime"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 7, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Msg8305_V2XTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UCHAR, 1, -1 },
    { flatbuffers::ET_UCHAR, 1, -1 },
    { flatbuffers::ET_UCHAR, 1, -1 },
    { flatbuffers::ET_UCHAR, 1, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_ULONG, 0, -1 }
  };
  static const char * const names[] = {
    "auxImei",
    "auxName",
    "truckImei",
    "truckName",
    "workType",
    "optType",
    "loadState",
    "materNum",
    "stopPosNum",
    "utcTime"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 10, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Msg8F0BTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "id",
    "file_type",
    "file_area",
    "file_result",
    "file_MD5",
    "file_name"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 6, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Msg0502TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 }
  };
  static const char * const names[] = {
    "id",
    "trigger_type"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Msg0F01TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_USHORT, 0, -1 }
  };
  static const char * const names[] = {
    "id",
    "work_type",
    "delayed_fault_reason",
    "delayed_time"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *apply_numberArrayTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 }
  };
  static const int64_t values[] = { 0, 8 };
  static const char * const names[] = {
    "apply_number"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_STRUCT, 1, type_codes, nullptr, values, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Msg0F0ETypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_UCHAR, 1, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_UCHAR, 1, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 }
  };
  static const char * const names[] = {
    "id",
    "apply_number",
    "clear_fault",
    "warning",
    "sourceflag"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Msg0F1CTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 }
  };
  static const char * const names[] = {
    "id",
    "test_type"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *passwordArrayTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 }
  };
  static const int64_t values[] = { 0, 6 };
  static const char * const names[] = {
    "password"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_STRUCT, 1, type_codes, nullptr, values, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Msg0F10TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_UCHAR, 1, -1 }
  };
  static const char * const names[] = {
    "id",
    "number",
    "password"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Msg0F11TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_USHORT, 0, -1 }
  };
  static const char * const names[] = {
    "id"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MsgTx_0104TypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MsgTx_0F03TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_USHORT, 0, -1 }
  };
  static const char * const names[] = {
    "material"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MsgTx_0F09TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_USHORT, 0, -1 }
  };
  static const char * const names[] = {
    "warn_type",
    "lane_num"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MsgTx_8305TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_ULONG, 0, -1 }
  };
  static const char * const names[] = {
    "remote_imei",
    "remote_name",
    "task_type",
    "cmd_type",
    "load_status",
    "material_type",
    "stop_num",
    "utcTime"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 8, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MsgTx_8B02TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_DOUBLE, 0, -1 },
    { flatbuffers::ET_DOUBLE, 0, -1 }
  };
  static const char * const names[] = {
    "latitude",
    "longitude"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MsgTx_8B07_listTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_DOUBLE, 0, -1 },
    { flatbuffers::ET_DOUBLE, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "num",
    "latitude",
    "longitude",
    "heading"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MsgTx_8B07TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    MsgTx_8B07_listTypeTable
  };
  static const char * const names[] = {
    "list_num",
    "List"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MsgTx_8B08_listTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 }
  };
  static const char * const names[] = {
    "num",
    "status"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MsgTx_8B08TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    MsgTx_8B08_listTypeTable
  };
  static const char * const names[] = {
    "list_num",
    "List"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MsgTx_0002TypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MsgCguVersionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 }
  };
  static const char * const names[] = {
    "product_type",
    "vehicle_type",
    "module_type",
    "data1",
    "data2",
    "data3"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 6, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MsgVechWarnStatTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UCHAR, 1, -1 }
  };
  static const char * const names[] = {
    "Warning"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

#endif  // FLATBUFFERS_GENERATED_CGUPROTOCOL_H_
