// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAPINFO_H_
#define FLATBUFFERS_GENERATED_MAPINFO_H_

#include "flatbuffers/flatbuffers.h"

struct MapApply;
struct MapApplyBuilder;
struct MapApplyT;

struct MapLaneTrailInfo;
struct MapLaneTrailInfoBuilder;
struct MapLaneTrailInfoT;

struct MapLaneInfo;
struct MapLaneInfoBuilder;
struct MapLaneInfoT;

struct MapGpsInfo;
struct MapGpsInfoBuilder;
struct MapGpsInfoT;

struct MapRoadInfo;
struct MapRoadInfoBuilder;
struct MapRoadInfoT;

struct MapBoundaryInfo;
struct MapBoundaryInfoBuilder;
struct MapBoundaryInfoT;

struct MapLaneListInfo;
struct MapLaneListInfoBuilder;
struct MapLaneListInfoT;

struct MapRoadListInfo;
struct MapRoadListInfoBuilder;
struct MapRoadListInfoT;

struct MapBoundaryListInfo;
struct MapBoundaryListInfoBuilder;
struct MapBoundaryListInfoT;

struct MapTaskPointInfo;
struct MapTaskPointInfoBuilder;
struct MapTaskPointInfoT;

struct MapTaskTrailInfo;
struct MapTaskTrailInfoBuilder;
struct MapTaskTrailInfoT;

struct MapTaskInfo;
struct MapTaskInfoBuilder;
struct MapTaskInfoT;

bool operator==(const MapApplyT &lhs, const MapApplyT &rhs);
bool operator!=(const MapApplyT &lhs, const MapApplyT &rhs);
bool operator==(const MapLaneTrailInfoT &lhs, const MapLaneTrailInfoT &rhs);
bool operator!=(const MapLaneTrailInfoT &lhs, const MapLaneTrailInfoT &rhs);
bool operator==(const MapLaneInfoT &lhs, const MapLaneInfoT &rhs);
bool operator!=(const MapLaneInfoT &lhs, const MapLaneInfoT &rhs);
bool operator==(const MapGpsInfoT &lhs, const MapGpsInfoT &rhs);
bool operator!=(const MapGpsInfoT &lhs, const MapGpsInfoT &rhs);
bool operator==(const MapRoadInfoT &lhs, const MapRoadInfoT &rhs);
bool operator!=(const MapRoadInfoT &lhs, const MapRoadInfoT &rhs);
bool operator==(const MapBoundaryInfoT &lhs, const MapBoundaryInfoT &rhs);
bool operator!=(const MapBoundaryInfoT &lhs, const MapBoundaryInfoT &rhs);
bool operator==(const MapLaneListInfoT &lhs, const MapLaneListInfoT &rhs);
bool operator!=(const MapLaneListInfoT &lhs, const MapLaneListInfoT &rhs);
bool operator==(const MapRoadListInfoT &lhs, const MapRoadListInfoT &rhs);
bool operator!=(const MapRoadListInfoT &lhs, const MapRoadListInfoT &rhs);
bool operator==(const MapBoundaryListInfoT &lhs, const MapBoundaryListInfoT &rhs);
bool operator!=(const MapBoundaryListInfoT &lhs, const MapBoundaryListInfoT &rhs);
bool operator==(const MapTaskPointInfoT &lhs, const MapTaskPointInfoT &rhs);
bool operator!=(const MapTaskPointInfoT &lhs, const MapTaskPointInfoT &rhs);
bool operator==(const MapTaskTrailInfoT &lhs, const MapTaskTrailInfoT &rhs);
bool operator!=(const MapTaskTrailInfoT &lhs, const MapTaskTrailInfoT &rhs);
bool operator==(const MapTaskInfoT &lhs, const MapTaskInfoT &rhs);
bool operator!=(const MapTaskInfoT &lhs, const MapTaskInfoT &rhs);

inline const flatbuffers::TypeTable *MapApplyTypeTable();

inline const flatbuffers::TypeTable *MapLaneTrailInfoTypeTable();

inline const flatbuffers::TypeTable *MapLaneInfoTypeTable();

inline const flatbuffers::TypeTable *MapGpsInfoTypeTable();

inline const flatbuffers::TypeTable *MapRoadInfoTypeTable();

inline const flatbuffers::TypeTable *MapBoundaryInfoTypeTable();

inline const flatbuffers::TypeTable *MapLaneListInfoTypeTable();

inline const flatbuffers::TypeTable *MapRoadListInfoTypeTable();

inline const flatbuffers::TypeTable *MapBoundaryListInfoTypeTable();

inline const flatbuffers::TypeTable *MapTaskPointInfoTypeTable();

inline const flatbuffers::TypeTable *MapTaskTrailInfoTypeTable();

inline const flatbuffers::TypeTable *MapTaskInfoTypeTable();

struct MapApplyT : public flatbuffers::NativeTable {
  typedef MapApply TableType;
  int32_t type;
  MapApplyT()
      : type(0) {
  }
};

inline bool operator==(const MapApplyT &lhs, const MapApplyT &rhs) {
  return
      (lhs.type == rhs.type);
}

inline bool operator!=(const MapApplyT &lhs, const MapApplyT &rhs) {
    return !(lhs == rhs);
}


struct MapApply FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MapApplyT NativeTableType;
  typedef MapApplyBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MapApplyTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  bool mutate_type(int32_t _type) {
    return SetField<int32_t>(VT_TYPE, _type, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           verifier.EndTable();
  }
  MapApplyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MapApplyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MapApply> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MapApplyT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MapApplyBuilder {
  typedef MapApply Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(MapApply::VT_TYPE, type, 0);
  }
  explicit MapApplyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MapApply> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MapApply>(end);
    return o;
  }
};

inline flatbuffers::Offset<MapApply> CreateMapApply(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 0) {
  MapApplyBuilder builder_(_fbb);
  builder_.add_type(type);
  return builder_.Finish();
}

flatbuffers::Offset<MapApply> CreateMapApply(flatbuffers::FlatBufferBuilder &_fbb, const MapApplyT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MapLaneTrailInfoT : public flatbuffers::NativeTable {
  typedef MapLaneTrailInfo TableType;
  double heading;
  double lat;
  double lon;
  double alt;
  MapLaneTrailInfoT()
      : heading(0.0),
        lat(0.0),
        lon(0.0),
        alt(0.0) {
  }
};

inline bool operator==(const MapLaneTrailInfoT &lhs, const MapLaneTrailInfoT &rhs) {
  return
      (lhs.heading == rhs.heading) &&
      (lhs.lat == rhs.lat) &&
      (lhs.lon == rhs.lon) &&
      (lhs.alt == rhs.alt);
}

inline bool operator!=(const MapLaneTrailInfoT &lhs, const MapLaneTrailInfoT &rhs) {
    return !(lhs == rhs);
}


struct MapLaneTrailInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MapLaneTrailInfoT NativeTableType;
  typedef MapLaneTrailInfoBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MapLaneTrailInfoTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HEADING = 4,
    VT_LAT = 6,
    VT_LON = 8,
    VT_ALT = 10
  };
  double heading() const {
    return GetField<double>(VT_HEADING, 0.0);
  }
  bool mutate_heading(double _heading) {
    return SetField<double>(VT_HEADING, _heading, 0.0);
  }
  double lat() const {
    return GetField<double>(VT_LAT, 0.0);
  }
  bool mutate_lat(double _lat) {
    return SetField<double>(VT_LAT, _lat, 0.0);
  }
  double lon() const {
    return GetField<double>(VT_LON, 0.0);
  }
  bool mutate_lon(double _lon) {
    return SetField<double>(VT_LON, _lon, 0.0);
  }
  double alt() const {
    return GetField<double>(VT_ALT, 0.0);
  }
  bool mutate_alt(double _alt) {
    return SetField<double>(VT_ALT, _alt, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_HEADING) &&
           VerifyField<double>(verifier, VT_LAT) &&
           VerifyField<double>(verifier, VT_LON) &&
           VerifyField<double>(verifier, VT_ALT) &&
           verifier.EndTable();
  }
  MapLaneTrailInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MapLaneTrailInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MapLaneTrailInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MapLaneTrailInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MapLaneTrailInfoBuilder {
  typedef MapLaneTrailInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_heading(double heading) {
    fbb_.AddElement<double>(MapLaneTrailInfo::VT_HEADING, heading, 0.0);
  }
  void add_lat(double lat) {
    fbb_.AddElement<double>(MapLaneTrailInfo::VT_LAT, lat, 0.0);
  }
  void add_lon(double lon) {
    fbb_.AddElement<double>(MapLaneTrailInfo::VT_LON, lon, 0.0);
  }
  void add_alt(double alt) {
    fbb_.AddElement<double>(MapLaneTrailInfo::VT_ALT, alt, 0.0);
  }
  explicit MapLaneTrailInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MapLaneTrailInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MapLaneTrailInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<MapLaneTrailInfo> CreateMapLaneTrailInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    double heading = 0.0,
    double lat = 0.0,
    double lon = 0.0,
    double alt = 0.0) {
  MapLaneTrailInfoBuilder builder_(_fbb);
  builder_.add_alt(alt);
  builder_.add_lon(lon);
  builder_.add_lat(lat);
  builder_.add_heading(heading);
  return builder_.Finish();
}

flatbuffers::Offset<MapLaneTrailInfo> CreateMapLaneTrailInfo(flatbuffers::FlatBufferBuilder &_fbb, const MapLaneTrailInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MapLaneInfoT : public flatbuffers::NativeTable {
  typedef MapLaneInfo TableType;
  int32_t lane_id;
  int32_t element_type;
  int32_t element_id;
  std::string lane_name;
  float length;
  std::vector<std::unique_ptr<MapLaneTrailInfoT>> trail_list;
  MapLaneInfoT()
      : lane_id(0),
        element_type(0),
        element_id(0),
        length(0.0f) {
  }
};

inline bool operator==(const MapLaneInfoT &lhs, const MapLaneInfoT &rhs) {
  return
      (lhs.lane_id == rhs.lane_id) &&
      (lhs.element_type == rhs.element_type) &&
      (lhs.element_id == rhs.element_id) &&
      (lhs.lane_name == rhs.lane_name) &&
      (lhs.length == rhs.length) &&
      (lhs.trail_list == rhs.trail_list);
}

inline bool operator!=(const MapLaneInfoT &lhs, const MapLaneInfoT &rhs) {
    return !(lhs == rhs);
}


struct MapLaneInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MapLaneInfoT NativeTableType;
  typedef MapLaneInfoBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MapLaneInfoTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LANE_ID = 4,
    VT_ELEMENT_TYPE = 6,
    VT_ELEMENT_ID = 8,
    VT_LANE_NAME = 10,
    VT_LENGTH = 12,
    VT_TRAIL_LIST = 14
  };
  int32_t lane_id() const {
    return GetField<int32_t>(VT_LANE_ID, 0);
  }
  bool mutate_lane_id(int32_t _lane_id) {
    return SetField<int32_t>(VT_LANE_ID, _lane_id, 0);
  }
  int32_t element_type() const {
    return GetField<int32_t>(VT_ELEMENT_TYPE, 0);
  }
  bool mutate_element_type(int32_t _element_type) {
    return SetField<int32_t>(VT_ELEMENT_TYPE, _element_type, 0);
  }
  int32_t element_id() const {
    return GetField<int32_t>(VT_ELEMENT_ID, 0);
  }
  bool mutate_element_id(int32_t _element_id) {
    return SetField<int32_t>(VT_ELEMENT_ID, _element_id, 0);
  }
  const flatbuffers::String *lane_name() const {
    return GetPointer<const flatbuffers::String *>(VT_LANE_NAME);
  }
  flatbuffers::String *mutable_lane_name() {
    return GetPointer<flatbuffers::String *>(VT_LANE_NAME);
  }
  float length() const {
    return GetField<float>(VT_LENGTH, 0.0f);
  }
  bool mutate_length(float _length) {
    return SetField<float>(VT_LENGTH, _length, 0.0f);
  }
  const flatbuffers::Vector<flatbuffers::Offset<MapLaneTrailInfo>> *trail_list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<MapLaneTrailInfo>> *>(VT_TRAIL_LIST);
  }
  flatbuffers::Vector<flatbuffers::Offset<MapLaneTrailInfo>> *mutable_trail_list() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<MapLaneTrailInfo>> *>(VT_TRAIL_LIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_LANE_ID) &&
           VerifyField<int32_t>(verifier, VT_ELEMENT_TYPE) &&
           VerifyField<int32_t>(verifier, VT_ELEMENT_ID) &&
           VerifyOffset(verifier, VT_LANE_NAME) &&
           verifier.VerifyString(lane_name()) &&
           VerifyField<float>(verifier, VT_LENGTH) &&
           VerifyOffset(verifier, VT_TRAIL_LIST) &&
           verifier.VerifyVector(trail_list()) &&
           verifier.VerifyVectorOfTables(trail_list()) &&
           verifier.EndTable();
  }
  MapLaneInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MapLaneInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MapLaneInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MapLaneInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MapLaneInfoBuilder {
  typedef MapLaneInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_lane_id(int32_t lane_id) {
    fbb_.AddElement<int32_t>(MapLaneInfo::VT_LANE_ID, lane_id, 0);
  }
  void add_element_type(int32_t element_type) {
    fbb_.AddElement<int32_t>(MapLaneInfo::VT_ELEMENT_TYPE, element_type, 0);
  }
  void add_element_id(int32_t element_id) {
    fbb_.AddElement<int32_t>(MapLaneInfo::VT_ELEMENT_ID, element_id, 0);
  }
  void add_lane_name(flatbuffers::Offset<flatbuffers::String> lane_name) {
    fbb_.AddOffset(MapLaneInfo::VT_LANE_NAME, lane_name);
  }
  void add_length(float length) {
    fbb_.AddElement<float>(MapLaneInfo::VT_LENGTH, length, 0.0f);
  }
  void add_trail_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MapLaneTrailInfo>>> trail_list) {
    fbb_.AddOffset(MapLaneInfo::VT_TRAIL_LIST, trail_list);
  }
  explicit MapLaneInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MapLaneInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MapLaneInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<MapLaneInfo> CreateMapLaneInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t lane_id = 0,
    int32_t element_type = 0,
    int32_t element_id = 0,
    flatbuffers::Offset<flatbuffers::String> lane_name = 0,
    float length = 0.0f,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MapLaneTrailInfo>>> trail_list = 0) {
  MapLaneInfoBuilder builder_(_fbb);
  builder_.add_trail_list(trail_list);
  builder_.add_length(length);
  builder_.add_lane_name(lane_name);
  builder_.add_element_id(element_id);
  builder_.add_element_type(element_type);
  builder_.add_lane_id(lane_id);
  return builder_.Finish();
}

inline flatbuffers::Offset<MapLaneInfo> CreateMapLaneInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t lane_id = 0,
    int32_t element_type = 0,
    int32_t element_id = 0,
    const char *lane_name = nullptr,
    float length = 0.0f,
    const std::vector<flatbuffers::Offset<MapLaneTrailInfo>> *trail_list = nullptr) {
  auto lane_name__ = lane_name ? _fbb.CreateString(lane_name) : 0;
  auto trail_list__ = trail_list ? _fbb.CreateVector<flatbuffers::Offset<MapLaneTrailInfo>>(*trail_list) : 0;
  return CreateMapLaneInfo(
      _fbb,
      lane_id,
      element_type,
      element_id,
      lane_name__,
      length,
      trail_list__);
}

flatbuffers::Offset<MapLaneInfo> CreateMapLaneInfo(flatbuffers::FlatBufferBuilder &_fbb, const MapLaneInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MapGpsInfoT : public flatbuffers::NativeTable {
  typedef MapGpsInfo TableType;
  double lat;
  double lon;
  double alt;
  MapGpsInfoT()
      : lat(0.0),
        lon(0.0),
        alt(0.0) {
  }
};

inline bool operator==(const MapGpsInfoT &lhs, const MapGpsInfoT &rhs) {
  return
      (lhs.lat == rhs.lat) &&
      (lhs.lon == rhs.lon) &&
      (lhs.alt == rhs.alt);
}

inline bool operator!=(const MapGpsInfoT &lhs, const MapGpsInfoT &rhs) {
    return !(lhs == rhs);
}


struct MapGpsInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MapGpsInfoT NativeTableType;
  typedef MapGpsInfoBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MapGpsInfoTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LAT = 4,
    VT_LON = 6,
    VT_ALT = 8
  };
  double lat() const {
    return GetField<double>(VT_LAT, 0.0);
  }
  bool mutate_lat(double _lat) {
    return SetField<double>(VT_LAT, _lat, 0.0);
  }
  double lon() const {
    return GetField<double>(VT_LON, 0.0);
  }
  bool mutate_lon(double _lon) {
    return SetField<double>(VT_LON, _lon, 0.0);
  }
  double alt() const {
    return GetField<double>(VT_ALT, 0.0);
  }
  bool mutate_alt(double _alt) {
    return SetField<double>(VT_ALT, _alt, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_LAT) &&
           VerifyField<double>(verifier, VT_LON) &&
           VerifyField<double>(verifier, VT_ALT) &&
           verifier.EndTable();
  }
  MapGpsInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MapGpsInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MapGpsInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MapGpsInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MapGpsInfoBuilder {
  typedef MapGpsInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_lat(double lat) {
    fbb_.AddElement<double>(MapGpsInfo::VT_LAT, lat, 0.0);
  }
  void add_lon(double lon) {
    fbb_.AddElement<double>(MapGpsInfo::VT_LON, lon, 0.0);
  }
  void add_alt(double alt) {
    fbb_.AddElement<double>(MapGpsInfo::VT_ALT, alt, 0.0);
  }
  explicit MapGpsInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MapGpsInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MapGpsInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<MapGpsInfo> CreateMapGpsInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    double lat = 0.0,
    double lon = 0.0,
    double alt = 0.0) {
  MapGpsInfoBuilder builder_(_fbb);
  builder_.add_alt(alt);
  builder_.add_lon(lon);
  builder_.add_lat(lat);
  return builder_.Finish();
}

flatbuffers::Offset<MapGpsInfo> CreateMapGpsInfo(flatbuffers::FlatBufferBuilder &_fbb, const MapGpsInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MapRoadInfoT : public flatbuffers::NativeTable {
  typedef MapRoadInfo TableType;
  int32_t road_id;
  std::string road_name;
  std::vector<std::unique_ptr<MapGpsInfoT>> left_list;
  std::vector<std::unique_ptr<MapGpsInfoT>> right_list;
  MapRoadInfoT()
      : road_id(0) {
  }
};

inline bool operator==(const MapRoadInfoT &lhs, const MapRoadInfoT &rhs) {
  return
      (lhs.road_id == rhs.road_id) &&
      (lhs.road_name == rhs.road_name) &&
      (lhs.left_list == rhs.left_list) &&
      (lhs.right_list == rhs.right_list);
}

inline bool operator!=(const MapRoadInfoT &lhs, const MapRoadInfoT &rhs) {
    return !(lhs == rhs);
}


struct MapRoadInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MapRoadInfoT NativeTableType;
  typedef MapRoadInfoBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MapRoadInfoTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ROAD_ID = 4,
    VT_ROAD_NAME = 6,
    VT_LEFT_LIST = 8,
    VT_RIGHT_LIST = 10
  };
  int32_t road_id() const {
    return GetField<int32_t>(VT_ROAD_ID, 0);
  }
  bool mutate_road_id(int32_t _road_id) {
    return SetField<int32_t>(VT_ROAD_ID, _road_id, 0);
  }
  const flatbuffers::String *road_name() const {
    return GetPointer<const flatbuffers::String *>(VT_ROAD_NAME);
  }
  flatbuffers::String *mutable_road_name() {
    return GetPointer<flatbuffers::String *>(VT_ROAD_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<MapGpsInfo>> *left_list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<MapGpsInfo>> *>(VT_LEFT_LIST);
  }
  flatbuffers::Vector<flatbuffers::Offset<MapGpsInfo>> *mutable_left_list() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<MapGpsInfo>> *>(VT_LEFT_LIST);
  }
  const flatbuffers::Vector<flatbuffers::Offset<MapGpsInfo>> *right_list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<MapGpsInfo>> *>(VT_RIGHT_LIST);
  }
  flatbuffers::Vector<flatbuffers::Offset<MapGpsInfo>> *mutable_right_list() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<MapGpsInfo>> *>(VT_RIGHT_LIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ROAD_ID) &&
           VerifyOffset(verifier, VT_ROAD_NAME) &&
           verifier.VerifyString(road_name()) &&
           VerifyOffset(verifier, VT_LEFT_LIST) &&
           verifier.VerifyVector(left_list()) &&
           verifier.VerifyVectorOfTables(left_list()) &&
           VerifyOffset(verifier, VT_RIGHT_LIST) &&
           verifier.VerifyVector(right_list()) &&
           verifier.VerifyVectorOfTables(right_list()) &&
           verifier.EndTable();
  }
  MapRoadInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MapRoadInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MapRoadInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MapRoadInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MapRoadInfoBuilder {
  typedef MapRoadInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_road_id(int32_t road_id) {
    fbb_.AddElement<int32_t>(MapRoadInfo::VT_ROAD_ID, road_id, 0);
  }
  void add_road_name(flatbuffers::Offset<flatbuffers::String> road_name) {
    fbb_.AddOffset(MapRoadInfo::VT_ROAD_NAME, road_name);
  }
  void add_left_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MapGpsInfo>>> left_list) {
    fbb_.AddOffset(MapRoadInfo::VT_LEFT_LIST, left_list);
  }
  void add_right_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MapGpsInfo>>> right_list) {
    fbb_.AddOffset(MapRoadInfo::VT_RIGHT_LIST, right_list);
  }
  explicit MapRoadInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MapRoadInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MapRoadInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<MapRoadInfo> CreateMapRoadInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t road_id = 0,
    flatbuffers::Offset<flatbuffers::String> road_name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MapGpsInfo>>> left_list = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MapGpsInfo>>> right_list = 0) {
  MapRoadInfoBuilder builder_(_fbb);
  builder_.add_right_list(right_list);
  builder_.add_left_list(left_list);
  builder_.add_road_name(road_name);
  builder_.add_road_id(road_id);
  return builder_.Finish();
}

inline flatbuffers::Offset<MapRoadInfo> CreateMapRoadInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t road_id = 0,
    const char *road_name = nullptr,
    const std::vector<flatbuffers::Offset<MapGpsInfo>> *left_list = nullptr,
    const std::vector<flatbuffers::Offset<MapGpsInfo>> *right_list = nullptr) {
  auto road_name__ = road_name ? _fbb.CreateString(road_name) : 0;
  auto left_list__ = left_list ? _fbb.CreateVector<flatbuffers::Offset<MapGpsInfo>>(*left_list) : 0;
  auto right_list__ = right_list ? _fbb.CreateVector<flatbuffers::Offset<MapGpsInfo>>(*right_list) : 0;
  return CreateMapRoadInfo(
      _fbb,
      road_id,
      road_name__,
      left_list__,
      right_list__);
}

flatbuffers::Offset<MapRoadInfo> CreateMapRoadInfo(flatbuffers::FlatBufferBuilder &_fbb, const MapRoadInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MapBoundaryInfoT : public flatbuffers::NativeTable {
  typedef MapBoundaryInfo TableType;
  int32_t boundary_id;
  int32_t boundary_type;
  std::string boundary_name;
  std::vector<std::unique_ptr<MapGpsInfoT>> list;
  MapBoundaryInfoT()
      : boundary_id(0),
        boundary_type(0) {
  }
};

inline bool operator==(const MapBoundaryInfoT &lhs, const MapBoundaryInfoT &rhs) {
  return
      (lhs.boundary_id == rhs.boundary_id) &&
      (lhs.boundary_type == rhs.boundary_type) &&
      (lhs.boundary_name == rhs.boundary_name) &&
      (lhs.list == rhs.list);
}

inline bool operator!=(const MapBoundaryInfoT &lhs, const MapBoundaryInfoT &rhs) {
    return !(lhs == rhs);
}


struct MapBoundaryInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MapBoundaryInfoT NativeTableType;
  typedef MapBoundaryInfoBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MapBoundaryInfoTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BOUNDARY_ID = 4,
    VT_BOUNDARY_TYPE = 6,
    VT_BOUNDARY_NAME = 8,
    VT_LIST = 10
  };
  int32_t boundary_id() const {
    return GetField<int32_t>(VT_BOUNDARY_ID, 0);
  }
  bool mutate_boundary_id(int32_t _boundary_id) {
    return SetField<int32_t>(VT_BOUNDARY_ID, _boundary_id, 0);
  }
  int32_t boundary_type() const {
    return GetField<int32_t>(VT_BOUNDARY_TYPE, 0);
  }
  bool mutate_boundary_type(int32_t _boundary_type) {
    return SetField<int32_t>(VT_BOUNDARY_TYPE, _boundary_type, 0);
  }
  const flatbuffers::String *boundary_name() const {
    return GetPointer<const flatbuffers::String *>(VT_BOUNDARY_NAME);
  }
  flatbuffers::String *mutable_boundary_name() {
    return GetPointer<flatbuffers::String *>(VT_BOUNDARY_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<MapGpsInfo>> *list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<MapGpsInfo>> *>(VT_LIST);
  }
  flatbuffers::Vector<flatbuffers::Offset<MapGpsInfo>> *mutable_list() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<MapGpsInfo>> *>(VT_LIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_BOUNDARY_ID) &&
           VerifyField<int32_t>(verifier, VT_BOUNDARY_TYPE) &&
           VerifyOffset(verifier, VT_BOUNDARY_NAME) &&
           verifier.VerifyString(boundary_name()) &&
           VerifyOffset(verifier, VT_LIST) &&
           verifier.VerifyVector(list()) &&
           verifier.VerifyVectorOfTables(list()) &&
           verifier.EndTable();
  }
  MapBoundaryInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MapBoundaryInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MapBoundaryInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MapBoundaryInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MapBoundaryInfoBuilder {
  typedef MapBoundaryInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_boundary_id(int32_t boundary_id) {
    fbb_.AddElement<int32_t>(MapBoundaryInfo::VT_BOUNDARY_ID, boundary_id, 0);
  }
  void add_boundary_type(int32_t boundary_type) {
    fbb_.AddElement<int32_t>(MapBoundaryInfo::VT_BOUNDARY_TYPE, boundary_type, 0);
  }
  void add_boundary_name(flatbuffers::Offset<flatbuffers::String> boundary_name) {
    fbb_.AddOffset(MapBoundaryInfo::VT_BOUNDARY_NAME, boundary_name);
  }
  void add_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MapGpsInfo>>> list) {
    fbb_.AddOffset(MapBoundaryInfo::VT_LIST, list);
  }
  explicit MapBoundaryInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MapBoundaryInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MapBoundaryInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<MapBoundaryInfo> CreateMapBoundaryInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t boundary_id = 0,
    int32_t boundary_type = 0,
    flatbuffers::Offset<flatbuffers::String> boundary_name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MapGpsInfo>>> list = 0) {
  MapBoundaryInfoBuilder builder_(_fbb);
  builder_.add_list(list);
  builder_.add_boundary_name(boundary_name);
  builder_.add_boundary_type(boundary_type);
  builder_.add_boundary_id(boundary_id);
  return builder_.Finish();
}

inline flatbuffers::Offset<MapBoundaryInfo> CreateMapBoundaryInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t boundary_id = 0,
    int32_t boundary_type = 0,
    const char *boundary_name = nullptr,
    const std::vector<flatbuffers::Offset<MapGpsInfo>> *list = nullptr) {
  auto boundary_name__ = boundary_name ? _fbb.CreateString(boundary_name) : 0;
  auto list__ = list ? _fbb.CreateVector<flatbuffers::Offset<MapGpsInfo>>(*list) : 0;
  return CreateMapBoundaryInfo(
      _fbb,
      boundary_id,
      boundary_type,
      boundary_name__,
      list__);
}

flatbuffers::Offset<MapBoundaryInfo> CreateMapBoundaryInfo(flatbuffers::FlatBufferBuilder &_fbb, const MapBoundaryInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MapLaneListInfoT : public flatbuffers::NativeTable {
  typedef MapLaneListInfo TableType;
  std::vector<std::unique_ptr<MapLaneInfoT>> lane_list;
  MapLaneListInfoT() {
  }
};

inline bool operator==(const MapLaneListInfoT &lhs, const MapLaneListInfoT &rhs) {
  return
      (lhs.lane_list == rhs.lane_list);
}

inline bool operator!=(const MapLaneListInfoT &lhs, const MapLaneListInfoT &rhs) {
    return !(lhs == rhs);
}


struct MapLaneListInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MapLaneListInfoT NativeTableType;
  typedef MapLaneListInfoBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MapLaneListInfoTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LANE_LIST = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<MapLaneInfo>> *lane_list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<MapLaneInfo>> *>(VT_LANE_LIST);
  }
  flatbuffers::Vector<flatbuffers::Offset<MapLaneInfo>> *mutable_lane_list() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<MapLaneInfo>> *>(VT_LANE_LIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LANE_LIST) &&
           verifier.VerifyVector(lane_list()) &&
           verifier.VerifyVectorOfTables(lane_list()) &&
           verifier.EndTable();
  }
  MapLaneListInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MapLaneListInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MapLaneListInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MapLaneListInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MapLaneListInfoBuilder {
  typedef MapLaneListInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_lane_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MapLaneInfo>>> lane_list) {
    fbb_.AddOffset(MapLaneListInfo::VT_LANE_LIST, lane_list);
  }
  explicit MapLaneListInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MapLaneListInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MapLaneListInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<MapLaneListInfo> CreateMapLaneListInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MapLaneInfo>>> lane_list = 0) {
  MapLaneListInfoBuilder builder_(_fbb);
  builder_.add_lane_list(lane_list);
  return builder_.Finish();
}

inline flatbuffers::Offset<MapLaneListInfo> CreateMapLaneListInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<MapLaneInfo>> *lane_list = nullptr) {
  auto lane_list__ = lane_list ? _fbb.CreateVector<flatbuffers::Offset<MapLaneInfo>>(*lane_list) : 0;
  return CreateMapLaneListInfo(
      _fbb,
      lane_list__);
}

flatbuffers::Offset<MapLaneListInfo> CreateMapLaneListInfo(flatbuffers::FlatBufferBuilder &_fbb, const MapLaneListInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MapRoadListInfoT : public flatbuffers::NativeTable {
  typedef MapRoadListInfo TableType;
  std::vector<std::unique_ptr<MapRoadInfoT>> road_list;
  MapRoadListInfoT() {
  }
};

inline bool operator==(const MapRoadListInfoT &lhs, const MapRoadListInfoT &rhs) {
  return
      (lhs.road_list == rhs.road_list);
}

inline bool operator!=(const MapRoadListInfoT &lhs, const MapRoadListInfoT &rhs) {
    return !(lhs == rhs);
}


struct MapRoadListInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MapRoadListInfoT NativeTableType;
  typedef MapRoadListInfoBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MapRoadListInfoTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ROAD_LIST = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<MapRoadInfo>> *road_list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<MapRoadInfo>> *>(VT_ROAD_LIST);
  }
  flatbuffers::Vector<flatbuffers::Offset<MapRoadInfo>> *mutable_road_list() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<MapRoadInfo>> *>(VT_ROAD_LIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ROAD_LIST) &&
           verifier.VerifyVector(road_list()) &&
           verifier.VerifyVectorOfTables(road_list()) &&
           verifier.EndTable();
  }
  MapRoadListInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MapRoadListInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MapRoadListInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MapRoadListInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MapRoadListInfoBuilder {
  typedef MapRoadListInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_road_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MapRoadInfo>>> road_list) {
    fbb_.AddOffset(MapRoadListInfo::VT_ROAD_LIST, road_list);
  }
  explicit MapRoadListInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MapRoadListInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MapRoadListInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<MapRoadListInfo> CreateMapRoadListInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MapRoadInfo>>> road_list = 0) {
  MapRoadListInfoBuilder builder_(_fbb);
  builder_.add_road_list(road_list);
  return builder_.Finish();
}

inline flatbuffers::Offset<MapRoadListInfo> CreateMapRoadListInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<MapRoadInfo>> *road_list = nullptr) {
  auto road_list__ = road_list ? _fbb.CreateVector<flatbuffers::Offset<MapRoadInfo>>(*road_list) : 0;
  return CreateMapRoadListInfo(
      _fbb,
      road_list__);
}

flatbuffers::Offset<MapRoadListInfo> CreateMapRoadListInfo(flatbuffers::FlatBufferBuilder &_fbb, const MapRoadListInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MapBoundaryListInfoT : public flatbuffers::NativeTable {
  typedef MapBoundaryListInfo TableType;
  std::vector<std::unique_ptr<MapBoundaryInfoT>> boud_list;
  MapBoundaryListInfoT() {
  }
};

inline bool operator==(const MapBoundaryListInfoT &lhs, const MapBoundaryListInfoT &rhs) {
  return
      (lhs.boud_list == rhs.boud_list);
}

inline bool operator!=(const MapBoundaryListInfoT &lhs, const MapBoundaryListInfoT &rhs) {
    return !(lhs == rhs);
}


struct MapBoundaryListInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MapBoundaryListInfoT NativeTableType;
  typedef MapBoundaryListInfoBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MapBoundaryListInfoTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BOUD_LIST = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<MapBoundaryInfo>> *boud_list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<MapBoundaryInfo>> *>(VT_BOUD_LIST);
  }
  flatbuffers::Vector<flatbuffers::Offset<MapBoundaryInfo>> *mutable_boud_list() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<MapBoundaryInfo>> *>(VT_BOUD_LIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BOUD_LIST) &&
           verifier.VerifyVector(boud_list()) &&
           verifier.VerifyVectorOfTables(boud_list()) &&
           verifier.EndTable();
  }
  MapBoundaryListInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MapBoundaryListInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MapBoundaryListInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MapBoundaryListInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MapBoundaryListInfoBuilder {
  typedef MapBoundaryListInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_boud_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MapBoundaryInfo>>> boud_list) {
    fbb_.AddOffset(MapBoundaryListInfo::VT_BOUD_LIST, boud_list);
  }
  explicit MapBoundaryListInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MapBoundaryListInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MapBoundaryListInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<MapBoundaryListInfo> CreateMapBoundaryListInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MapBoundaryInfo>>> boud_list = 0) {
  MapBoundaryListInfoBuilder builder_(_fbb);
  builder_.add_boud_list(boud_list);
  return builder_.Finish();
}

inline flatbuffers::Offset<MapBoundaryListInfo> CreateMapBoundaryListInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<MapBoundaryInfo>> *boud_list = nullptr) {
  auto boud_list__ = boud_list ? _fbb.CreateVector<flatbuffers::Offset<MapBoundaryInfo>>(*boud_list) : 0;
  return CreateMapBoundaryListInfo(
      _fbb,
      boud_list__);
}

flatbuffers::Offset<MapBoundaryListInfo> CreateMapBoundaryListInfo(flatbuffers::FlatBufferBuilder &_fbb, const MapBoundaryListInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MapTaskPointInfoT : public flatbuffers::NativeTable {
  typedef MapTaskPointInfo TableType;
  int32_t index;
  float speed;
  int32_t laneid;
  int32_t type;
  double lat;
  double lon;
  MapTaskPointInfoT()
      : index(0),
        speed(0.0f),
        laneid(0),
        type(0),
        lat(0.0),
        lon(0.0) {
  }
};

inline bool operator==(const MapTaskPointInfoT &lhs, const MapTaskPointInfoT &rhs) {
  return
      (lhs.index == rhs.index) &&
      (lhs.speed == rhs.speed) &&
      (lhs.laneid == rhs.laneid) &&
      (lhs.type == rhs.type) &&
      (lhs.lat == rhs.lat) &&
      (lhs.lon == rhs.lon);
}

inline bool operator!=(const MapTaskPointInfoT &lhs, const MapTaskPointInfoT &rhs) {
    return !(lhs == rhs);
}


struct MapTaskPointInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MapTaskPointInfoT NativeTableType;
  typedef MapTaskPointInfoBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MapTaskPointInfoTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INDEX = 4,
    VT_SPEED = 6,
    VT_LANEID = 8,
    VT_TYPE = 10,
    VT_LAT = 12,
    VT_LON = 14
  };
  int32_t index() const {
    return GetField<int32_t>(VT_INDEX, 0);
  }
  bool mutate_index(int32_t _index) {
    return SetField<int32_t>(VT_INDEX, _index, 0);
  }
  float speed() const {
    return GetField<float>(VT_SPEED, 0.0f);
  }
  bool mutate_speed(float _speed) {
    return SetField<float>(VT_SPEED, _speed, 0.0f);
  }
  int32_t laneid() const {
    return GetField<int32_t>(VT_LANEID, 0);
  }
  bool mutate_laneid(int32_t _laneid) {
    return SetField<int32_t>(VT_LANEID, _laneid, 0);
  }
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  bool mutate_type(int32_t _type) {
    return SetField<int32_t>(VT_TYPE, _type, 0);
  }
  double lat() const {
    return GetField<double>(VT_LAT, 0.0);
  }
  bool mutate_lat(double _lat) {
    return SetField<double>(VT_LAT, _lat, 0.0);
  }
  double lon() const {
    return GetField<double>(VT_LON, 0.0);
  }
  bool mutate_lon(double _lon) {
    return SetField<double>(VT_LON, _lon, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_INDEX) &&
           VerifyField<float>(verifier, VT_SPEED) &&
           VerifyField<int32_t>(verifier, VT_LANEID) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyField<double>(verifier, VT_LAT) &&
           VerifyField<double>(verifier, VT_LON) &&
           verifier.EndTable();
  }
  MapTaskPointInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MapTaskPointInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MapTaskPointInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MapTaskPointInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MapTaskPointInfoBuilder {
  typedef MapTaskPointInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_index(int32_t index) {
    fbb_.AddElement<int32_t>(MapTaskPointInfo::VT_INDEX, index, 0);
  }
  void add_speed(float speed) {
    fbb_.AddElement<float>(MapTaskPointInfo::VT_SPEED, speed, 0.0f);
  }
  void add_laneid(int32_t laneid) {
    fbb_.AddElement<int32_t>(MapTaskPointInfo::VT_LANEID, laneid, 0);
  }
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(MapTaskPointInfo::VT_TYPE, type, 0);
  }
  void add_lat(double lat) {
    fbb_.AddElement<double>(MapTaskPointInfo::VT_LAT, lat, 0.0);
  }
  void add_lon(double lon) {
    fbb_.AddElement<double>(MapTaskPointInfo::VT_LON, lon, 0.0);
  }
  explicit MapTaskPointInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MapTaskPointInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MapTaskPointInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<MapTaskPointInfo> CreateMapTaskPointInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t index = 0,
    float speed = 0.0f,
    int32_t laneid = 0,
    int32_t type = 0,
    double lat = 0.0,
    double lon = 0.0) {
  MapTaskPointInfoBuilder builder_(_fbb);
  builder_.add_lon(lon);
  builder_.add_lat(lat);
  builder_.add_type(type);
  builder_.add_laneid(laneid);
  builder_.add_speed(speed);
  builder_.add_index(index);
  return builder_.Finish();
}

flatbuffers::Offset<MapTaskPointInfo> CreateMapTaskPointInfo(flatbuffers::FlatBufferBuilder &_fbb, const MapTaskPointInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MapTaskTrailInfoT : public flatbuffers::NativeTable {
  typedef MapTaskTrailInfo TableType;
  int32_t index;
  int32_t laneid;
  double heading;
  double speed;
  double lat;
  double lon;
  int32_t alt;
  MapTaskTrailInfoT()
      : index(0),
        laneid(0),
        heading(0.0),
        speed(0.0),
        lat(0.0),
        lon(0.0),
        alt(0) {
  }
};

inline bool operator==(const MapTaskTrailInfoT &lhs, const MapTaskTrailInfoT &rhs) {
  return
      (lhs.index == rhs.index) &&
      (lhs.laneid == rhs.laneid) &&
      (lhs.heading == rhs.heading) &&
      (lhs.speed == rhs.speed) &&
      (lhs.lat == rhs.lat) &&
      (lhs.lon == rhs.lon) &&
      (lhs.alt == rhs.alt);
}

inline bool operator!=(const MapTaskTrailInfoT &lhs, const MapTaskTrailInfoT &rhs) {
    return !(lhs == rhs);
}


struct MapTaskTrailInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MapTaskTrailInfoT NativeTableType;
  typedef MapTaskTrailInfoBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MapTaskTrailInfoTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INDEX = 4,
    VT_LANEID = 6,
    VT_HEADING = 8,
    VT_SPEED = 10,
    VT_LAT = 12,
    VT_LON = 14,
    VT_ALT = 16
  };
  int32_t index() const {
    return GetField<int32_t>(VT_INDEX, 0);
  }
  bool mutate_index(int32_t _index) {
    return SetField<int32_t>(VT_INDEX, _index, 0);
  }
  int32_t laneid() const {
    return GetField<int32_t>(VT_LANEID, 0);
  }
  bool mutate_laneid(int32_t _laneid) {
    return SetField<int32_t>(VT_LANEID, _laneid, 0);
  }
  double heading() const {
    return GetField<double>(VT_HEADING, 0.0);
  }
  bool mutate_heading(double _heading) {
    return SetField<double>(VT_HEADING, _heading, 0.0);
  }
  double speed() const {
    return GetField<double>(VT_SPEED, 0.0);
  }
  bool mutate_speed(double _speed) {
    return SetField<double>(VT_SPEED, _speed, 0.0);
  }
  double lat() const {
    return GetField<double>(VT_LAT, 0.0);
  }
  bool mutate_lat(double _lat) {
    return SetField<double>(VT_LAT, _lat, 0.0);
  }
  double lon() const {
    return GetField<double>(VT_LON, 0.0);
  }
  bool mutate_lon(double _lon) {
    return SetField<double>(VT_LON, _lon, 0.0);
  }
  int32_t alt() const {
    return GetField<int32_t>(VT_ALT, 0);
  }
  bool mutate_alt(int32_t _alt) {
    return SetField<int32_t>(VT_ALT, _alt, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_INDEX) &&
           VerifyField<int32_t>(verifier, VT_LANEID) &&
           VerifyField<double>(verifier, VT_HEADING) &&
           VerifyField<double>(verifier, VT_SPEED) &&
           VerifyField<double>(verifier, VT_LAT) &&
           VerifyField<double>(verifier, VT_LON) &&
           VerifyField<int32_t>(verifier, VT_ALT) &&
           verifier.EndTable();
  }
  MapTaskTrailInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MapTaskTrailInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MapTaskTrailInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MapTaskTrailInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MapTaskTrailInfoBuilder {
  typedef MapTaskTrailInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_index(int32_t index) {
    fbb_.AddElement<int32_t>(MapTaskTrailInfo::VT_INDEX, index, 0);
  }
  void add_laneid(int32_t laneid) {
    fbb_.AddElement<int32_t>(MapTaskTrailInfo::VT_LANEID, laneid, 0);
  }
  void add_heading(double heading) {
    fbb_.AddElement<double>(MapTaskTrailInfo::VT_HEADING, heading, 0.0);
  }
  void add_speed(double speed) {
    fbb_.AddElement<double>(MapTaskTrailInfo::VT_SPEED, speed, 0.0);
  }
  void add_lat(double lat) {
    fbb_.AddElement<double>(MapTaskTrailInfo::VT_LAT, lat, 0.0);
  }
  void add_lon(double lon) {
    fbb_.AddElement<double>(MapTaskTrailInfo::VT_LON, lon, 0.0);
  }
  void add_alt(int32_t alt) {
    fbb_.AddElement<int32_t>(MapTaskTrailInfo::VT_ALT, alt, 0);
  }
  explicit MapTaskTrailInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MapTaskTrailInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MapTaskTrailInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<MapTaskTrailInfo> CreateMapTaskTrailInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t index = 0,
    int32_t laneid = 0,
    double heading = 0.0,
    double speed = 0.0,
    double lat = 0.0,
    double lon = 0.0,
    int32_t alt = 0) {
  MapTaskTrailInfoBuilder builder_(_fbb);
  builder_.add_lon(lon);
  builder_.add_lat(lat);
  builder_.add_speed(speed);
  builder_.add_heading(heading);
  builder_.add_alt(alt);
  builder_.add_laneid(laneid);
  builder_.add_index(index);
  return builder_.Finish();
}

flatbuffers::Offset<MapTaskTrailInfo> CreateMapTaskTrailInfo(flatbuffers::FlatBufferBuilder &_fbb, const MapTaskTrailInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MapTaskInfoT : public flatbuffers::NativeTable {
  typedef MapTaskInfo TableType;
  std::vector<std::unique_ptr<MapTaskTrailInfoT>> trail_list;
  std::vector<std::unique_ptr<MapTaskPointInfoT>> point_list;
  MapTaskInfoT() {
  }
};

inline bool operator==(const MapTaskInfoT &lhs, const MapTaskInfoT &rhs) {
  return
      (lhs.trail_list == rhs.trail_list) &&
      (lhs.point_list == rhs.point_list);
}

inline bool operator!=(const MapTaskInfoT &lhs, const MapTaskInfoT &rhs) {
    return !(lhs == rhs);
}


struct MapTaskInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MapTaskInfoT NativeTableType;
  typedef MapTaskInfoBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MapTaskInfoTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TRAIL_LIST = 4,
    VT_POINT_LIST = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<MapTaskTrailInfo>> *trail_list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<MapTaskTrailInfo>> *>(VT_TRAIL_LIST);
  }
  flatbuffers::Vector<flatbuffers::Offset<MapTaskTrailInfo>> *mutable_trail_list() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<MapTaskTrailInfo>> *>(VT_TRAIL_LIST);
  }
  const flatbuffers::Vector<flatbuffers::Offset<MapTaskPointInfo>> *point_list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<MapTaskPointInfo>> *>(VT_POINT_LIST);
  }
  flatbuffers::Vector<flatbuffers::Offset<MapTaskPointInfo>> *mutable_point_list() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<MapTaskPointInfo>> *>(VT_POINT_LIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TRAIL_LIST) &&
           verifier.VerifyVector(trail_list()) &&
           verifier.VerifyVectorOfTables(trail_list()) &&
           VerifyOffset(verifier, VT_POINT_LIST) &&
           verifier.VerifyVector(point_list()) &&
           verifier.VerifyVectorOfTables(point_list()) &&
           verifier.EndTable();
  }
  MapTaskInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MapTaskInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MapTaskInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MapTaskInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MapTaskInfoBuilder {
  typedef MapTaskInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_trail_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MapTaskTrailInfo>>> trail_list) {
    fbb_.AddOffset(MapTaskInfo::VT_TRAIL_LIST, trail_list);
  }
  void add_point_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MapTaskPointInfo>>> point_list) {
    fbb_.AddOffset(MapTaskInfo::VT_POINT_LIST, point_list);
  }
  explicit MapTaskInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MapTaskInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MapTaskInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<MapTaskInfo> CreateMapTaskInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MapTaskTrailInfo>>> trail_list = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MapTaskPointInfo>>> point_list = 0) {
  MapTaskInfoBuilder builder_(_fbb);
  builder_.add_point_list(point_list);
  builder_.add_trail_list(trail_list);
  return builder_.Finish();
}

inline flatbuffers::Offset<MapTaskInfo> CreateMapTaskInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<MapTaskTrailInfo>> *trail_list = nullptr,
    const std::vector<flatbuffers::Offset<MapTaskPointInfo>> *point_list = nullptr) {
  auto trail_list__ = trail_list ? _fbb.CreateVector<flatbuffers::Offset<MapTaskTrailInfo>>(*trail_list) : 0;
  auto point_list__ = point_list ? _fbb.CreateVector<flatbuffers::Offset<MapTaskPointInfo>>(*point_list) : 0;
  return CreateMapTaskInfo(
      _fbb,
      trail_list__,
      point_list__);
}

flatbuffers::Offset<MapTaskInfo> CreateMapTaskInfo(flatbuffers::FlatBufferBuilder &_fbb, const MapTaskInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline MapApplyT *MapApply::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<MapApplyT> _o = std::unique_ptr<MapApplyT>(new MapApplyT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MapApply::UnPackTo(MapApplyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; }
}

inline flatbuffers::Offset<MapApply> MapApply::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MapApplyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMapApply(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MapApply> CreateMapApply(flatbuffers::FlatBufferBuilder &_fbb, const MapApplyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MapApplyT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  return CreateMapApply(
      _fbb,
      _type);
}

inline MapLaneTrailInfoT *MapLaneTrailInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<MapLaneTrailInfoT> _o = std::unique_ptr<MapLaneTrailInfoT>(new MapLaneTrailInfoT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MapLaneTrailInfo::UnPackTo(MapLaneTrailInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = heading(); _o->heading = _e; }
  { auto _e = lat(); _o->lat = _e; }
  { auto _e = lon(); _o->lon = _e; }
  { auto _e = alt(); _o->alt = _e; }
}

inline flatbuffers::Offset<MapLaneTrailInfo> MapLaneTrailInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MapLaneTrailInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMapLaneTrailInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MapLaneTrailInfo> CreateMapLaneTrailInfo(flatbuffers::FlatBufferBuilder &_fbb, const MapLaneTrailInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MapLaneTrailInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _heading = _o->heading;
  auto _lat = _o->lat;
  auto _lon = _o->lon;
  auto _alt = _o->alt;
  return CreateMapLaneTrailInfo(
      _fbb,
      _heading,
      _lat,
      _lon,
      _alt);
}

inline MapLaneInfoT *MapLaneInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<MapLaneInfoT> _o = std::unique_ptr<MapLaneInfoT>(new MapLaneInfoT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MapLaneInfo::UnPackTo(MapLaneInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = lane_id(); _o->lane_id = _e; }
  { auto _e = element_type(); _o->element_type = _e; }
  { auto _e = element_id(); _o->element_id = _e; }
  { auto _e = lane_name(); if (_e) _o->lane_name = _e->str(); }
  { auto _e = length(); _o->length = _e; }
  { auto _e = trail_list(); if (_e) { _o->trail_list.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->trail_list[_i] = std::unique_ptr<MapLaneTrailInfoT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<MapLaneInfo> MapLaneInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MapLaneInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMapLaneInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MapLaneInfo> CreateMapLaneInfo(flatbuffers::FlatBufferBuilder &_fbb, const MapLaneInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MapLaneInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _lane_id = _o->lane_id;
  auto _element_type = _o->element_type;
  auto _element_id = _o->element_id;
  auto _lane_name = _o->lane_name.empty() ? 0 : _fbb.CreateString(_o->lane_name);
  auto _length = _o->length;
  auto _trail_list = _o->trail_list.size() ? _fbb.CreateVector<flatbuffers::Offset<MapLaneTrailInfo>> (_o->trail_list.size(), [](size_t i, _VectorArgs *__va) { return CreateMapLaneTrailInfo(*__va->__fbb, __va->__o->trail_list[i].get(), __va->__rehasher); }, &_va ) : 0;
  return CreateMapLaneInfo(
      _fbb,
      _lane_id,
      _element_type,
      _element_id,
      _lane_name,
      _length,
      _trail_list);
}

inline MapGpsInfoT *MapGpsInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<MapGpsInfoT> _o = std::unique_ptr<MapGpsInfoT>(new MapGpsInfoT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MapGpsInfo::UnPackTo(MapGpsInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = lat(); _o->lat = _e; }
  { auto _e = lon(); _o->lon = _e; }
  { auto _e = alt(); _o->alt = _e; }
}

inline flatbuffers::Offset<MapGpsInfo> MapGpsInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MapGpsInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMapGpsInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MapGpsInfo> CreateMapGpsInfo(flatbuffers::FlatBufferBuilder &_fbb, const MapGpsInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MapGpsInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _lat = _o->lat;
  auto _lon = _o->lon;
  auto _alt = _o->alt;
  return CreateMapGpsInfo(
      _fbb,
      _lat,
      _lon,
      _alt);
}

inline MapRoadInfoT *MapRoadInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<MapRoadInfoT> _o = std::unique_ptr<MapRoadInfoT>(new MapRoadInfoT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MapRoadInfo::UnPackTo(MapRoadInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = road_id(); _o->road_id = _e; }
  { auto _e = road_name(); if (_e) _o->road_name = _e->str(); }
  { auto _e = left_list(); if (_e) { _o->left_list.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->left_list[_i] = std::unique_ptr<MapGpsInfoT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = right_list(); if (_e) { _o->right_list.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->right_list[_i] = std::unique_ptr<MapGpsInfoT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<MapRoadInfo> MapRoadInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MapRoadInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMapRoadInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MapRoadInfo> CreateMapRoadInfo(flatbuffers::FlatBufferBuilder &_fbb, const MapRoadInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MapRoadInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _road_id = _o->road_id;
  auto _road_name = _o->road_name.empty() ? 0 : _fbb.CreateString(_o->road_name);
  auto _left_list = _o->left_list.size() ? _fbb.CreateVector<flatbuffers::Offset<MapGpsInfo>> (_o->left_list.size(), [](size_t i, _VectorArgs *__va) { return CreateMapGpsInfo(*__va->__fbb, __va->__o->left_list[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _right_list = _o->right_list.size() ? _fbb.CreateVector<flatbuffers::Offset<MapGpsInfo>> (_o->right_list.size(), [](size_t i, _VectorArgs *__va) { return CreateMapGpsInfo(*__va->__fbb, __va->__o->right_list[i].get(), __va->__rehasher); }, &_va ) : 0;
  return CreateMapRoadInfo(
      _fbb,
      _road_id,
      _road_name,
      _left_list,
      _right_list);
}

inline MapBoundaryInfoT *MapBoundaryInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<MapBoundaryInfoT> _o = std::unique_ptr<MapBoundaryInfoT>(new MapBoundaryInfoT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MapBoundaryInfo::UnPackTo(MapBoundaryInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = boundary_id(); _o->boundary_id = _e; }
  { auto _e = boundary_type(); _o->boundary_type = _e; }
  { auto _e = boundary_name(); if (_e) _o->boundary_name = _e->str(); }
  { auto _e = list(); if (_e) { _o->list.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->list[_i] = std::unique_ptr<MapGpsInfoT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<MapBoundaryInfo> MapBoundaryInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MapBoundaryInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMapBoundaryInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MapBoundaryInfo> CreateMapBoundaryInfo(flatbuffers::FlatBufferBuilder &_fbb, const MapBoundaryInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MapBoundaryInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _boundary_id = _o->boundary_id;
  auto _boundary_type = _o->boundary_type;
  auto _boundary_name = _o->boundary_name.empty() ? 0 : _fbb.CreateString(_o->boundary_name);
  auto _list = _o->list.size() ? _fbb.CreateVector<flatbuffers::Offset<MapGpsInfo>> (_o->list.size(), [](size_t i, _VectorArgs *__va) { return CreateMapGpsInfo(*__va->__fbb, __va->__o->list[i].get(), __va->__rehasher); }, &_va ) : 0;
  return CreateMapBoundaryInfo(
      _fbb,
      _boundary_id,
      _boundary_type,
      _boundary_name,
      _list);
}

inline MapLaneListInfoT *MapLaneListInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<MapLaneListInfoT> _o = std::unique_ptr<MapLaneListInfoT>(new MapLaneListInfoT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MapLaneListInfo::UnPackTo(MapLaneListInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = lane_list(); if (_e) { _o->lane_list.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->lane_list[_i] = std::unique_ptr<MapLaneInfoT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<MapLaneListInfo> MapLaneListInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MapLaneListInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMapLaneListInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MapLaneListInfo> CreateMapLaneListInfo(flatbuffers::FlatBufferBuilder &_fbb, const MapLaneListInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MapLaneListInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _lane_list = _o->lane_list.size() ? _fbb.CreateVector<flatbuffers::Offset<MapLaneInfo>> (_o->lane_list.size(), [](size_t i, _VectorArgs *__va) { return CreateMapLaneInfo(*__va->__fbb, __va->__o->lane_list[i].get(), __va->__rehasher); }, &_va ) : 0;
  return CreateMapLaneListInfo(
      _fbb,
      _lane_list);
}

inline MapRoadListInfoT *MapRoadListInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<MapRoadListInfoT> _o = std::unique_ptr<MapRoadListInfoT>(new MapRoadListInfoT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MapRoadListInfo::UnPackTo(MapRoadListInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = road_list(); if (_e) { _o->road_list.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->road_list[_i] = std::unique_ptr<MapRoadInfoT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<MapRoadListInfo> MapRoadListInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MapRoadListInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMapRoadListInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MapRoadListInfo> CreateMapRoadListInfo(flatbuffers::FlatBufferBuilder &_fbb, const MapRoadListInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MapRoadListInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _road_list = _o->road_list.size() ? _fbb.CreateVector<flatbuffers::Offset<MapRoadInfo>> (_o->road_list.size(), [](size_t i, _VectorArgs *__va) { return CreateMapRoadInfo(*__va->__fbb, __va->__o->road_list[i].get(), __va->__rehasher); }, &_va ) : 0;
  return CreateMapRoadListInfo(
      _fbb,
      _road_list);
}

inline MapBoundaryListInfoT *MapBoundaryListInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<MapBoundaryListInfoT> _o = std::unique_ptr<MapBoundaryListInfoT>(new MapBoundaryListInfoT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MapBoundaryListInfo::UnPackTo(MapBoundaryListInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = boud_list(); if (_e) { _o->boud_list.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->boud_list[_i] = std::unique_ptr<MapBoundaryInfoT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<MapBoundaryListInfo> MapBoundaryListInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MapBoundaryListInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMapBoundaryListInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MapBoundaryListInfo> CreateMapBoundaryListInfo(flatbuffers::FlatBufferBuilder &_fbb, const MapBoundaryListInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MapBoundaryListInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _boud_list = _o->boud_list.size() ? _fbb.CreateVector<flatbuffers::Offset<MapBoundaryInfo>> (_o->boud_list.size(), [](size_t i, _VectorArgs *__va) { return CreateMapBoundaryInfo(*__va->__fbb, __va->__o->boud_list[i].get(), __va->__rehasher); }, &_va ) : 0;
  return CreateMapBoundaryListInfo(
      _fbb,
      _boud_list);
}

inline MapTaskPointInfoT *MapTaskPointInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<MapTaskPointInfoT> _o = std::unique_ptr<MapTaskPointInfoT>(new MapTaskPointInfoT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MapTaskPointInfo::UnPackTo(MapTaskPointInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = index(); _o->index = _e; }
  { auto _e = speed(); _o->speed = _e; }
  { auto _e = laneid(); _o->laneid = _e; }
  { auto _e = type(); _o->type = _e; }
  { auto _e = lat(); _o->lat = _e; }
  { auto _e = lon(); _o->lon = _e; }
}

inline flatbuffers::Offset<MapTaskPointInfo> MapTaskPointInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MapTaskPointInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMapTaskPointInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MapTaskPointInfo> CreateMapTaskPointInfo(flatbuffers::FlatBufferBuilder &_fbb, const MapTaskPointInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MapTaskPointInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _index = _o->index;
  auto _speed = _o->speed;
  auto _laneid = _o->laneid;
  auto _type = _o->type;
  auto _lat = _o->lat;
  auto _lon = _o->lon;
  return CreateMapTaskPointInfo(
      _fbb,
      _index,
      _speed,
      _laneid,
      _type,
      _lat,
      _lon);
}

inline MapTaskTrailInfoT *MapTaskTrailInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<MapTaskTrailInfoT> _o = std::unique_ptr<MapTaskTrailInfoT>(new MapTaskTrailInfoT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MapTaskTrailInfo::UnPackTo(MapTaskTrailInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = index(); _o->index = _e; }
  { auto _e = laneid(); _o->laneid = _e; }
  { auto _e = heading(); _o->heading = _e; }
  { auto _e = speed(); _o->speed = _e; }
  { auto _e = lat(); _o->lat = _e; }
  { auto _e = lon(); _o->lon = _e; }
  { auto _e = alt(); _o->alt = _e; }
}

inline flatbuffers::Offset<MapTaskTrailInfo> MapTaskTrailInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MapTaskTrailInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMapTaskTrailInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MapTaskTrailInfo> CreateMapTaskTrailInfo(flatbuffers::FlatBufferBuilder &_fbb, const MapTaskTrailInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MapTaskTrailInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _index = _o->index;
  auto _laneid = _o->laneid;
  auto _heading = _o->heading;
  auto _speed = _o->speed;
  auto _lat = _o->lat;
  auto _lon = _o->lon;
  auto _alt = _o->alt;
  return CreateMapTaskTrailInfo(
      _fbb,
      _index,
      _laneid,
      _heading,
      _speed,
      _lat,
      _lon,
      _alt);
}

inline MapTaskInfoT *MapTaskInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<MapTaskInfoT> _o = std::unique_ptr<MapTaskInfoT>(new MapTaskInfoT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MapTaskInfo::UnPackTo(MapTaskInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = trail_list(); if (_e) { _o->trail_list.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->trail_list[_i] = std::unique_ptr<MapTaskTrailInfoT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = point_list(); if (_e) { _o->point_list.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->point_list[_i] = std::unique_ptr<MapTaskPointInfoT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<MapTaskInfo> MapTaskInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MapTaskInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMapTaskInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MapTaskInfo> CreateMapTaskInfo(flatbuffers::FlatBufferBuilder &_fbb, const MapTaskInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MapTaskInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _trail_list = _o->trail_list.size() ? _fbb.CreateVector<flatbuffers::Offset<MapTaskTrailInfo>> (_o->trail_list.size(), [](size_t i, _VectorArgs *__va) { return CreateMapTaskTrailInfo(*__va->__fbb, __va->__o->trail_list[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _point_list = _o->point_list.size() ? _fbb.CreateVector<flatbuffers::Offset<MapTaskPointInfo>> (_o->point_list.size(), [](size_t i, _VectorArgs *__va) { return CreateMapTaskPointInfo(*__va->__fbb, __va->__o->point_list[i].get(), __va->__rehasher); }, &_va ) : 0;
  return CreateMapTaskInfo(
      _fbb,
      _trail_list,
      _point_list);
}

inline const flatbuffers::TypeTable *MapApplyTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "type"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MapLaneTrailInfoTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_DOUBLE, 0, -1 },
    { flatbuffers::ET_DOUBLE, 0, -1 },
    { flatbuffers::ET_DOUBLE, 0, -1 },
    { flatbuffers::ET_DOUBLE, 0, -1 }
  };
  static const char * const names[] = {
    "heading",
    "lat",
    "lon",
    "alt"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MapLaneInfoTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    MapLaneTrailInfoTypeTable
  };
  static const char * const names[] = {
    "lane_id",
    "element_type",
    "element_id",
    "lane_name",
    "length",
    "trail_list"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 6, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MapGpsInfoTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_DOUBLE, 0, -1 },
    { flatbuffers::ET_DOUBLE, 0, -1 },
    { flatbuffers::ET_DOUBLE, 0, -1 }
  };
  static const char * const names[] = {
    "lat",
    "lon",
    "alt"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MapRoadInfoTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 0 },
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    MapGpsInfoTypeTable
  };
  static const char * const names[] = {
    "road_id",
    "road_name",
    "left_list",
    "right_list"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MapBoundaryInfoTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    MapGpsInfoTypeTable
  };
  static const char * const names[] = {
    "boundary_id",
    "boundary_type",
    "boundary_name",
    "list"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MapLaneListInfoTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    MapLaneInfoTypeTable
  };
  static const char * const names[] = {
    "lane_list"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MapRoadListInfoTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    MapRoadInfoTypeTable
  };
  static const char * const names[] = {
    "road_list"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MapBoundaryListInfoTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    MapBoundaryInfoTypeTable
  };
  static const char * const names[] = {
    "boud_list"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MapTaskPointInfoTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_DOUBLE, 0, -1 },
    { flatbuffers::ET_DOUBLE, 0, -1 }
  };
  static const char * const names[] = {
    "index",
    "speed",
    "laneid",
    "type",
    "lat",
    "lon"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 6, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MapTaskTrailInfoTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_DOUBLE, 0, -1 },
    { flatbuffers::ET_DOUBLE, 0, -1 },
    { flatbuffers::ET_DOUBLE, 0, -1 },
    { flatbuffers::ET_DOUBLE, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "index",
    "laneid",
    "heading",
    "speed",
    "lat",
    "lon",
    "alt"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 7, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MapTaskInfoTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 1, 0 },
    { flatbuffers::ET_SEQUENCE, 1, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    MapTaskTrailInfoTypeTable,
    MapTaskPointInfoTypeTable
  };
  static const char * const names[] = {
    "trail_list",
    "point_list"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

#endif  // FLATBUFFERS_GENERATED_MAPINFO_H_
